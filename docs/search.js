window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "domino", "modulename": "domino", "kind": "module", "doc": "<h1 id=\"welcome-to-the-domino-documentation\">Welcome to the Domino documentation!</h1>\n\n<p>The five main classes in Domino are:</p>\n\n<p><em>domino.core.LaggedAnalyser</em></p>\n\n<p>For computing lagged composites with respect to categorical time series.</p>\n\n<p><em>domino.core.PatternFilter</em></p>\n\n<p>For applying filters to Boolean masks.</p>\n\n<p><em>domino.core.IndexGenerator</em></p>\n\n<p>For reducing fields to scalar indices by projection onto masked field composites.</p>\n\n<p><em>domino.prediction.PredictionTest</em></p>\n\n<p>For assessing the predictive skill of scalar indices with respect to categorical events.</p>\n\n<p><em>domino.PLSR.PLSR_Reduction</em></p>\n\n<p>For reducing the dimensionality of a multivariate dataset using Partial least squares regression.</p>\n\n<h1 id=\"if-youre-new-to-domino-dont-forget-to-check-out-the-worked-exampleshttpsgithubcomjoshdorringtondominotreemasterexamples\">If you're new to Domino, don't forget to check out the <a href=\"https://github.com/joshdorrington/domino/tree/master/examples\">worked examples</a>!</h1>\n"}, {"fullname": "domino.agg", "modulename": "domino.agg", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "domino.agg.aggregate_ds", "modulename": "domino.agg", "qualname": "aggregate_ds", "kind": "function", "doc": "<p>A wrapper function for applying aggregation functions to datasets.\n<strong>Arguments</strong>\n<em>ds</em> An xarray.Dataset to aggregate\n<em>dim</em> A string specifiying the dimension of <em>ds</em> to aggregate over.\n<em>agg_func</em> An aggregation function with signature (xarray.Dataset,string,**agg_kwargs)->(xarray.Dataset)</p>\n\n<p><strong>Outputs</strong>\nAn xarray.Dataset aggregated over <em>dim</em>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span>, </span><span class=\"param\"><span class=\"n\">dim</span>, </span><span class=\"param\"><span class=\"n\">agg_func</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">agg_kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.agg.mean_ds", "modulename": "domino.agg", "qualname": "mean_ds", "kind": "function", "doc": "<p>Returns the mean of the dataset over dim</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span>, </span><span class=\"param\"><span class=\"n\">dim</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.agg.std_ds", "modulename": "domino.agg", "qualname": "std_ds", "kind": "function", "doc": "<p>Returns the standard deviation of the dataset over dim</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span>, </span><span class=\"param\"><span class=\"n\">dim</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.agg.cat_occ_ds", "modulename": "domino.agg", "qualname": "cat_occ_ds", "kind": "function", "doc": "<p>Returns the occurrence frequency of the dataset's categorical variables</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span>, </span><span class=\"param\"><span class=\"n\">dim</span>, </span><span class=\"param\"><span class=\"n\">cat_ds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.categorical_analysis", "modulename": "domino.categorical_analysis", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "domino.categorical_analysis.get_occurrence", "modulename": "domino.categorical_analysis", "qualname": "get_occurrence", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">states</span>, </span><span class=\"param\"><span class=\"n\">state_combinations</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.categorical_analysis.get_xr_occurrence", "modulename": "domino.categorical_analysis", "qualname": "get_xr_occurrence", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da</span>, </span><span class=\"param\"><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>, </span><span class=\"param\"><span class=\"n\">s</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">coord_name</span><span class=\"o\">=</span><span class=\"s1\">&#39;regime&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.categorical_analysis.get_transmat", "modulename": "domino.categorical_analysis", "qualname": "get_transmat", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">states</span>, </span><span class=\"param\"><span class=\"n\">state_combinations</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">exclude_diag</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">t</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.categorical_analysis.synthetic_states_from_transmat", "modulename": "domino.categorical_analysis", "qualname": "synthetic_states_from_transmat", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">T</span>, </span><span class=\"param\"><span class=\"n\">L</span>, </span><span class=\"param\"><span class=\"n\">init_its</span><span class=\"o\">=</span><span class=\"mi\">50</span>, </span><span class=\"param\"><span class=\"n\">state_labs</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core", "modulename": "domino.core", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "domino.core.LaggedAnalyser", "modulename": "domino.core", "qualname": "LaggedAnalyser", "kind": "class", "doc": "<p>Computes lagged composites of variables with respect to a categorical categorical event series, with support for bootstrap resampling to provide a non-parametric assessment of composite significance, and for deseasonalisation of variables.</p>\n\n<p><strong>Arguments:</strong></p>\n\n<p><em>event</em></p>\n\n<p>An xarray.DataArray with one dimension taking on categorical values, each defining a class of event (or non-event).</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>variables, name, is_categorical</em></p>\n\n<p>Arguments for adding variables to the LaggedAnalyser. Identical behaviour to calling <em>LaggedAnalyser.add_variables</em> directly.</p>\n"}, {"fullname": "domino.core.LaggedAnalyser.__init__", "modulename": "domino.core", "qualname": "LaggedAnalyser.__init__", "kind": "function", "doc": "<p>Initialise a new LaggedAnalyser object.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">event</span>, </span><span class=\"param\"><span class=\"n\">variables</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">is_categorical</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "domino.core.LaggedAnalyser.add_variable", "modulename": "domino.core", "qualname": "LaggedAnalyser.add_variable", "kind": "function", "doc": "<p>Adds an additional variable to LaggedAnalyser.variables.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>variables</em> </p>\n\n<p>An xarray.DataArray, xarray.Dataset or dictionary of xarray.DataArrays, containing data to be composited with respect to <em>event</em>. One of the coordinates of <em>variables</em> should have the same name as the coordinate of <em>events</em>. Stored internally as an xarray.Dataset. If a dictionary is passed, the DataArrays are joined according to the method <em>join_type</em> which defaults to 'outer'.</p>\n\n<p><strong>Optional Arguments</strong></p>\n\n<p><em>name</em> </p>\n\n<p>A string. If <em>variables</em> is a single xarray.DataArray then <em>name</em> will be used as the name of the array in the LaggedAnalyser.variables DataArray. Otherwise ignored.</p>\n\n<p><em>is_categorical</em> </p>\n\n<p>An integer, if <em>variables</em> is an xarray.DataArray, or else a dictionary of integers with keys corresponding to DataArrays in the xarray.Dataset/dictionary. 0 indicates that the variable is continuous, and 1 indicates that it is categorical. Note that continuous and categorical variables are by default composited differently (see LaggedAnalyser.compute_composites). Default assumption is all DataArrays are continuous, unless a DataAarray contains an 'is_categorical' key in its DataArray.attrs, in which case this value is used.</p>\n\n<p><em>overwrite</em></p>\n\n<p>A boolean. If False then attempts to assign a variable who's name is already in <em>LaggedAnalyser.variables</em> will raise a ValueError</p>\n\n<p><em>join_type</em></p>\n\n<p>A string setting the rules for how differences in the coordinate indices of different variables are handled:\n\u201couter\u201d: use the union of object indexes\n\u201cinner\u201d: use the intersection of object indexes</p>\n\n<p>\u201cleft\u201d: use indexes from the pre-existing <em>LaggedAnalyser.variables</em> with each dimension</p>\n\n<p>\u201cright\u201d: use indexes from the new <em>variables</em> with each dimension</p>\n\n<p>\u201cexact\u201d: instead of aligning, raise ValueError when indexes to be aligned are not equal</p>\n\n<p>\u201coverride\u201d: if indexes are of same size, rewrite indexes to be those of the pre-existing <em>LaggedAnalyser.variables</em>. Indexes for the same dimension must have the same size in all objects.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">variables</span>,</span><span class=\"param\">\t<span class=\"n\">name</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">is_categorical</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">join_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;outer&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.lagged_variables", "modulename": "domino.core", "qualname": "LaggedAnalyser.lagged_variables", "kind": "function", "doc": "<p>A convenience function that retrieves variables at lag <em>t</em> from the <em>LaggedAnalyser</em></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">t</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.lag_variables", "modulename": "domino.core", "qualname": "LaggedAnalyser.lag_variables", "kind": "function", "doc": "<p>Produces time lags of <em>LaggedAnalyser.variables</em>, which can be used to produce lagged composites.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>offsets</em></p>\n\n<p>An iterable of integers which represent time lags at which to lag <em>LaggedAnalyser.variables</em> in the units specified by <em>offset_unit</em>. Positive offsets denote variables <em>preceding</em> the event.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>offset_unit</em></p>\n\n<p>A string, defining the units of <em>offsets</em>. Valid options are weeks, days, hours, minutes, seconds, milliseconds, and microseconds.</p>\n\n<p><em>offset_dim</em></p>\n\n<p>A string, defining the coordinate of <em>LaggedAnalyser.variables</em> along which offsets are to be calculated.</p>\n\n<p><em>mode</em></p>\n\n<p>One of 'any', 'past', or 'future'. If 'past' or 'future' is used then only positive or negative lags are valid, respectively.</p>\n\n<p><em>overwrite</em></p>\n\n<p>A boolean. If False, then attempts to produce a lag which already exist will raise a ValueError.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span>,</span><span class=\"param\">\t<span class=\"n\">offset_unit</span><span class=\"o\">=</span><span class=\"s1\">&#39;days&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">offset_dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;any&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">overwrite</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.compute_composites", "modulename": "domino.core", "qualname": "LaggedAnalyser.compute_composites", "kind": "function", "doc": "<p>Partitions <em>LaggedAnalyser.variables</em>, and any time-lagged equivalents, into subsets depending on the value of <em>LaggedAnalyser.event</em>, and then computes a bulk summary metric for each.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>dim</em></p>\n\n<p>A string, the coordinate along which to compute composites.</p>\n\n<p><em>lag_vals</em></p>\n\n<p>Either 'All', or a list of integers, denoting the time lags for which composites should be computed.</p>\n\n<p><em>as_anomaly</em></p>\n\n<p>A Boolean, defining whether composites should be given as absolute values or differences from the unpartitioned value.</p>\n\n<p><em>con_func</em></p>\n\n<p>The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</p>\n\n<p><em>cat_func</em></p>\n\n<p>The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then categorical variables will be ignored</p>\n\n<p><em>inplace</em></p>\n\n<p>A boolean, defining whether the composite should be stored in <em>LaggedAnalyser.composites</em></p>\n\n<p><strong>returns</strong></p>\n\n<p>An xarray.Dataset like  <em>LaggedAnalyser.variables</em> but summarised according to <em>con_func</em> and <em>cat_func</em>, and with an additional coordinate <em>index_val</em>, which indexes over the values taken by <em>LaggedAnalyser.event</em>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">lag_vals</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">as_anomaly</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">con_func</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">mean_ds</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">cat_func</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">cat_occ_ds</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">inplace</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.aggregate_variables", "modulename": "domino.core", "qualname": "LaggedAnalyser.aggregate_variables", "kind": "function", "doc": "<p>Calculates a summary metric from <em>LaggedAnalyser.variables</em> at all points where <em>LaggedAnalyser.event</em> is defined, regardless of its value.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>dim</em></p>\n\n<p>A string, the name of the shared coordinate between <em>LaggedAnalyser.variables</em> and <em>LaggedAnalyser.event</em>.</p>\n\n<p><em>lag_vals</em></p>\n\n<p>'all' or a iterable of integers, specifying for which lag values to compute the summary metric.</p>\n\n<p><em>con_func</em></p>\n\n<p>The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</p>\n\n<p><em>cat_func</em></p>\n\n<p>The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</p>\n\n<p><strong>returns</strong></p>\n\n<p>An xarray.Dataset like  <em>LaggedAnalyser.variables</em> but summarised according to <em>con_func</em> and <em>cat_func</em>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">lag_vals</span><span class=\"o\">=</span><span class=\"s1\">&#39;all&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">con_func</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">mean_ds</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">cat_func</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">cat_occ_ds</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.add_derived_composite", "modulename": "domino.core", "qualname": "LaggedAnalyser.add_derived_composite", "kind": "function", "doc": "<p>Applies <em>func</em> to one or multiple composites to calculate composites of derived quantities, and additionally, stores <em>func</em> to allow derived bootstrap composites to be calculated. For linear quantities, where Ex[f(x)]==f(Ex[x]), then this can minimise redundant memory use.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>name</em></p>\n\n<p>A string, providing the name of the new variable to add.</p>\n\n<p><em>func</em></p>\n\n<p>A callable which must take 1 or more xarray.DataArrays as inputs</p>\n\n<p><em>composite_vars</em></p>\n\n<p>An iterable of strings, of the same length as the number of arguments taken by <em>func</em>. Each string must be the name of a variable in <em>LaggedAnalyser.variables</em> which will be passed into <em>func</em> in order.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>as_anomaly</em></p>\n\n<p>A boolean. Whether anomaly composites or full composites should be passed in to func.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">name</span>, </span><span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"n\">composite_vars</span>, </span><span class=\"param\"><span class=\"n\">as_anomaly</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.compute_bootstraps", "modulename": "domino.core", "qualname": "LaggedAnalyser.compute_bootstraps", "kind": "function", "doc": "<p>Computes composites from synthetic event indices, which can be used to assess whether composites are insignificant.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>bootnum</em></p>\n\n<p>An integer, the number of bootstrapped composites to compute</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>dim</em></p>\n\n<p>A string, the name of the shared coordinate between <em>LaggedAnalyser.variables</em> and <em>LaggedAnalyser.event</em>.</p>\n\n<p><em>con_func</em></p>\n\n<p>The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</p>\n\n<p><em>cat_func</em></p>\n\n<p>The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</p>\n\n<p><em>lag</em></p>\n\n<p>An integer, specifying which lagged variables to use for the bootstraps. i.e. bootstraps for lag=90 will be from a completely different season than those for lag=0.</p>\n\n<p><em>synth_mode</em></p>\n\n<p>A string, specifying how synthetic event indices are to be computed. Valid options are:</p>\n\n<p>\"random\": </p>\n\n<p>categorical values are randomly chosen with the same probability of occurrence as those found in <em>LaggedAnalyser.event</em>, but with no autocorrelation.</p>\n\n<p>\"markov\": </p>\n\n<p>A first order Markov chain is fitted to <em>LaggedAnalyser.event</em>, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than \"random\" and so should normally be used.</p>\n\n<p>\"shuffle\": </p>\n\n<p>The values are randomly reordered. This means that each value will occur exactly the same amount of times as in the original index, and so is ideal for particularly rare events or short series.</p>\n\n<p><em>data_vars</em></p>\n\n<p>An iterable of strings, specifying for which variables bootstraps should be computed.</p>\n\n<p><strong>returns</strong></p>\n\n<p>An xarray.Dataset like <em>LaggedAnalyser.variables</em> but summarised according to <em>con_func</em> and <em>cat_func</em>, and with a new coordinate 'bootnum' of length <em>bootnum</em>.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">bootnum</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">con_func</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">mean_ds</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">cat_func</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">cat_occ_ds</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">lag</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">synth_mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;markov&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">data_vars</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">reuse_ixs</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.get_significance", "modulename": "domino.core", "qualname": "LaggedAnalyser.get_significance", "kind": "function", "doc": "<p>Computes whether a composite is significant with respect to a given distribution of bootstrapped composites. </p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>bootstraps</em></p>\n\n<p>An xarray.Dataset with a coordinate 'bootnum', such as produced by <em>LaggedAnalyser.compute_bootstraps</em></p>\n\n<p><em>comp</em></p>\n\n<p>An xarray Dataset of the same shape as <em>bootstraps</em> but without a 'bootnum' coordinate. Missing or additional variables are allowed, and are simply ignored.\n<em>p</em></p>\n\n<p>A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>data_vars</em></p>\n\n<p>An iterable of strings, specifying for which variables significance should be computed.</p>\n\n<p><em>hb_correction</em></p>\n\n<p>A Boolean, specifying whether a Holm-Bonferroni correction should be applied to <em>p</em>, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in <em>comp</em> independently, and so will have no impact on scalar variables.</p>\n\n<p><strong>returns</strong></p>\n\n<p>An xarray.Dataset like <em>comp</em> but with boolean data, specifying whether each feature of each variable passed the significance test.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">bootstraps</span>, </span><span class=\"param\"><span class=\"n\">comp</span>, </span><span class=\"param\"><span class=\"n\">p</span>, </span><span class=\"param\"><span class=\"n\">data_vars</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">hb_correction</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.bootstrap_significance", "modulename": "domino.core", "qualname": "LaggedAnalyser.bootstrap_significance", "kind": "function", "doc": "<p>A wrapper around <em>compute_bootstraps</em> and <em>get_significance</em>, that calculates bootstraps and applies a significance test to a number of time lagged composites simulataneously.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>bootnum</em></p>\n\n<p>An integer, the number of bootstrapped composites to compute</p>\n\n<p><em>p</em></p>\n\n<p>A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>dim</em></p>\n\n<p>A string, the name of the shared coordinate between <em>LaggedAnalyser.variables</em> and <em>LaggedAnalyser.event</em>.</p>\n\n<p><em>synth_mode</em></p>\n\n<p>A string, specifying how synthetic event indices are to be computed. Valid options are:\n\"random\": categorical values are randomly chosen with the same probability of occurrence as those found in <em>LaggedAnalyser.event</em>, but with no autocorrelation.\n'markov': A first order Markov chain is fitted to <em>LaggedAnalyser.event</em>, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than \"random\" and so should normally be used.</p>\n\n<p><em>reuse_lag0_boots</em>\n    A Boolean. If True, bootstraps are only computed for lag=0, and then used as a null distribution to assess all lagged composites. For variables which are approximately stationary across the lag timescale, then this is a good approximation and can increase performance. However if used incorrectly, it may lead to 'significant composites' which simply reflect the seasonal cycle. if False, separate bootstraps are computed for all time lags.</p>\n\n<p><em>data_vars</em>\n    An iterable of strings, specifying for which variables significance should be computed.</p>\n\n<p><em>hb_correction</em>\n    A Boolean, specifying whether a Holm-Bonferroni correction should be applied to <em>p</em>, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in <em>comp</em> independently, and so will have no impact on scalar variables.</p>\n\n<p><strong>returns</strong></p>\n\n<p>An xarray.Dataset like <em>LaggedAnalyser.variables</em> but with the <em>dim</em> dimension summarised according to <em>con_func</em> and <em>cat_func</em>, an additional <em>lag</em> coordinate, and with boolean data specifying whether each feature of each variable passed the significance test.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">bootnum</span>,</span><span class=\"param\">\t<span class=\"n\">p</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">synth_mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;markov&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">reuse_lag0_boots</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">data_vars</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">hb_correction</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.deseasonalise_variables", "modulename": "domino.core", "qualname": "LaggedAnalyser.deseasonalise_variables", "kind": "function", "doc": "<p>Computes a seasonal cycle for each variable in <em>LaggedAnalyser.variables</em> and subtracts it inplace, turning <em>LaggedAnalyser.variables</em> into deseasonalised anomalies. The seasonal cycle is computed via temporal aggregation of each variable over a given period - by default the calendar day of the year. This cycle can then be smoothed with an n-point rolling average.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>variable_list</em></p>\n\n<p>A list of variables to deseasonalise. Defaults to all variables in the <em>LaggedAnalyser.variables</em></p>\n\n<p><em>dim</em></p>\n\n<p>A string, the name of the shared coordinate between <em>LaggedAnalyser.variables</em> and <em>LaggedAnalyser.event</em>, along which the seasonal cycle is computed. Currently, only timelike coordinates are supported.</p>\n\n<p><em>agg</em></p>\n\n<p>A string specifying the datetime-like field to aggregate over. Useful and supported values are 'season', 'month', 'weekofyear', and 'dayofyear'</p>\n\n<p><em>smooth</em></p>\n\n<p>An integer, specifying the size of the n-timestep centred rolling mean applied to the aggregated seasonal cycle. By default <em>smooth</em>=1 results in no smoothing.</p>\n\n<p><em>coeffs</em></p>\n\n<p>A Dataset containing a precomputed seasonal cycle, which, if <em>LaggedAnalyser.variables</em> has coordinates (<em>dim</em>,[X,Y,...,Z]), has coords (<em>agg</em>,[X,Y,...,Z]), and has the same data variables as <em>LaggedAnalyser.variables</em>. If <em>coeffs</em> is provided, no seasonal cycle is fitted to <em>LaggedAnalyser.variables</em>, <em>coeffs</em> is used instead.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">variable_list</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">agg</span><span class=\"o\">=</span><span class=\"s1\">&#39;dayofyear&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">smooth</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">coeffs</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.get_seasonal_cycle_coeffs", "modulename": "domino.core", "qualname": "LaggedAnalyser.get_seasonal_cycle_coeffs", "kind": "function", "doc": "<p>Retrieve seasonal cycle coeffs computed with <em>LaggedAnalyser.deseasonalise_variables</em>, suitable for passing into <em>coeffs</em> in other <em>LaggedAnalyser.deseasonalise_variables</em> function calls as a precomputed cycle.</p>\n\n<p><strong>Returns</strong>\nAn xarray.Dataset, as specified in  the <em>LaggedAnalyser.deseasonalise_variables</em> <em>coeff</em> optional keyword.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.LaggedAnalyser.get_composite_seasonal_mean", "modulename": "domino.core", "qualname": "LaggedAnalyser.get_composite_seasonal_mean", "kind": "function", "doc": "<p>If <em>LaggedAnalyser.deseasonalise_variables</em> has been called, then this function returns the seasonal mean state corresponding to a given composite, given by a sum of the seasonal cycle weighted by the time-varying occurrence of each categorical value in <em>LaggedAnalyser.events</em>. This mean state + the deseasonalised anomaly composite\nproduced by <em>LaggedAnalyser.compute_composites</em> then retrieves the full composite pattern.</p>\n\n<p><strong>Returns</strong>\n    An xarray.Dataset containing the composite seasonal mean values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.PatternFilter", "modulename": "domino.core", "qualname": "PatternFilter", "kind": "class", "doc": "<p>Provides filtering methods to refine n-dimensional boolean masks, and apply them to an underlying dataset.</p>\n\n<p><strong>Optional arguments:</strong></p>\n\n<p><em>mask_ds</em></p>\n\n<p>An xarray boolean Dataset of arbitrary dimensions which provides the initial mask dataset. If <em>mask_ds</em>=None  and <em>analyser</em>=None, then <em>mask_ds</em> will be initialised as a Dataset of the same dimensions and data_vars as <em>val_ds</em>, with all values = 1 (i.e. initially unmasked). </p>\n\n<p><em>val_ds</em></p>\n\n<p>An xarray Dataset with the same dimensions as <em>mask_ds</em> if provided, otherwise arbitrary, consisting of an underlying dataset to which the mask is applied. If <em>val_ds</em>=None and <em>analyser</em>=None, then <em>PatternFilter.apply_value_mask</em> will raise an Error</p>\n\n<p><em>analyser</em></p>\n\n<p>An instance of a  core.LaggedAnalyser class for which both composites and significance masks have been computed, used to infer the <em>val_ds</em> and <em>mask_ds</em> arguments respectively. This overrides any values passed explicitly to  <em>mask_ds</em> and <em>val_ds</em>.</p>\n"}, {"fullname": "domino.core.PatternFilter.__init__", "modulename": "domino.core", "qualname": "PatternFilter.__init__", "kind": "function", "doc": "<p>Initialise a new PatternFilter object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mask_ds</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">val_ds</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">analyser</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "domino.core.PatternFilter.update_mask", "modulename": "domino.core", "qualname": "PatternFilter.update_mask", "kind": "function", "doc": "<p>Update <em>PatternFilter.mask_ds</em> with a new mask, either taking their union or intersection, or replacing the current mask with new_mask.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>new_mask</em></p>\n\n<p>An xarray.Dataset with the same coords and variables as <em>PatternFilter.mask_ds</em>.</p>\n\n<p><em>mode</em></p>\n\n<p>A string, one of 'replace','intersection' or 'union', defining how <em>new_mask</em> should be used to update the mask.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">new_mask</span>, </span><span class=\"param\"><span class=\"n\">mode</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.PatternFilter.apply_value_mask", "modulename": "domino.core", "qualname": "PatternFilter.apply_value_mask", "kind": "function", "doc": "<p>Apply a filter to <em>PatternFilter.mask_ds</em> based on a user-specified truth function which is applied to *PatternFilter.val_ds. </p>\n\n<p><strong>Examples</strong></p>\n\n<pre><code>#Mask values beneath a threshold:\ndef larger_than_thresh(ds,thresh):\n    return ds&gt;thresh\npatternfilter.apply_value_mask(is_positive,thresh)\n\n#Mask values where absolute value is less than a reference field:\ndef amp_greater_than_reference(ds,ref_ds):\n    return np.abs(ds)&gt;ref_ds\npattern_filter.apply_value_mask(amp_greater_than_reference,ref_ds)\n</code></pre>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>truth_function</em></p>\n\n<p>A function with inputs (val_ds,<em>args) that returns a boolean dataset with the same coords and data variables as *PatternFilter.val_ds</em>.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>mode</em></p>\n\n<p>A string, one of 'replace','intersection' or 'union', defining how the value filter should be used to update the <em>PatternFilter.mask_ds</em>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">truth_function</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;intersection&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.PatternFilter.apply_area_mask", "modulename": "domino.core", "qualname": "PatternFilter.apply_area_mask", "kind": "function", "doc": "<p>Apply a filter to <em>PatternFilter.mask_ds</em> that identifies connected groups of True values within a subspace of the Dataset's dimensions specified by <em>dims</em>, and masks out groups which are beneath a threshold size <em>n</em>. This is done through the application of <em>scipy.ndimage.label</em> using the default structuring element (https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.label.html). </p>\n\n<p>When <em>area_type</em>='gridpoint', <em>n</em> specifies the number of connected datapoints within each connected region. For the special case where <em>dims</em> consists of a latitude- and longitude-like coordinate, area_type='spherical' applies a cosine-latitude weighting, such that <em>n</em> can be interpreted as a measure of area, where a datapoint with lat=0 would have area 1. </p>\n\n<p><strong>Examples</strong></p>\n\n<pre><code>#Keep groups of True values consisting of an area &gt;=30 square equatorial gridpoints\npatternfilter.apply_area_mask(30,dims=('lat','lon'),area_type='spherical')\n\n#Keep groups of True values that are consistent for at least 3 neighbouring time lags\npatternfilter.apply_area_mask(3,dims=('time'))\n\n#Keep groups of true values consisting of &gt;=10 longitudinal values, or &gt;=30 values in longitude and altitude if the variables have an altitude coord:\npatternfilter.apply_area_mask(10,dims=('longitude'))\npatternfilter.apply_area_mask(30,dims=('longitude,altitude'),mode='union')\n</code></pre>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>n</em></p>\n\n<p>A scalar indicating the minimum size of an unmasked group, in terms of number of gridpoints (for <em>area_type</em>=gridpoint) or the weighted area (for <em>area_type</em>=spherical), beneath which the group will be masked.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>dims</em></p>\n\n<p>An iterable of strings specifying coords in <em>PatternFilter.mask_ds</em> which define the subspace in which groups of connected True values are identified. Other dims will be iterated over. DataArrays within <em>PatternFilter.mask_ds</em> that do not contain all the <em>dims</em> will be ignored. If <em>dims</em>=None, all dims in each DataArray will be used.</p>\n\n<p><em>mode</em></p>\n\n<p>A string, one of 'replace','intersection' or 'union', defining how the area filter should be used to update the <em>PatternFilter.mask_ds</em>.</p>\n\n<p><em>area_type</em></p>\n\n<p>A string, one of 'gridpoint' or 'spherical' as specified above. 'spherical' is currently only supported for len-2 <em>dims</em> kwargs, with the first assumed to be latitude-like.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;intersection&#39;</span>, </span><span class=\"param\"><span class=\"n\">area_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;gridpoint&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.PatternFilter.apply_convolution", "modulename": "domino.core", "qualname": "PatternFilter.apply_convolution", "kind": "function", "doc": "<p>Apply a square n-point convolution filter to <em>PatternFilter.mask_ds</em> in one or two dimensions specified by <em>dims</em>, iterated over remaining dimensions. This has the effect of extending the unmasked regions and smoothing the mask overall.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>n</em></p>\n\n<p>A positive integer specifying the size of the convolution filter. <em>n</em>=1 leaves the mask unchanged. Even <em>n</em> are asymmetric and shifted right. </p>\n\n<p><em>dims</em></p>\n\n<p>A length 1 or 2 iterable of strings specifying the dims in which the convolution is applied. Other dims will be iterated over. DataArrays within <em>PatternFilter.mask_ds</em> that do not contain all the <em>dims</em> will be ignored. </p>\n\n<p><em>mode</em></p>\n\n<p>A string, one of 'replace','intersection' or 'union', defining how the area filter should be used to update the <em>PatternFilter.mask_ds</em>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">dims</span>, </span><span class=\"param\"><span class=\"n\">mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;replace&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.PatternFilter.get_mask", "modulename": "domino.core", "qualname": "PatternFilter.get_mask", "kind": "function", "doc": "<p>\" Retrieve the mask with all filters applied.\n<strong>Returns</strong>\nAn xarray.Dataset of boolean values.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.PatternFilter.filter", "modulename": "domino.core", "qualname": "PatternFilter.filter", "kind": "function", "doc": "<p>Apply the current mask to <em>ds</em> or to <em>PatternFilter.val_ds</em> (if <em>ds</em> is None), replacing masked gridpoints with <em>fill_val</em>.\n<strong>Optional arguments</strong></p>\n\n<p><em>ds</em></p>\n\n<p>An xarray.Dataset to apply the mask to. Should have the same coords and data_vars as <em>PatternFilter.mask_ds</em>. If None, the mask is applied to <em>PatternFilter.val_ds</em>.</p>\n\n<p><em>drop_empty</em></p>\n\n<p>A boolean value. If True, then completely masked variables are dropped from the returned masked Dataset.</p>\n\n<p><em>fill_val</em></p>\n\n<p>A scalar that defaults to np.nan. The value with which masked gridpoints in the Dataset are replaced.</p>\n\n<p><strong>Returns</strong></p>\n\n<p>A Dataset with masked values replaced by <em>fill_val</em>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">ds</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">drop_empty</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">fill_val</span><span class=\"o\">=</span><span class=\"n\">nan</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.IndexGenerator", "modulename": "domino.core", "qualname": "IndexGenerator", "kind": "class", "doc": "<p>Computes dot-products between a Dataset of patterns and a Dataset of variables, reducing them to standardised scalar indices.</p>\n"}, {"fullname": "domino.core.IndexGenerator.generate", "modulename": "domino.core", "qualname": "IndexGenerator.generate", "kind": "function", "doc": "<p>Compute standardised indices from an xarray.Dataset of patterns and an xarray.Dataset of arbitrary dimension variables.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>pattern_ds</em></p>\n\n<p>An xarray.Dataset of patterns to project onto with arbitrary dimensions.</p>\n\n<p><em>series_ds</em></p>\n\n<p>An xarray.Dataset of variables to project onto the patterns. Coordinates of <em>series_ds</em> once subsetted using <em>slices</em> must match the dimensions of <em>pattern_ds</em> + the extra coord <em>dim</em>.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>dim</em>:</p>\n\n<p>A string specifying the remaining coord of the scalar indices. Defaults to 'time', which should be the choice for most use cases.</p>\n\n<p><em>slices</em></p>\n\n<p>A dictionary or iterable of dictionaries, each specifying a subset of <em>pattern_ds</em> to take before computing an index, with one index returned for each dictionary and for each variable. Subsetting is based on the <em>xr.Dataset.sel</em> method: e.g. <em>slices</em>=[dict(lag=0,index_val=1)] will produce 1 set of indices based on pattern_ds.sel(lag=0,index_val=1). If <em>slices</em>=None, no subsets are computed.</p>\n\n<p><em>ix_means</em></p>\n\n<p>If None, the mean of each index is calculated and subtracted, resulting in centred indices. Otherwise, <em>ix_means</em> should be a dictionary of index names and predefined mean values which are subtracted instead. Of most use for online computations, updating a precomputed index in a new dataset.</p>\n\n<p><em>ix_stds</em></p>\n\n<p>If None, the standard deviation of each index is calculated and is divided by, resulting in standardised indices. Otherwise, <em>ix_stds</em> should be a dictionary of index names and predefined std values which are divided by instead. Of most use for online computations, updating a precomputed index in a new dataset.</p>\n\n<p><em>drop_blank</em></p>\n\n<p>A boolean. If True, drop indices where the corresponding pattern is entirely blank. If False, returns an all np.nan time series.\n<em>in_place</em></p>\n\n<p><em>strict_metadata</em></p>\n\n<p>If False, indices will be merged into a common dataset regardless of metadata. If True, nonmatching metadata will raise a ValueError.</p>\n\n<p>**Returns</p>\n\n<p>An xarray.Dataset of indices with a single coordinate (<em>dim</em>).</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">pattern_ds</span>,</span><span class=\"param\">\t<span class=\"n\">series_ds</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">slices</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ix_means</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">ix_stds</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">drop_blank</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">in_place</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">strict_metadata</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.core.IndexGenerator.get_standardisation_params", "modulename": "domino.core", "qualname": "IndexGenerator.get_standardisation_params", "kind": "function", "doc": "<p>Retrieve index means and stds for computed indices, for use as future inputs into index_means or index_stds in <em>IndexGenerator.Generate</em></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">as_dict</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.deseasonaliser", "modulename": "domino.deseasonaliser", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "domino.deseasonaliser.Agg_Deseasonaliser", "modulename": "domino.deseasonaliser", "qualname": "Agg_Deseasonaliser", "kind": "class", "doc": "<p>Computes a seasonal cycle from an xarray dataset based on an aggregation\ncriteria i.e. month, day of year, week of year etc.</p>\n"}, {"fullname": "domino.deseasonaliser.Agg_Deseasonaliser.fit_cycle", "modulename": "domino.deseasonaliser", "qualname": "Agg_Deseasonaliser.fit_cycle", "kind": "function", "doc": "<p>Computes a seasonal cycle for <em>arr</em> by aggregating over the coordinate <em>dim</em> and then taking the mean. Default functionality is to compute the average by day of year.\nSeasonal cycle coefficients are stored in self.cycle_coeffs</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>arr</em></p>\n\n<p>An xarray.DataArray for which a seasonal cycle is to be computed.</p>\n\n<p><strong>Optional Arguments</strong></p>\n\n<p><em>dim</em></p>\n\n<p>Defaults to 'time': the time-like dimension of <em>arr</em> along which the seasonal cycle is to be computed. Values of the coordinate must be a Pandas.DatetimeIndex.</p>\n\n<p><em>agg</em></p>\n\n<p>Defaults to 'dayofyear': The time parameter along which aggregation will be carried out. This can be any valid string which specifies a property of Pandas.DatetimeIndex. Likely alternate choices are 'month','day' and 'quarter'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>, </span><span class=\"param\"><span class=\"n\">agg</span><span class=\"o\">=</span><span class=\"s1\">&#39;dayofyear&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.deseasonaliser.Agg_Deseasonaliser.evaluate_cycle", "modulename": "domino.deseasonaliser", "qualname": "Agg_Deseasonaliser.evaluate_cycle", "kind": "function", "doc": "<p>When data is None, creates a seasonal cycle DataArray the same shape as the input data used in fit_cycle.\ndata can be a DataArray with a differing dim coordinate, but matching other coordinates. \nThis can be used to fit a seasonal cycle on one dataset, but evaluate it on  another, as long as the grid, levels, etc are the same.\nReturns The seasonal cycle as a DataArray A centred rolling mean can be optionally applied to the cycle.</p>\n\n<p><strong>Optional Arguments</strong></p>\n\n<p><em>data</em></p>\n\n<p>An xarray.DataArray or Dataset with a time coordinate with the same name as the <em>arr</em> used in fit_cycle.</p>\n\n<p><em>smooth</em></p>\n\n<p>An integer specifying the width of the rolling mean to apply in terms of timesteps. No checks are made that timesteps are evenly spaced!</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">smooth</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.deseasonaliser.Agg_FlexiDeseasonaliser", "modulename": "domino.deseasonaliser", "qualname": "Agg_FlexiDeseasonaliser", "kind": "class", "doc": "<p>Modifies Agg_Deseasonaliser, with the ability\nto handle custom summary funcs other than the mean.\nsummary_func must take an xarray.groupby object, and\naccept a keyword 'dim'.</p>\n", "bases": "Agg_Deseasonaliser"}, {"fullname": "domino.deseasonaliser.Agg_FlexiDeseasonaliser.fit_cycle", "modulename": "domino.deseasonaliser", "qualname": "Agg_FlexiDeseasonaliser.fit_cycle", "kind": "function", "doc": "<p>Computes a seasonal cycle for <em>arr</em> by aggregating over the coordinate <em>dim</em> and then taking the mean. Default functionality is to compute the average by day of year.\nSeasonal cycle coefficients are stored in self.cycle_coeffs</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>arr</em></p>\n\n<p>An xarray.DataArray for which a seasonal cycle is to be computed.</p>\n\n<p><strong>Optional Arguments</strong></p>\n\n<p><em>dim</em></p>\n\n<p>Defaults to 'time': the time-like dimension of <em>arr</em> along which the seasonal cycle is to be computed. Values of the coordinate must be a Pandas.DatetimeIndex.</p>\n\n<p><em>agg</em></p>\n\n<p>Defaults to 'dayofyear': The time parameter along which aggregation will be carried out. This can be any valid string which specifies a property of Pandas.DatetimeIndex. Likely alternate choices are 'month','day' and 'quarter'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">summary_func</span>, </span><span class=\"param\"><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>, </span><span class=\"param\"><span class=\"n\">agg</span><span class=\"o\">=</span><span class=\"s1\">&#39;dayofyear&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.deseasonaliser.Sinefit_Deseasonaliser", "modulename": "domino.deseasonaliser", "qualname": "Sinefit_Deseasonaliser", "kind": "class", "doc": "<p>Same functionalityy as Agg_Deseasonaliser but fits a number of sin modes\nto the data using least squares fitting. This produces a smoother cycle than\naggregating but can be slow for large datasets.</p>\n", "bases": "Agg_Deseasonaliser"}, {"fullname": "domino.deseasonaliser.Sinefit_Deseasonaliser.fit_cycle", "modulename": "domino.deseasonaliser", "qualname": "Sinefit_Deseasonaliser.fit_cycle", "kind": "function", "doc": "<p>N sets the number of sine modes to fit as fractions of the period. i.e. the default of N=4 fits waves with periods of period, period/2, period/3 and period/4. period is a float setting the length of a year in days.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">arr</span>, </span><span class=\"param\"><span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>, </span><span class=\"param\"><span class=\"n\">N</span><span class=\"o\">=</span><span class=\"mi\">4</span>, </span><span class=\"param\"><span class=\"n\">period</span><span class=\"o\">=</span><span class=\"mf\">365.25</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.deseasonaliser.Sinefit_Deseasonaliser.evaluate_cycle", "modulename": "domino.deseasonaliser", "qualname": "Sinefit_Deseasonaliser.evaluate_cycle", "kind": "function", "doc": "<p>As for Agg_Deseasonaliser but without the option for further smoothing.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering", "modulename": "domino.filtering", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "domino.filtering.latlonarea", "modulename": "domino.filtering", "qualname": "latlonarea", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">lat0</span>, </span><span class=\"param\"><span class=\"n\">lat1</span>, </span><span class=\"param\"><span class=\"n\">lon0</span>, </span><span class=\"param\"><span class=\"n\">lon1</span>, </span><span class=\"param\"><span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">6731</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.grid_area", "modulename": "domino.filtering", "qualname": "grid_area", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da</span>, </span><span class=\"param\"><span class=\"n\">lat_coord</span><span class=\"o\">=</span><span class=\"s1\">&#39;lat&#39;</span>, </span><span class=\"param\"><span class=\"n\">lon_coord</span><span class=\"o\">=</span><span class=\"s1\">&#39;lon&#39;</span>, </span><span class=\"param\"><span class=\"n\">r</span><span class=\"o\">=</span><span class=\"mi\">6371</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.apply_2d_func_to_da", "modulename": "domino.filtering", "qualname": "apply_2d_func_to_da", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da</span>, </span><span class=\"param\"><span class=\"n\">func</span>, </span><span class=\"param\"><span class=\"o\">*</span><span class=\"n\">args</span>, </span><span class=\"param\"><span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.get_large_regions", "modulename": "domino.filtering", "qualname": "get_large_regions", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">point_thresh</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.get_area_regions", "modulename": "domino.filtering", "qualname": "get_area_regions", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">area_thresh</span>, </span><span class=\"param\"><span class=\"n\">area</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.da_large_regions", "modulename": "domino.filtering", "qualname": "da_large_regions", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">dims</span>, </span><span class=\"param\"><span class=\"n\">area_based</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.ds_large_regions", "modulename": "domino.filtering", "qualname": "ds_large_regions", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mask_ds</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">dims</span>, </span><span class=\"param\"><span class=\"n\">area_based</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.convolve_pad", "modulename": "domino.filtering", "qualname": "convolve_pad", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">N</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.convolve_pad_da", "modulename": "domino.filtering", "qualname": "convolve_pad_da", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">dims</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.convolve_pad_ds", "modulename": "domino.filtering", "qualname": "convolve_pad_ds", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span>, </span><span class=\"param\"><span class=\"n\">n</span>, </span><span class=\"param\"><span class=\"n\">dims</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.filtering.std_filter", "modulename": "domino.filtering", "qualname": "std_filter", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">val_ds</span>, </span><span class=\"param\"><span class=\"n\">std</span>, </span><span class=\"param\"><span class=\"n\">frac</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.plsr", "modulename": "domino.plsr", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "domino.plsr.PLSR_Reduction", "modulename": "domino.plsr", "qualname": "PLSR_Reduction", "kind": "class", "doc": "<p>Wraps around the scikit-learn partial-least-squares-regression algorithm, supporting prediction-focused dimensionality reduction.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>mode_num</em></p>\n\n<p>An integer number of PLSR modes to retain. Defaults to the second dimension of the predictor variables <em>X</em> passed to <em>PLSR_Reduction.fit</em></p>\n"}, {"fullname": "domino.plsr.PLSR_Reduction.__init__", "modulename": "domino.plsr", "qualname": "PLSR_Reduction.__init__", "kind": "function", "doc": "<p>Initialise a PLSR_Reduction object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mode_num</span></span>)</span>"}, {"fullname": "domino.plsr.PLSR_Reduction.fit", "modulename": "domino.plsr", "qualname": "PLSR_Reduction.fit", "kind": "function", "doc": "<p>Performs the partial-least-squares regression of <em>X</em> against <em>y</em>, returning the transformed PLSR modes.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>X</em></p>\n\n<p>The predictor variables to transform. An xarray.Datarray with two coordinates representing the sample and feature dimensions as specified by <em>sample_dim</em>.</p>\n\n<p><em>y</em></p>\n\n<p>The target variables to be predicted. An xarray.Datarray with two coordinates representing the sample and feature dimensions as specified by <em>sample_dim</em>.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>sample_dim</em></p>\n\n<p>A string specifying the sample dimension which must be shared between <em>X</em> and <em>y</em>. Defaults to <em>time</em>.</p>\n\n<p><strong>Returns</strong></p>\n\n<p><em>plsr_X</em></p>\n\n<p>A DataArray containing PLSR modes, with a sample coordinate given by the intersection of the sample coordinates of <em>X</em> and <em>y</em></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">sample_dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.plsr.PLSR_Reduction.project_quasimodes", "modulename": "domino.plsr", "qualname": "PLSR_Reduction.project_quasimodes", "kind": "function", "doc": "<p>Use precomputed rotation matrix from calling <em>PLSR_Reduction.fit</em> to project <em>X</em> into the space of PLSR modes.\nThis can be used to extend the PLSR modes to times when the target events are not defined.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>X</em></p>\n\n<p>The predictor variables to transform. An xarray.Datarray with two coordinates representing the sample and feature dimensions as specified by the <em>sample_dim</em> used to fit the PLSR regression.</p>\n\n<p><strong>Returns</strong></p>\n\n<p><em>proj_plsr_X</em></p>\n\n<p>A DataArray containing projected PLSR modes, with the same sample coordinate as <em>X</em>.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.plsr.PLSR_Reduction.project_pattern", "modulename": "domino.plsr", "qualname": "PLSR_Reduction.project_pattern", "kind": "function", "doc": "<p>Compute the patterns corresponding to each PLSR mode, by computing a weighted sum of the spatial patterns corresponding to the predictor indices used to fit the partial least squares regression.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>X</em></p>\n\n<p>The pattern to transform. An xarray.Datarray of arbitrary shape, and with an identical feature coordinate to the predictor variables passed into <em>PLSR_Reduction.fit</em>.</p>\n\n<p><strong>Returns</strong></p>\n\n<p><em>pattern</em></p>\n\n<p>A DataArray containing the resulting weighted sums, with the same coordinates as <em>X</em>, except for the feature coordinate is replaced with the PLSR_mode coordinate.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">X</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.prediction", "modulename": "domino.prediction", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "domino.prediction.CV_None", "modulename": "domino.prediction", "qualname": "CV_None", "kind": "function", "doc": "<p>No cross validation: train and test data are the same.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">predictors</span>, </span><span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">cv_kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.prediction.CV_drop1year", "modulename": "domino.prediction", "qualname": "CV_drop1year", "kind": "function", "doc": "<p>Cross validation is performed by dropping out single years of data from the training set to use as test data. This is repeated for all years with non-nan data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">predictors</span>, </span><span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">cv_kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.prediction.CV_n_chunks", "modulename": "domino.prediction", "qualname": "CV_n_chunks", "kind": "function", "doc": "<p>The dataset is split into <em>N</em> chunks and each is successively held out as test data.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">predictors</span>, </span><span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"n\">N</span><span class=\"o\">=</span><span class=\"mi\">2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.prediction.CV_manual", "modulename": "domino.prediction", "qualname": "CV_manual", "kind": "function", "doc": "<p>Separate training and test datasets are passed manually.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">train_pred</span>, </span><span class=\"param\"><span class=\"n\">train_targ</span>, </span><span class=\"param\"><span class=\"n\">test_pred</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">test_targ</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.prediction.log_regression_model", "modulename": "domino.prediction", "qualname": "log_regression_model", "kind": "function", "doc": "<p>A wrapper around sklearn's <em>LogisticRegression</em> class, which accepts the same <em>model_kwargs</em></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X_train</span>, </span><span class=\"param\"><span class=\"n\">y_train</span>, </span><span class=\"param\"><span class=\"n\">X_test</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">model_kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.prediction.ROC_AUC", "modulename": "domino.prediction", "qualname": "ROC_AUC", "kind": "function", "doc": "<p>Computes the ROC AUC score, as implemented in sklearn, and accepting the same <em>score_kwargs</em></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">det_pred</span>, </span><span class=\"param\"><span class=\"n\">prob_pred</span>, </span><span class=\"param\"><span class=\"n\">target</span>, </span><span class=\"param\"><span class=\"o\">**</span><span class=\"n\">score_kwargs</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.prediction.PredictionTest", "modulename": "domino.prediction", "qualname": "PredictionTest", "kind": "class", "doc": "<p>Supports quick and simple testing of the predictive power of predictor variables stored in an xarray.Dataset applied to a target variable stored in an xarray.DataArray.\nSupports different predictive models, cross validation approaches and skill scores within a straightforward API.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>predictors</em></p>\n\n<p>An xarray Dataset of scalar predictors</p>\n\n<p><em>predictand</em></p>\n\n<p>An xarray DataArray with a shared coord to <em>predictors</em>.</p>\n"}, {"fullname": "domino.prediction.PredictionTest.__init__", "modulename": "domino.prediction", "qualname": "PredictionTest.__init__", "kind": "function", "doc": "<p>Initialise a PredictionTest object</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">predictors</span>, </span><span class=\"param\"><span class=\"n\">predictand</span>, </span><span class=\"param\"><span class=\"n\">tolerate_empty_variables</span><span class=\"o\">=</span><span class=\"kc\">False</span></span>)</span>"}, {"fullname": "domino.prediction.PredictionTest.categorical_prediction", "modulename": "domino.prediction", "qualname": "PredictionTest.categorical_prediction", "kind": "function", "doc": "<p><strong>Arguments</strong></p>\n\n<p><em>model</em></p>\n\n<p>A function with the following signature:</p>\n\n<p>Input: Three numpy arrays of shape [T1,N], [T1], [T2,N] (train_predictors, train_target, and test_predictors respectively), and an arbitrary number of keyword arguments.</p>\n\n<p>Output: <em>model</em> (A scikit-learn-like fitted model object),<em>det_pred</em> (a numpy array of shape [T2] with deterministic predictions) and <em>prob_pred</em> (a numpy array of shape [T2,M] with probabilistic predictions, where M is the number of unique values in <em>train_target</em> and each element predicts the probability of a given class). Any output can instead be replaced with None, but at least one of <em>det_pred</em> and <em>prob_pred</em> must not be None.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>score</em></p>\n\n<p>A string specifying a predefined skill score (currently only 'sklearn_roc_auc') or a function with the signature:</p>\n\n<p>Input: det_pred (a numpy array of shape [T2]), prob_pred (a numpy array of shape [T2,M], a truth series (a numpy array of shape [T2]), and an arbitrary number of keyword arguments.\nOutput: a scalar skill score.</p>\n\n<p><em>cv_method</em>\nA string specifying a predefined cross-validation method, a custom cross-validation function with corresponding signature, or None, in which case no cross-validation is used (the training and test datasets are the same). Predefined cross-validation methods are:</p>\n\n<p><em>nchunks</em> - Divide the dataset into <em>n</em> chunks, using each as the test dataset predicted by the other <em>n</em>-1 chunks, to produce <em>n</em> total skill estimates. <em>n</em> defaults to 2, and is specified in <em>cv_kwargs</em></p>\n\n<p><em>drop_year</em> - Split the dataset by calendar year, using each year as the test dataset predicted by the remaining years.\n<em>manual</em> - Treat <em>predictors</em> and <em>predictand</em> as training data. Test data must be passed explicitly via <em>cv_kwargs</em> as <em>test_pred</em> and <em>test_targ</em>.</p>\n\n<p>If a custom function is passed it must have the following signature:\nInput: predictors (a Dataset), target (a DataArray), and an arbitrary number of keyword arguments.</p>\n\n<p>Output: A train predictor Dataset, a train target DatArray, a test predictor Dataset, and a test target DataArray.</p>\n\n<p><em>predictor_variables</em></p>\n\n<p>If 'univariate' all variables in <em>PredictionTest.predictors</em> are used individually to predict <em>PredictionTest.predictand</em>.</p>\n\n<p>If 'all' all variables in <em>PredictionTest.predictors</em> are used collectively to predict <em>PredictionTest.predictand</em>.</p>\n\n<p>If a 1D array of variable names in <em>PredictionTest.predictors</em>, each specified variable is used individually to predict <em>PredictionTest.predictand</em>.</p>\n\n<p>If a 2D array of iterables over variable names in <em>PredictionTest.predictors</em>, each specified combination of variables is used to predict <em>PredictionTest.predictand</em>.</p>\n\n<p><em>keep_models</em>\nIf True, a dictionary of arrays of fitted models is returned, corresponding to each variable combination and cross validated model that was computed.</p>\n\n<p><em>model_kwargs</em></p>\n\n<p>A dictionary of keyword arguments to pass to <em>model</em>\n<em>cv_kwargs</em></p>\n\n<p>A dictionary of keyword arguments to pass to <em>cv_method</em></p>\n\n<p><em>score_kwargs</em></p>\n\n<p>A dictionary of keyword arguments to pass to <em>score</em></p>\n\n<p><strong>Returns</strong></p>\n\n<p>If keep_models is False:</p>\n\n<p>returns <em>score_da</em>, a Dataset of skill scores for each prediction experiment, with a cross_validation coordinate.</p>\n\n<p>if keep_models is True:</p>\n\n<p>return (<em>score_da</em>,<em>model_da</em>)</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">model</span>,</span><span class=\"param\">\t<span class=\"n\">score</span><span class=\"o\">=</span><span class=\"s1\">&#39;sklearn_roc_auc&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">cv_method</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">predictor_variables</span><span class=\"o\">=</span><span class=\"s1\">&#39;univariate&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">keep_models</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">model_kwargs</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">cv_kwargs</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">score_kwargs</span><span class=\"o\">=</span><span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.prediction.PredictionTest.add_score_to_index_metadata", "modulename": "domino.prediction", "qualname": "PredictionTest.add_score_to_index_metadata", "kind": "function", "doc": "<p>Annotate a Dataset of indices with computed skill scores by adding them to the attributes of each DataArray in the Dataset.</p>\n\n<p><strong>Arguments</strong></p>\n\n<p><em>indices</em></p>\n\n<p><em>An xarray.Dataset of indices</em>.</p>\n\n<p><strong>Optional arguments</strong></p>\n\n<p><em>label</em></p>\n\n<p>A string determining the name of the added attribute key.</p>\n\n<p><em>raise_on_missing_var</em></p>\n\n<p>A boolean, determining if an error is raised if not all variables present in the computed skill scores are present in the indices.</p>\n\n<p><em>reduce_func</em></p>\n\n<p>The function used to reduce the 'cv' vector of skill scores to a single value. Default is the mean average, ignoring nans. To add the entire vector of scores for different cross validations, pass <em>reduce_func</em>=lambda x: x</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">indices</span>,</span><span class=\"param\">\t<span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s1\">&#39;score&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">raise_on_missing_var</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">reduce_func</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"n\">nanmean</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util", "modulename": "domino.util", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "domino.util.squeeze_da", "modulename": "domino.util", "qualname": "squeeze_da", "kind": "function", "doc": "<p>Remove length 1 coords from a DataArray</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.drop_scalar_coords", "modulename": "domino.util", "qualname": "drop_scalar_coords", "kind": "function", "doc": "<p>Remove coords without dimensions from Dataset</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.make_all_dims_coords", "modulename": "domino.util", "qualname": "make_all_dims_coords", "kind": "function", "doc": "<p>Convert all dims to coords</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.is_time_type", "modulename": "domino.util", "qualname": "is_time_type", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.offset_time_dim", "modulename": "domino.util", "qualname": "offset_time_dim", "kind": "function", "doc": "<p>Shifts the time-like <em>offset_dim</em> coord of <em>da</em> by <em>offset</em> <em>offset_units</em>.</p>\n\n<p>e.g. offset_time_dim(da,3,'days'), adds three days to the time axis of da.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">da</span>, </span><span class=\"param\"><span class=\"n\">offset</span>, </span><span class=\"param\"><span class=\"n\">offset_unit</span><span class=\"o\">=</span><span class=\"s1\">&#39;days&#39;</span>, </span><span class=\"param\"><span class=\"n\">offset_dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span>, </span><span class=\"param\"><span class=\"n\">deep</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.split_to_contiguous", "modulename": "domino.util", "qualname": "split_to_contiguous", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t_arr</span>, </span><span class=\"param\"><span class=\"n\">x_arr</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">dt</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">max_t</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.holm_bonferroni_correction", "modulename": "domino.util", "qualname": "holm_bonferroni_correction", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">pvals</span>, </span><span class=\"param\"><span class=\"n\">alpha</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.event_from_datetimes", "modulename": "domino.util", "qualname": "event_from_datetimes", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">events</span>, </span><span class=\"param\"><span class=\"n\">d1</span>, </span><span class=\"param\"><span class=\"n\">d2</span>, </span><span class=\"param\"><span class=\"n\">subset_dict</span><span class=\"o\">=</span><span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.xarr_times_to_ints", "modulename": "domino.util", "qualname": "xarr_times_to_ints", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">time_coord</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.restrict", "modulename": "domino.util", "qualname": "restrict", "kind": "function", "doc": "<p>Subset the coords of a Dataset <em>ds</em>, using <em>extent_dict</em>, a dictionary of the form {coord:[lower_bound,upper_bound],...}.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ds</span>, </span><span class=\"param\"><span class=\"n\">extent_dict</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "domino.util.offset_indices", "modulename": "domino.util", "qualname": "offset_indices", "kind": "function", "doc": "<p>For a Dataset <em>indices</em> and either a dictionary of <em>offsets</em> ({data_var:offset,...}) or offsets stored in an attribute <em>attr_kw</em>, offset each index along the <em>dim</em> coord and take their union.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">indices</span>,</span><span class=\"param\">\t<span class=\"n\">offsets</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">infer_offset</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">attr_kw</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">offset_unit</span><span class=\"o\">=</span><span class=\"s1\">&#39;days&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;time&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();