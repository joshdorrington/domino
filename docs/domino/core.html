<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 14.0.0"/>
    <title>domino.core API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;z-index:999;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;opacity:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{cursor:pointer;display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .pdoc-alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:1rem center;margin-bottom:1rem;}.pdoc .pdoc-alert > *:last-child{margin-bottom:0;}.pdoc .pdoc-alert-note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc > section:not(.module-info) h1{font-size:1.5rem;font-weight:500;}.pdoc > section:not(.module-info) h2{font-size:1.4rem;font-weight:500;}.pdoc > section:not(.module-info) h3{font-size:1.3rem;font-weight:500;}.pdoc > section:not(.module-info) h4{font-size:1.2rem;}.pdoc > section:not(.module-info) h5{font-size:1.1rem;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(.module-info){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.view-source-toggle-state,.view-source-toggle-state ~ .pdoc-code{display:none;}.view-source-toggle-state:checked ~ .pdoc-code{display:block;}.view-source-button{display:inline-block;float:right;font-size:.75rem;line-height:1.5rem;color:var(--muted);padding:0 .4rem 0 1.3rem;cursor:pointer;text-indent:-2px;}.view-source-button > span{visibility:hidden;}.module-info .view-source-button{float:none;display:flex;justify-content:flex-end;margin:-1.2rem .4rem -.2rem 0;}.view-source-button::before{position:absolute;content:"View Source";display:list-item;list-style-type:disclosure-closed;}.view-source-toggle-state:checked ~ .attr .view-source-button::before,.view-source-toggle-state:checked ~ .view-source-button::before{list-style-type:disclosure-open;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc section:not(.module-info) .docstring{margin-left:clamp(0rem, 5vw - 2rem, 1rem);}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target,.pdoc .pdoc-code > pre > span:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc .pdoc-code > pre > span:target{display:block;}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc *{scroll-margin:2rem;}.pdoc .pdoc-code .linenos{user-select:none;}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc section, .pdoc .classattr{position:relative;}.pdoc .headerlink{--width:clamp(1rem, 3vw, 2rem);position:absolute;top:0;left:calc(0rem - var(--width));transition:all 100ms ease-in-out;opacity:0;}.pdoc .headerlink::before{content:"#";display:block;text-align:center;width:var(--width);height:2.3rem;line-height:2.3rem;font-size:1.5rem;}.pdoc .attr:hover ~ .headerlink,.pdoc *:target > .headerlink,.pdoc .headerlink:hover{opacity:1;}.pdoc .attr{display:block;margin:.5rem 0 .5rem;padding:.4rem .4rem .4rem 1rem;background-color:var(--accent);overflow-x:auto;}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{background-color:transparent;}.pdoc .param, .pdoc .return-annotation{white-space:pre;}.pdoc .signature.multiline .param{display:block;}.pdoc .signature.condensed .param{display:inline-block;}.pdoc .annotation{color:var(--annotation);}.pdoc .view-value-toggle-state,.pdoc .view-value-toggle-state ~ .default_value{display:none;}.pdoc .view-value-toggle-state:checked ~ .default_value{display:inherit;}.pdoc .view-value-button{font-size:.5rem;vertical-align:middle;border-style:dashed;margin-top:-0.1rem;}.pdoc .view-value-button:hover{background:white;}.pdoc .view-value-button::before{content:"show";text-align:center;width:2.2em;display:inline-block;}.pdoc .view-value-toggle-state:checked ~ .view-value-button::before{content:"hide";}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>            <a class="pdoc-button module-list-button" href="../domino.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                &nbsp;domino</a>


            <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                   pattern=".+" required>



            <h2>API Documentation</h2>
                <ul class="memberlist">
            <li>
                    <a class="class" href="#LaggedAnalyser">LaggedAnalyser</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#LaggedAnalyser.__init__">LaggedAnalyser</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.add_variable">add_variable</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.lagged_variables">lagged_variables</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.lag_variables">lag_variables</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.compute_composites">compute_composites</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.aggregate_variables">aggregate_variables</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.add_derived_composite">add_derived_composite</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.compute_bootstraps">compute_bootstraps</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.get_significance">get_significance</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.bootstrap_significance">bootstrap_significance</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.deseasonalise_variables">deseasonalise_variables</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.get_seasonal_cycle_coeffs">get_seasonal_cycle_coeffs</a>
                        </li>
                        <li>
                                <a class="function" href="#LaggedAnalyser.get_composite_seasonal_mean">get_composite_seasonal_mean</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PatternFilter">PatternFilter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PatternFilter.__init__">PatternFilter</a>
                        </li>
                        <li>
                                <a class="function" href="#PatternFilter.update_mask">update_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#PatternFilter.apply_value_mask">apply_value_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#PatternFilter.apply_area_mask">apply_area_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#PatternFilter.apply_convolution">apply_convolution</a>
                        </li>
                        <li>
                                <a class="function" href="#PatternFilter.get_mask">get_mask</a>
                        </li>
                        <li>
                                <a class="function" href="#PatternFilter.filter">filter</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IndexGenerator">IndexGenerator</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IndexGenerator.generate">generate</a>
                        </li>
                        <li>
                                <a class="function" href="#IndexGenerator.get_standardisation_params">get_standardisation_params</a>
                        </li>
                </ul>

            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev" target="_blank">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section class="module-info">
                    <h1 class="modulename">
<a href="./../domino.html">domino</a><wbr>.core    </h1>

                
                        <input id="mod-core-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">

                        <label class="view-source-button" for="mod-core-view-source"><span>View Source</span></label>

                        <div class="pdoc-code codehilite"><pre><span></span><span id="L-1"><a href="#L-1"><span class="linenos">   1</span></a><span class="kn">import</span> <span class="nn">xarray</span> <span class="k">as</span> <span class="nn">xr</span>
</span><span id="L-2"><a href="#L-2"><span class="linenos">   2</span></a><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
</span><span id="L-3"><a href="#L-3"><span class="linenos">   3</span></a><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
</span><span id="L-4"><a href="#L-4"><span class="linenos">   4</span></a><span class="kn">import</span> <span class="nn">datetime</span> <span class="k">as</span> <span class="nn">dt</span>
</span><span id="L-5"><a href="#L-5"><span class="linenos">   5</span></a><span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
</span><span id="L-6"><a href="#L-6"><span class="linenos">   6</span></a><span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">label</span>
</span><span id="L-7"><a href="#L-7"><span class="linenos">   7</span></a><span class="kn">import</span> <span class="nn">dateutil.relativedelta</span> <span class="k">as</span> <span class="nn">durel</span>
</span><span id="L-8"><a href="#L-8"><span class="linenos">   8</span></a>
</span><span id="L-9"><a href="#L-9"><span class="linenos">   9</span></a><span class="kn">from</span> <span class="nn">domino</span> <span class="kn">import</span> <span class="n">agg</span>
</span><span id="L-10"><a href="#L-10"><span class="linenos">  10</span></a><span class="kn">from</span> <span class="nn">domino.categorical_analysis</span> <span class="kn">import</span> <span class="n">get_transmat</span><span class="p">,</span> <span class="n">synthetic_states_from_transmat</span>
</span><span id="L-11"><a href="#L-11"><span class="linenos">  11</span></a><span class="kn">from</span> <span class="nn">domino.util</span> <span class="kn">import</span> <span class="n">holm_bonferroni_correction</span><span class="p">,</span> <span class="n">split_to_contiguous</span><span class="p">,</span> <span class="n">is_time_type</span><span class="p">,</span> <span class="n">make_all_dims_coords</span><span class="p">,</span> <span class="n">drop_scalar_coords</span><span class="p">,</span> <span class="n">squeeze_da</span><span class="p">,</span><span class="n">offset_time_dim</span>
</span><span id="L-12"><a href="#L-12"><span class="linenos">  12</span></a><span class="kn">from</span> <span class="nn">domino.filtering</span> <span class="kn">import</span> <span class="n">ds_large_regions</span><span class="p">,</span> <span class="n">convolve_pad_ds</span>
</span><span id="L-13"><a href="#L-13"><span class="linenos">  13</span></a><span class="kn">from</span> <span class="nn">domino.deseasonaliser</span> <span class="kn">import</span> <span class="n">Agg_Deseasonaliser</span>
</span><span id="L-14"><a href="#L-14"><span class="linenos">  14</span></a>
</span><span id="L-15"><a href="#L-15"><span class="linenos">  15</span></a><span class="k">class</span> <span class="nc">LaggedAnalyser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span id="L-16"><a href="#L-16"><span class="linenos">  16</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes lagged composites of variables with respect to a categorical categorical event series, with support for bootstrap resampling to provide a non-parametric assessment of composite significance, and for deseasonalisation of variables.</span>
</span><span id="L-17"><a href="#L-17"><span class="linenos">  17</span></a><span class="sd">    </span>
</span><span id="L-18"><a href="#L-18"><span class="linenos">  18</span></a><span class="sd">    **Arguments:**</span>
</span><span id="L-19"><a href="#L-19"><span class="linenos">  19</span></a><span class="sd">        </span>
</span><span id="L-20"><a href="#L-20"><span class="linenos">  20</span></a><span class="sd">    *event*</span>
</span><span id="L-21"><a href="#L-21"><span class="linenos">  21</span></a><span class="sd">            </span>
</span><span id="L-22"><a href="#L-22"><span class="linenos">  22</span></a><span class="sd">    An xarray.DataArray with one dimension taking on categorical values, each defining a class of event (or non-event).</span>
</span><span id="L-23"><a href="#L-23"><span class="linenos">  23</span></a><span class="sd">            </span>
</span><span id="L-24"><a href="#L-24"><span class="linenos">  24</span></a><span class="sd">    **Optional arguments**</span>
</span><span id="L-25"><a href="#L-25"><span class="linenos">  25</span></a><span class="sd">        </span>
</span><span id="L-26"><a href="#L-26"><span class="linenos">  26</span></a><span class="sd">    *variables, name, is_categorical*</span>
</span><span id="L-27"><a href="#L-27"><span class="linenos">  27</span></a><span class="sd">        </span>
</span><span id="L-28"><a href="#L-28"><span class="linenos">  28</span></a><span class="sd">    Arguments for adding variables to the LaggedAnalyser. Identical behaviour to calling *LaggedAnalyser.add_variables* directly.</span>
</span><span id="L-29"><a href="#L-29"><span class="linenos">  29</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="L-30"><a href="#L-30"><span class="linenos">  30</span></a>    
</span><span id="L-31"><a href="#L-31"><span class="linenos">  31</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="p">,</span><span class="n">variables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">is_categorical</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="L-32"><a href="#L-32"><span class="linenos">  32</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise a new LaggedAnalyser object.&quot;&quot;&quot;</span>
</span><span id="L-33"><a href="#L-33"><span class="linenos">  33</span></a>        
</span><span id="L-34"><a href="#L-34"><span class="linenos">  34</span></a>        <span class="c1">#: event is a dataarray</span>
</span><span id="L-35"><a href="#L-35"><span class="linenos">  35</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="c1">#: This is a docstring?</span>
</span><span id="L-36"><a href="#L-36"><span class="linenos">  36</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-37"><a href="#L-37"><span class="linenos">  37</span></a>        
</span><span id="L-38"><a href="#L-38"><span class="linenos">  38</span></a>        <span class="c1">#variables are stored in a dataset, and can be added later,</span>
</span><span id="L-39"><a href="#L-39"><span class="linenos">  39</span></a>        <span class="c1">#or passed as a DataArray, a Dataset or as a dict of DataArrays</span>
</span><span id="L-40"><a href="#L-40"><span class="linenos">  40</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
</span><span id="L-41"><a href="#L-41"><span class="linenos">  41</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-42"><a href="#L-42"><span class="linenos">  42</span></a>
</span><span id="L-43"><a href="#L-43"><span class="linenos">  43</span></a>        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-44"><a href="#L-44"><span class="linenos">  44</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
</span><span id="L-45"><a href="#L-45"><span class="linenos">  45</span></a>            
</span><span id="L-46"><a href="#L-46"><span class="linenos">  46</span></a>        <span class="c1">#Time lagged versions of the dataset self.variables will be stored here, with a key</span>
</span><span id="L-47"><a href="#L-47"><span class="linenos">  47</span></a>        <span class="c1">#equal to the lag applied. Designed to be accessed by the self.lagged_variables function</span>
</span><span id="L-48"><a href="#L-48"><span class="linenos">  48</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="o">=</span><span class="p">{}</span>
</span><span id="L-49"><a href="#L-49"><span class="linenos">  49</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="o">=</span><span class="kc">None</span>
</span><span id="L-50"><a href="#L-50"><span class="linenos">  50</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-51"><a href="#L-51"><span class="linenos">  51</span></a>
</span><span id="L-52"><a href="#L-52"><span class="linenos">  52</span></a>        <span class="c1">#variables that are a linear combination of other variables are more efficiently</span>
</span><span id="L-53"><a href="#L-53"><span class="linenos">  53</span></a>        <span class="c1">#computed after compositing using the self.add_derived_composite method</span>
</span><span id="L-54"><a href="#L-54"><span class="linenos">  54</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="o">=</span><span class="p">{}</span>
</span><span id="L-55"><a href="#L-55"><span class="linenos">  55</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="o">=</span><span class="p">{}</span>
</span><span id="L-56"><a href="#L-56"><span class="linenos">  56</span></a>        
</span><span id="L-57"><a href="#L-57"><span class="linenos">  57</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composite_mask</span><span class="o">=</span><span class="kc">None</span>
</span><span id="L-58"><a href="#L-58"><span class="linenos">  58</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-59"><a href="#L-59"><span class="linenos">  59</span></a>
</span><span id="L-60"><a href="#L-60"><span class="linenos">  60</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">boot_indices</span><span class="o">=</span><span class="kc">None</span>
</span><span id="L-61"><a href="#L-61"><span class="linenos">  61</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-62"><a href="#L-62"><span class="linenos">  62</span></a>
</span><span id="L-63"><a href="#L-63"><span class="linenos">  63</span></a>        <span class="k">return</span>
</span><span id="L-64"><a href="#L-64"><span class="linenos">  64</span></a>    
</span><span id="L-65"><a href="#L-65"><span class="linenos">  65</span></a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-66"><a href="#L-66"><span class="linenos">  66</span></a>        <span class="n">l1</span><span class="o">=</span><span class="s1">&#39;A LaggedAnalyser object</span><span class="se">\n</span><span class="s1">&#39;</span>
</span><span id="L-67"><a href="#L-67"><span class="linenos">  67</span></a>        <span class="n">l2</span><span class="o">=</span><span class="s1">&#39;event:</span><span class="se">\n\n</span><span class="s1">&#39;</span>
</span><span id="L-68"><a href="#L-68"><span class="linenos">  68</span></a>        <span class="n">da_string</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="L-69"><a href="#L-69"><span class="linenos">  69</span></a>        <span class="n">l3</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">variables:</span><span class="se">\n\n</span><span class="s1">&#39;</span>
</span><span id="L-70"><a href="#L-70"><span class="linenos">  70</span></a>        <span class="n">ds_string</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</span><span id="L-71"><a href="#L-71"><span class="linenos">  71</span></a>        <span class="n">ds_string</span><span class="o">=</span><span class="n">ds_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">ds_string</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span><span id="L-72"><a href="#L-72"><span class="linenos">  72</span></a>        <span class="n">ds_string2</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
</span><span id="L-73"><a href="#L-73"><span class="linenos">  73</span></a>        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">!=</span><span class="p">[]:</span>
</span><span id="L-74"><a href="#L-74"><span class="linenos">  74</span></a>            <span class="n">lag_string</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Lagged variables at time intervals:</span><span class="se">\n</span><span class="s1"> </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">&#39;</span>
</span><span id="L-75"><a href="#L-75"><span class="linenos">  75</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-76"><a href="#L-76"><span class="linenos">  76</span></a>            <span class="n">lag_string</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
</span><span id="L-77"><a href="#L-77"><span class="linenos">  77</span></a>        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">da_string</span><span class="p">,</span><span class="n">l3</span><span class="p">,</span><span class="n">ds_string</span><span class="p">,</span><span class="n">ds_string2</span><span class="p">,</span><span class="n">lag_string</span><span class="p">])</span>
</span><span id="L-78"><a href="#L-78"><span class="linenos">  78</span></a>    
</span><span id="L-79"><a href="#L-79"><span class="linenos">  79</span></a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-80"><a href="#L-80"><span class="linenos">  80</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
</span><span id="L-81"><a href="#L-81"><span class="linenos">  81</span></a>
</span><span id="L-82"><a href="#L-82"><span class="linenos">  82</span></a>    <span class="k">def</span> <span class="nf">add_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">variables</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">is_categorical</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">join_type</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">):</span>
</span><span id="L-83"><a href="#L-83"><span class="linenos">  83</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds an additional variable to LaggedAnalyser.variables.</span>
</span><span id="L-84"><a href="#L-84"><span class="linenos">  84</span></a><span class="sd">        </span>
</span><span id="L-85"><a href="#L-85"><span class="linenos">  85</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-86"><a href="#L-86"><span class="linenos">  86</span></a><span class="sd">        </span>
</span><span id="L-87"><a href="#L-87"><span class="linenos">  87</span></a><span class="sd">        *variables* </span>
</span><span id="L-88"><a href="#L-88"><span class="linenos">  88</span></a><span class="sd">        </span>
</span><span id="L-89"><a href="#L-89"><span class="linenos">  89</span></a><span class="sd">        An xarray.DataArray, xarray.Dataset or dictionary of xarray.DataArrays, containing data to be composited with respect to *event*. One of the coordinates of *variables* should have the same name as the coordinate of *events*. Stored internally as an xarray.Dataset. If a dictionary is passed, the DataArrays are joined according to the method *join_type* which defaults to &#39;outer&#39;.</span>
</span><span id="L-90"><a href="#L-90"><span class="linenos">  90</span></a><span class="sd">            </span>
</span><span id="L-91"><a href="#L-91"><span class="linenos">  91</span></a><span class="sd">        **Optional Arguments**</span>
</span><span id="L-92"><a href="#L-92"><span class="linenos">  92</span></a><span class="sd">        </span>
</span><span id="L-93"><a href="#L-93"><span class="linenos">  93</span></a><span class="sd">        *name* </span>
</span><span id="L-94"><a href="#L-94"><span class="linenos">  94</span></a><span class="sd">        </span>
</span><span id="L-95"><a href="#L-95"><span class="linenos">  95</span></a><span class="sd">        A string. If *variables* is a single xarray.DataArray then *name* will be used as the name of the array in the LaggedAnalyser.variables DataArray. Otherwise ignored.</span>
</span><span id="L-96"><a href="#L-96"><span class="linenos">  96</span></a><span class="sd">        </span>
</span><span id="L-97"><a href="#L-97"><span class="linenos">  97</span></a><span class="sd">        *is_categorical* </span>
</span><span id="L-98"><a href="#L-98"><span class="linenos">  98</span></a><span class="sd">        </span>
</span><span id="L-99"><a href="#L-99"><span class="linenos">  99</span></a><span class="sd">        An integer, if *variables* is an xarray.DataArray, or else a dictionary of integers with keys corresponding to DataArrays in the xarray.Dataset/dictionary. 0 indicates that the variable is continuous, and 1 indicates that it is categorical. Note that continuous and categorical variables are by default composited differently (see LaggedAnalyser.compute_composites). Default assumption is all DataArrays are continuous, unless a DataAarray contains an &#39;is_categorical&#39; key in its DataArray.attrs, in which case this value is used.</span>
</span><span id="L-100"><a href="#L-100"><span class="linenos"> 100</span></a><span class="sd">            </span>
</span><span id="L-101"><a href="#L-101"><span class="linenos"> 101</span></a><span class="sd">        *overwrite*</span>
</span><span id="L-102"><a href="#L-102"><span class="linenos"> 102</span></a><span class="sd">        </span>
</span><span id="L-103"><a href="#L-103"><span class="linenos"> 103</span></a><span class="sd">        A boolean. If False then attempts to assign a variable who&#39;s name is already in *LaggedAnalyser.variables* will raise a ValueError</span>
</span><span id="L-104"><a href="#L-104"><span class="linenos"> 104</span></a><span class="sd">        </span>
</span><span id="L-105"><a href="#L-105"><span class="linenos"> 105</span></a><span class="sd">        *join_type*</span>
</span><span id="L-106"><a href="#L-106"><span class="linenos"> 106</span></a><span class="sd">        </span>
</span><span id="L-107"><a href="#L-107"><span class="linenos"> 107</span></a><span class="sd">        A string setting the rules for how differences in the coordinate indices of different variables are handled:</span>
</span><span id="L-108"><a href="#L-108"><span class="linenos"> 108</span></a><span class="sd">        outer: use the union of object indexes</span>
</span><span id="L-109"><a href="#L-109"><span class="linenos"> 109</span></a><span class="sd">        inner: use the intersection of object indexes</span>
</span><span id="L-110"><a href="#L-110"><span class="linenos"> 110</span></a>
</span><span id="L-111"><a href="#L-111"><span class="linenos"> 111</span></a><span class="sd">        left: use indexes from the pre-existing *LaggedAnalyser.variables* with each dimension</span>
</span><span id="L-112"><a href="#L-112"><span class="linenos"> 112</span></a>
</span><span id="L-113"><a href="#L-113"><span class="linenos"> 113</span></a><span class="sd">        right: use indexes from the new *variables* with each dimension</span>
</span><span id="L-114"><a href="#L-114"><span class="linenos"> 114</span></a>
</span><span id="L-115"><a href="#L-115"><span class="linenos"> 115</span></a><span class="sd">        exact: instead of aligning, raise ValueError when indexes to be aligned are not equal</span>
</span><span id="L-116"><a href="#L-116"><span class="linenos"> 116</span></a>
</span><span id="L-117"><a href="#L-117"><span class="linenos"> 117</span></a><span class="sd">        override: if indexes are of same size, rewrite indexes to be those of the pre-existing *LaggedAnalyser.variables*. Indexes for the same dimension must have the same size in all objects.</span>
</span><span id="L-118"><a href="#L-118"><span class="linenos"> 118</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-119"><a href="#L-119"><span class="linenos"> 119</span></a>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
</span><span id="L-120"><a href="#L-120"><span class="linenos"> 120</span></a>            
</span><span id="L-121"><a href="#L-121"><span class="linenos"> 121</span></a>            <span class="k">if</span> <span class="n">is_categorical</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-122"><a href="#L-122"><span class="linenos"> 122</span></a>                <span class="n">is_categorical</span><span class="o">=</span><span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
</span><span id="L-123"><a href="#L-123"><span class="linenos"> 123</span></a>                
</span><span id="L-124"><a href="#L-124"><span class="linenos"> 124</span></a>            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_variable</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">da</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
</span><span id="L-125"><a href="#L-125"><span class="linenos"> 125</span></a>            
</span><span id="L-126"><a href="#L-126"><span class="linenos"> 126</span></a>        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
</span><span id="L-127"><a href="#L-127"><span class="linenos"> 127</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">add_variable</span><span class="p">({</span><span class="n">v</span><span class="p">:</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">data_vars</span><span class="p">},</span><span class="kc">None</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">)</span>
</span><span id="L-128"><a href="#L-128"><span class="linenos"> 128</span></a>            
</span><span id="L-129"><a href="#L-129"><span class="linenos"> 129</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-130"><a href="#L-130"><span class="linenos"> 130</span></a>            
</span><span id="L-131"><a href="#L-131"><span class="linenos"> 131</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">_add_variable</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">)</span>            
</span><span id="L-132"><a href="#L-132"><span class="linenos"> 132</span></a>        <span class="k">return</span>
</span><span id="L-133"><a href="#L-133"><span class="linenos"> 133</span></a>    
</span><span id="L-134"><a href="#L-134"><span class="linenos"> 134</span></a>    <span class="k">def</span> <span class="nf">_more_mergable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="p">):</span>
</span><span id="L-135"><a href="#L-135"><span class="linenos"> 135</span></a>        
</span><span id="L-136"><a href="#L-136"><span class="linenos"> 136</span></a>        <span class="k">return</span> <span class="n">drop_scalar_coords</span><span class="p">(</span><span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span>
</span><span id="L-137"><a href="#L-137"><span class="linenos"> 137</span></a>    
</span><span id="L-138"><a href="#L-138"><span class="linenos"> 138</span></a>    <span class="k">def</span> <span class="nf">_add_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">da</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">):</span>
</span><span id="L-139"><a href="#L-139"><span class="linenos"> 139</span></a>        
</span><span id="L-140"><a href="#L-140"><span class="linenos"> 140</span></a>        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-141"><a href="#L-141"><span class="linenos"> 141</span></a>            <span class="n">name</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">name</span>
</span><span id="L-142"><a href="#L-142"><span class="linenos"> 142</span></a>        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="ow">not</span> <span class="n">overwrite</span><span class="p">):</span>
</span><span id="L-143"><a href="#L-143"><span class="linenos"> 143</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Key &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; is already in variables.&#39;</span><span class="p">))</span>
</span><span id="L-144"><a href="#L-144"><span class="linenos"> 144</span></a>        
</span><span id="L-145"><a href="#L-145"><span class="linenos"> 145</span></a>        <span class="k">try</span><span class="p">:</span>
</span><span id="L-146"><a href="#L-146"><span class="linenos"> 146</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">squeeze_da</span><span class="p">(</span><span class="n">da</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">),</span><span class="n">join</span><span class="o">=</span><span class="n">join_type</span><span class="p">)</span>
</span><span id="L-147"><a href="#L-147"><span class="linenos"> 147</span></a>        <span class="k">except</span><span class="p">:</span>
</span><span id="L-148"><a href="#L-148"><span class="linenos"> 148</span></a>            <span class="c1">#Trying to make the merge work:</span>
</span><span id="L-149"><a href="#L-149"><span class="linenos"> 149</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_more_mergable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_more_mergable</span><span class="p">(</span><span class="n">squeeze_da</span><span class="p">(</span><span class="n">da</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)),</span><span class="n">join</span><span class="o">=</span><span class="n">join_type</span><span class="p">)</span>
</span><span id="L-150"><a href="#L-150"><span class="linenos"> 150</span></a>
</span><span id="L-151"><a href="#L-151"><span class="linenos"> 151</span></a>        <span class="k">if</span> <span class="p">(</span><span class="n">is_categorical</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="s1">&#39;is_categorical&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="p">):</span>
</span><span id="L-152"><a href="#L-152"><span class="linenos"> 152</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;is_categorical&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
</span><span id="L-153"><a href="#L-153"><span class="linenos"> 153</span></a>        <span class="k">elif</span> <span class="n">is_categorical</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-154"><a href="#L-154"><span class="linenos"> 154</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;is_categorical&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">is_categorical</span>
</span><span id="L-155"><a href="#L-155"><span class="linenos"> 155</span></a>
</span><span id="L-156"><a href="#L-156"><span class="linenos"> 156</span></a>    <span class="k">def</span> <span class="nf">lagged_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
</span><span id="L-157"><a href="#L-157"><span class="linenos"> 157</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;A convenience function that retrieves variables at lag *t* from the *LaggedAnalyser*&quot;&quot;&quot;</span>
</span><span id="L-158"><a href="#L-158"><span class="linenos"> 158</span></a>        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">:</span>
</span><span id="L-159"><a href="#L-159"><span class="linenos"> 159</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
</span><span id="L-160"><a href="#L-160"><span class="linenos"> 160</span></a>        <span class="k">elif</span> <span class="n">t</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
</span><span id="L-161"><a href="#L-161"><span class="linenos"> 161</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
</span><span id="L-162"><a href="#L-162"><span class="linenos"> 162</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-163"><a href="#L-163"><span class="linenos"> 163</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lag </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1"> is not in self._lagged_variables.&#39;</span><span class="p">))</span>
</span><span id="L-164"><a href="#L-164"><span class="linenos"> 164</span></a>
</span><span id="L-165"><a href="#L-165"><span class="linenos"> 165</span></a>    <span class="k">def</span> <span class="nf">_lag_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="n">offset_unit</span><span class="o">=</span><span class="s1">&#39;days&#39;</span><span class="p">,</span><span class="n">offset_dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-166"><a href="#L-166"><span class="linenos"> 166</span></a>        
</span><span id="L-167"><a href="#L-167"><span class="linenos"> 167</span></a>        <span class="k">if</span> <span class="n">offset</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
</span><span id="L-168"><a href="#L-168"><span class="linenos"> 168</span></a>            <span class="k">return</span>
</span><span id="L-169"><a href="#L-169"><span class="linenos"> 169</span></a>        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="ow">not</span> <span class="n">overwrite</span><span class="p">):</span>
</span><span id="L-170"><a href="#L-170"><span class="linenos"> 170</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Key &quot;</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s1">&quot; is already in lagged_variables.&#39;</span><span class="p">))</span>
</span><span id="L-171"><a href="#L-171"><span class="linenos"> 171</span></a>            
</span><span id="L-172"><a href="#L-172"><span class="linenos"> 172</span></a>        <span class="c1">#We are really paranoid about mixing up our lags. So we implement this safety check</span>
</span><span id="L-173"><a href="#L-173"><span class="linenos"> 173</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_check_offset_is_valid</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="L-174"><a href="#L-174"><span class="linenos"> 174</span></a>        
</span><span id="L-175"><a href="#L-175"><span class="linenos"> 175</span></a>        <span class="c1">#REPLACED PREVIOUS IMPLEMENTATION WITH EQUIVALENT UTIL IMPORT.</span>
</span><span id="L-176"><a href="#L-176"><span class="linenos"> 176</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span><span class="o">=</span><span class="n">offset_time_dim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span><span class="n">offset_unit</span><span class="o">=</span><span class="n">offset_unit</span><span class="p">,</span><span class="n">offset_dim</span><span class="o">=</span><span class="n">offset_dim</span><span class="p">)</span>
</span><span id="L-177"><a href="#L-177"><span class="linenos"> 177</span></a>
</span><span id="L-178"><a href="#L-178"><span class="linenos"> 178</span></a>        <span class="k">return</span>
</span><span id="L-179"><a href="#L-179"><span class="linenos"> 179</span></a>    
</span><span id="L-180"><a href="#L-180"><span class="linenos"> 180</span></a>    <span class="c1">#For coords not in a time format</span>
</span><span id="L-181"><a href="#L-181"><span class="linenos"> 181</span></a>    <span class="k">def</span> <span class="nf">_ilag_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-182"><a href="#L-182"><span class="linenos"> 182</span></a>        <span class="k">raise</span><span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Only lagging along timelike dimensions is currently supported.&#39;</span><span class="p">))</span>
</span><span id="L-183"><a href="#L-183"><span class="linenos"> 183</span></a>        
</span><span id="L-184"><a href="#L-184"><span class="linenos"> 184</span></a>    <span class="k">def</span> <span class="nf">lag_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">offsets</span><span class="p">,</span><span class="n">offset_unit</span><span class="o">=</span><span class="s1">&#39;days&#39;</span><span class="p">,</span><span class="n">offset_dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-185"><a href="#L-185"><span class="linenos"> 185</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Produces time lags of *LaggedAnalyser.variables*, which can be used to produce lagged composites.</span>
</span><span id="L-186"><a href="#L-186"><span class="linenos"> 186</span></a><span class="sd">        </span>
</span><span id="L-187"><a href="#L-187"><span class="linenos"> 187</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-188"><a href="#L-188"><span class="linenos"> 188</span></a><span class="sd">        </span>
</span><span id="L-189"><a href="#L-189"><span class="linenos"> 189</span></a><span class="sd">        *offsets*</span>
</span><span id="L-190"><a href="#L-190"><span class="linenos"> 190</span></a><span class="sd">        </span>
</span><span id="L-191"><a href="#L-191"><span class="linenos"> 191</span></a><span class="sd">        An iterable of integers which represent time lags at which to lag *LaggedAnalyser.variables* in the units specified by *offset_unit*. Positive offsets denote variables *preceding* the event.</span>
</span><span id="L-192"><a href="#L-192"><span class="linenos"> 192</span></a><span class="sd">            </span>
</span><span id="L-193"><a href="#L-193"><span class="linenos"> 193</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-194"><a href="#L-194"><span class="linenos"> 194</span></a><span class="sd">        </span>
</span><span id="L-195"><a href="#L-195"><span class="linenos"> 195</span></a><span class="sd">        *offset_unit*</span>
</span><span id="L-196"><a href="#L-196"><span class="linenos"> 196</span></a><span class="sd">        </span>
</span><span id="L-197"><a href="#L-197"><span class="linenos"> 197</span></a><span class="sd">        A string, defining the units of *offsets*. Valid options are weeks, days, hours, minutes, seconds, milliseconds, and microseconds.</span>
</span><span id="L-198"><a href="#L-198"><span class="linenos"> 198</span></a><span class="sd">            </span>
</span><span id="L-199"><a href="#L-199"><span class="linenos"> 199</span></a><span class="sd">        *offset_dim*</span>
</span><span id="L-200"><a href="#L-200"><span class="linenos"> 200</span></a><span class="sd">        </span>
</span><span id="L-201"><a href="#L-201"><span class="linenos"> 201</span></a><span class="sd">        A string, defining the coordinate of *LaggedAnalyser.variables* along which offsets are to be calculated.</span>
</span><span id="L-202"><a href="#L-202"><span class="linenos"> 202</span></a><span class="sd">            </span>
</span><span id="L-203"><a href="#L-203"><span class="linenos"> 203</span></a><span class="sd">        *mode*</span>
</span><span id="L-204"><a href="#L-204"><span class="linenos"> 204</span></a><span class="sd">        </span>
</span><span id="L-205"><a href="#L-205"><span class="linenos"> 205</span></a><span class="sd">        One of &#39;any&#39;, &#39;past&#39;, or &#39;future&#39;. If &#39;past&#39; or &#39;future&#39; is used then only positive or negative lags are valid, respectively.</span>
</span><span id="L-206"><a href="#L-206"><span class="linenos"> 206</span></a><span class="sd">            </span>
</span><span id="L-207"><a href="#L-207"><span class="linenos"> 207</span></a><span class="sd">        *overwrite*</span>
</span><span id="L-208"><a href="#L-208"><span class="linenos"> 208</span></a><span class="sd">        </span>
</span><span id="L-209"><a href="#L-209"><span class="linenos"> 209</span></a><span class="sd">        A boolean. If False, then attempts to produce a lag which already exist will raise a ValueError.</span>
</span><span id="L-210"><a href="#L-210"><span class="linenos"> 210</span></a><span class="sd">        </span>
</span><span id="L-211"><a href="#L-211"><span class="linenos"> 211</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-212"><a href="#L-212"><span class="linenos"> 212</span></a>        <span class="n">time_type</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">is_time_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">offset_dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
</span><span id="L-213"><a href="#L-213"><span class="linenos"> 213</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">offset_unit</span><span class="o">=</span><span class="n">offset_unit</span>
</span><span id="L-214"><a href="#L-214"><span class="linenos"> 214</span></a>        <span class="n">lag_funcs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ilag_variables</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_lag_variables</span><span class="p">]</span>
</span><span id="L-215"><a href="#L-215"><span class="linenos"> 215</span></a>        <span class="n">offsets</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
</span><span id="L-216"><a href="#L-216"><span class="linenos"> 216</span></a>        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">:</span>
</span><span id="L-217"><a href="#L-217"><span class="linenos"> 217</span></a>            <span class="n">lag_funcs</span><span class="p">[</span><span class="n">time_type</span><span class="p">](</span><span class="nb">int</span><span class="p">(</span><span class="n">o</span><span class="p">),</span><span class="n">offset_unit</span><span class="p">,</span><span class="n">offset_dim</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="n">overwrite</span><span class="p">)</span>
</span><span id="L-218"><a href="#L-218"><span class="linenos"> 218</span></a>        
</span><span id="L-219"><a href="#L-219"><span class="linenos"> 219</span></a>    <span class="k">def</span> <span class="nf">_check_offset_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="n">mode</span><span class="p">):</span>
</span><span id="L-220"><a href="#L-220"><span class="linenos"> 220</span></a>        
</span><span id="L-221"><a href="#L-221"><span class="linenos"> 221</span></a>        <span class="n">valid_modes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;any&#39;</span><span class="p">,</span><span class="s1">&#39;past&#39;</span><span class="p">,</span><span class="s1">&#39;future&#39;</span><span class="p">]</span>
</span><span id="L-222"><a href="#L-222"><span class="linenos"> 222</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">valid_modes</span><span class="p">:</span>
</span><span id="L-223"><a href="#L-223"><span class="linenos"> 223</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mode must be one of </span><span class="si">{</span><span class="n">valid_modes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span>
</span><span id="L-224"><a href="#L-224"><span class="linenos"> 224</span></a>        <span class="k">if</span> <span class="n">offset</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;past&#39;</span><span class="p">:</span>
</span><span id="L-225"><a href="#L-225"><span class="linenos"> 225</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Positive offset </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s1"> given, but mode is &quot;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">))</span>
</span><span id="L-226"><a href="#L-226"><span class="linenos"> 226</span></a>        <span class="k">if</span> <span class="n">offset</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;future&#39;</span><span class="p">:</span>
</span><span id="L-227"><a href="#L-227"><span class="linenos"> 227</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Negative offset </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s1"> given, but mode is &quot;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">))</span>
</span><span id="L-228"><a href="#L-228"><span class="linenos"> 228</span></a>        <span class="k">return</span>
</span><span id="L-229"><a href="#L-229"><span class="linenos"> 229</span></a><span class="w">    </span>
</span><span id="L-230"><a href="#L-230"><span class="linenos"> 230</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-231"><a href="#L-231"><span class="linenos"> 231</span></a><span class="sd">        COMPOSITE COMPUTATION FUNCTIONS </span>
</span><span id="L-232"><a href="#L-232"><span class="linenos"> 232</span></a><span class="sd">        Composite computation is split over 4 function layers:</span>
</span><span id="L-233"><a href="#L-233"><span class="linenos"> 233</span></a><span class="sd">        compute_composites(): calls</span>
</span><span id="L-234"><a href="#L-234"><span class="linenos"> 234</span></a><span class="sd">            _compute_aggregate_over_lags(): calls</span>
</span><span id="L-235"><a href="#L-235"><span class="linenos"> 235</span></a><span class="sd">                _composite_from_ix(): splits data into cat vars</span>
</span><span id="L-236"><a href="#L-236"><span class="linenos"> 236</span></a><span class="sd">                and con vars and then calls</span>
</span><span id="L-237"><a href="#L-237"><span class="linenos"> 237</span></a><span class="sd">                    _aggregate_from_ix(): applies an operation to</span>
</span><span id="L-238"><a href="#L-238"><span class="linenos"> 238</span></a><span class="sd">                    subsets of ds, where the ix takes unique values</span>
</span><span id="L-239"><a href="#L-239"><span class="linenos"> 239</span></a><span class="sd">                then merges them together.</span>
</span><span id="L-240"><a href="#L-240"><span class="linenos"> 240</span></a><span class="sd">             then loops over lags and merges those.</span>
</span><span id="L-241"><a href="#L-241"><span class="linenos"> 241</span></a><span class="sd">        And then substracts any anomalies and returns the data.</span>
</span><span id="L-242"><a href="#L-242"><span class="linenos"> 242</span></a>
</span><span id="L-243"><a href="#L-243"><span class="linenos"> 243</span></a>
</span><span id="L-244"><a href="#L-244"><span class="linenos"> 244</span></a><span class="sd">        Example usage of the aggregate funcs:</span>
</span><span id="L-245"><a href="#L-245"><span class="linenos"> 245</span></a><span class="sd">        i.e. self._aggregate_from_ix(ds,ix,&#39;time&#39;,self._mean_ds)</span>
</span><span id="L-246"><a href="#L-246"><span class="linenos"> 246</span></a><span class="sd">        self._aggregate_from_ix(ds,ix,&#39;time&#39;,self._std_ds)</span>
</span><span id="L-247"><a href="#L-247"><span class="linenos"> 247</span></a><span class="sd">        self._aggregate_from_ix(ds,ix,&#39;time&#39;,self._cat_occ_ds,s=reg_ds)</span>
</span><span id="L-248"><a href="#L-248"><span class="linenos"> 248</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="L-249"><a href="#L-249"><span class="linenos"> 249</span></a>    
</span><span id="L-250"><a href="#L-250"><span class="linenos"> 250</span></a>    <span class="k">def</span> <span class="nf">_aggregate_from_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">agg_func</span><span class="p">,</span><span class="o">*</span><span class="n">agg_args</span><span class="p">):</span>
</span><span id="L-251"><a href="#L-251"><span class="linenos"> 251</span></a>        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">agg_func</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span><span class="n">ix</span><span class="o">==</span><span class="n">i</span><span class="p">}),</span><span class="n">dim</span><span class="p">,</span><span class="o">*</span><span class="n">agg_args</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ix</span><span class="p">)],</span><span class="s1">&#39;index_val&#39;</span><span class="p">)</span>
</span><span id="L-252"><a href="#L-252"><span class="linenos"> 252</span></a>    
</span><span id="L-253"><a href="#L-253"><span class="linenos"> 253</span></a>    
</span><span id="L-254"><a href="#L-254"><span class="linenos"> 254</span></a>    <span class="c1">#Splits variables into cat and con and then combines the two different kinds of composites.</span>
</span><span id="L-255"><a href="#L-255"><span class="linenos"> 255</span></a>    <span class="c1">#Used with a synthetic &#39;ix&#39; for bootstrapping by self._compute_bootstraps.</span>
</span><span id="L-256"><a href="#L-256"><span class="linenos"> 256</span></a>    <span class="k">def</span> <span class="nf">_composite_from_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">ds</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</span><span id="L-257"><a href="#L-257"><span class="linenos"> 257</span></a>                
</span><span id="L-258"><a href="#L-258"><span class="linenos"> 258</span></a>        <span class="n">ix</span><span class="o">=</span><span class="n">ix</span><span class="o">.</span><span class="n">values</span> <span class="c1">#passed in as a da</span>
</span><span id="L-259"><a href="#L-259"><span class="linenos"> 259</span></a>        <span class="n">cat_vars</span><span class="o">=</span><span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span> <span class="k">if</span> <span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;is_categorical&#39;</span><span class="p">]]</span>
</span><span id="L-260"><a href="#L-260"><span class="linenos"> 260</span></a>        <span class="n">con_vars</span><span class="o">=</span><span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cat_vars</span><span class="p">]</span>
</span><span id="L-261"><a href="#L-261"><span class="linenos"> 261</span></a>        <span class="n">cat_ds</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="n">cat_vars</span><span class="p">]</span>
</span><span id="L-262"><a href="#L-262"><span class="linenos"> 262</span></a>        <span class="n">con_ds</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="n">con_vars</span><span class="p">]</span>
</span><span id="L-263"><a href="#L-263"><span class="linenos"> 263</span></a>        <span class="n">cat_vals</span><span class="o">=</span><span class="n">cat_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">)</span>
</span><span id="L-264"><a href="#L-264"><span class="linenos"> 264</span></a>
</span><span id="L-265"><a href="#L-265"><span class="linenos"> 265</span></a>        <span class="k">if</span> <span class="p">(</span><span class="n">con_vars</span><span class="o">!=</span><span class="p">[])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">con_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
</span><span id="L-266"><a href="#L-266"><span class="linenos"> 266</span></a>            <span class="k">if</span> <span class="p">(</span><span class="n">cat_vars</span><span class="o">!=</span><span class="p">[])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cat_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
</span><span id="L-267"><a href="#L-267"><span class="linenos"> 267</span></a>                <span class="n">con_comp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_from_ix</span><span class="p">(</span><span class="n">con_ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">)</span>
</span><span id="L-268"><a href="#L-268"><span class="linenos"> 268</span></a>                <span class="n">cat_comp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_from_ix</span><span class="p">(</span><span class="n">cat_ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">cat_vals</span><span class="p">)</span>
</span><span id="L-269"><a href="#L-269"><span class="linenos"> 269</span></a>                <span class="n">comp</span><span class="o">=</span><span class="n">con_comp</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cat_comp</span><span class="p">)</span>
</span><span id="L-270"><a href="#L-270"><span class="linenos"> 270</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="L-271"><a href="#L-271"><span class="linenos"> 271</span></a>                <span class="n">comp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_from_ix</span><span class="p">(</span><span class="n">con_ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">)</span>
</span><span id="L-272"><a href="#L-272"><span class="linenos"> 272</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-273"><a href="#L-273"><span class="linenos"> 273</span></a>                <span class="n">comp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_from_ix</span><span class="p">(</span><span class="n">cat_ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">cat_vals</span><span class="p">)</span>
</span><span id="L-274"><a href="#L-274"><span class="linenos"> 274</span></a>        <span class="n">comp</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">attrs</span>
</span><span id="L-275"><a href="#L-275"><span class="linenos"> 275</span></a>        <span class="k">return</span> <span class="n">comp</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;lag&#39;</span><span class="p">:[</span><span class="n">lag</span><span class="p">]})</span>    
</span><span id="L-276"><a href="#L-276"><span class="linenos"> 276</span></a>    
</span><span id="L-277"><a href="#L-277"><span class="linenos"> 277</span></a>    <span class="c1">#loops over all lags, calling _composite_from_ix, and assembles composites into a single dataset</span>
</span><span id="L-278"><a href="#L-278"><span class="linenos"> 278</span></a>    <span class="k">def</span> <span class="nf">_compute_aggregate_over_lags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">da</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">):</span>
</span><span id="L-279"><a href="#L-279"><span class="linenos"> 279</span></a>            
</span><span id="L-280"><a href="#L-280"><span class="linenos"> 280</span></a>        <span class="k">if</span> <span class="n">lag_vals</span><span class="o">==</span><span class="s1">&#39;all&#39;</span><span class="p">:</span>
</span><span id="L-281"><a href="#L-281"><span class="linenos"> 281</span></a>            <span class="n">lag_vals</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)</span>
</span><span id="L-282"><a href="#L-282"><span class="linenos"> 282</span></a>                    
</span><span id="L-283"><a href="#L-283"><span class="linenos"> 283</span></a>        <span class="n">composite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_composite_from_ix</span><span class="p">(</span><span class="o">*</span><span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="L-284"><a href="#L-284"><span class="linenos"> 284</span></a>              
</span><span id="L-285"><a href="#L-285"><span class="linenos"> 285</span></a>        <span class="k">if</span> <span class="n">lag_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-286"><a href="#L-286"><span class="linenos"> 286</span></a>            <span class="n">lag_composites</span><span class="o">=</span><span class="p">[]</span>
</span><span id="L-287"><a href="#L-287"><span class="linenos"> 287</span></a>            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lag_vals</span><span class="p">:</span>
</span><span id="L-288"><a href="#L-288"><span class="linenos"> 288</span></a>                <span class="n">lag_composites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_composite_from_ix</span><span class="p">(</span><span class="o">*</span><span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_variables</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="o">=</span><span class="n">t</span><span class="p">))</span>
</span><span id="L-289"><a href="#L-289"><span class="linenos"> 289</span></a>            <span class="n">composite</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">composite</span><span class="p">,</span><span class="o">*</span><span class="n">lag_composites</span><span class="p">],</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span>
</span><span id="L-290"><a href="#L-290"><span class="linenos"> 290</span></a>            
</span><span id="L-291"><a href="#L-291"><span class="linenos"> 291</span></a>        <span class="k">return</span> <span class="n">composite</span>
</span><span id="L-292"><a href="#L-292"><span class="linenos"> 292</span></a>
</span><span id="L-293"><a href="#L-293"><span class="linenos"> 293</span></a>    <span class="c1">#The top level wrapper for compositing</span>
</span><span id="L-294"><a href="#L-294"><span class="linenos"> 294</span></a>    <span class="k">def</span> <span class="nf">compute_composites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">lag_vals</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">as_anomaly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">con_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">mean_ds</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">cat_occ_ds</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="L-295"><a href="#L-295"><span class="linenos"> 295</span></a><span class="w">        </span>
</span><span id="L-296"><a href="#L-296"><span class="linenos"> 296</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-297"><a href="#L-297"><span class="linenos"> 297</span></a><span class="sd">        Partitions *LaggedAnalyser.variables*, and any time-lagged equivalents, into subsets depending on the value of *LaggedAnalyser.event*, and then computes a bulk summary metric for each.</span>
</span><span id="L-298"><a href="#L-298"><span class="linenos"> 298</span></a>
</span><span id="L-299"><a href="#L-299"><span class="linenos"> 299</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-300"><a href="#L-300"><span class="linenos"> 300</span></a><span class="sd">        </span>
</span><span id="L-301"><a href="#L-301"><span class="linenos"> 301</span></a><span class="sd">        *dim*</span>
</span><span id="L-302"><a href="#L-302"><span class="linenos"> 302</span></a><span class="sd">        </span>
</span><span id="L-303"><a href="#L-303"><span class="linenos"> 303</span></a><span class="sd">        A string, the coordinate along which to compute composites.</span>
</span><span id="L-304"><a href="#L-304"><span class="linenos"> 304</span></a><span class="sd">            </span>
</span><span id="L-305"><a href="#L-305"><span class="linenos"> 305</span></a><span class="sd">        *lag_vals*</span>
</span><span id="L-306"><a href="#L-306"><span class="linenos"> 306</span></a><span class="sd">        </span>
</span><span id="L-307"><a href="#L-307"><span class="linenos"> 307</span></a><span class="sd">        Either &#39;All&#39;, or a list of integers, denoting the time lags for which composites should be computed.</span>
</span><span id="L-308"><a href="#L-308"><span class="linenos"> 308</span></a><span class="sd">            </span>
</span><span id="L-309"><a href="#L-309"><span class="linenos"> 309</span></a><span class="sd">        *as_anomaly*</span>
</span><span id="L-310"><a href="#L-310"><span class="linenos"> 310</span></a><span class="sd">        </span>
</span><span id="L-311"><a href="#L-311"><span class="linenos"> 311</span></a><span class="sd">        A Boolean, defining whether composites should be given as absolute values or differences from the unpartitioned value.</span>
</span><span id="L-312"><a href="#L-312"><span class="linenos"> 312</span></a><span class="sd">            </span>
</span><span id="L-313"><a href="#L-313"><span class="linenos"> 313</span></a><span class="sd">        *con_func*</span>
</span><span id="L-314"><a href="#L-314"><span class="linenos"> 314</span></a><span class="sd">        </span>
</span><span id="L-315"><a href="#L-315"><span class="linenos"> 315</span></a><span class="sd">        The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</span>
</span><span id="L-316"><a href="#L-316"><span class="linenos"> 316</span></a><span class="sd">            </span>
</span><span id="L-317"><a href="#L-317"><span class="linenos"> 317</span></a><span class="sd">        *cat_func*</span>
</span><span id="L-318"><a href="#L-318"><span class="linenos"> 318</span></a><span class="sd">        </span>
</span><span id="L-319"><a href="#L-319"><span class="linenos"> 319</span></a><span class="sd">        The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then categorical variables will be ignored</span>
</span><span id="L-320"><a href="#L-320"><span class="linenos"> 320</span></a><span class="sd">            </span>
</span><span id="L-321"><a href="#L-321"><span class="linenos"> 321</span></a><span class="sd">        *inplace*</span>
</span><span id="L-322"><a href="#L-322"><span class="linenos"> 322</span></a><span class="sd">    </span>
</span><span id="L-323"><a href="#L-323"><span class="linenos"> 323</span></a><span class="sd">        A boolean, defining whether the composite should be stored in *LaggedAnalyser.composites*</span>
</span><span id="L-324"><a href="#L-324"><span class="linenos"> 324</span></a><span class="sd">        </span>
</span><span id="L-325"><a href="#L-325"><span class="linenos"> 325</span></a><span class="sd">        **returns**</span>
</span><span id="L-326"><a href="#L-326"><span class="linenos"> 326</span></a><span class="sd">        </span>
</span><span id="L-327"><a href="#L-327"><span class="linenos"> 327</span></a><span class="sd">        An xarray.Dataset like  *LaggedAnalyser.variables* but summarised according to *con_func* and *cat_func*, and with an additional coordinate *index_val*, which indexes over the values taken by *LaggedAnalyser.event*.</span>
</span><span id="L-328"><a href="#L-328"><span class="linenos"> 328</span></a><span class="sd">            </span>
</span><span id="L-329"><a href="#L-329"><span class="linenos"> 329</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-330"><a href="#L-330"><span class="linenos"> 330</span></a>        <span class="n">composite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_aggregate_over_lags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="L-331"><a href="#L-331"><span class="linenos"> 331</span></a>        <span class="n">lagged_means</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aggregate_variables</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="L-332"><a href="#L-332"><span class="linenos"> 332</span></a>
</span><span id="L-333"><a href="#L-333"><span class="linenos"> 333</span></a>        <span class="k">if</span> <span class="n">as_anomaly</span><span class="p">:</span>
</span><span id="L-334"><a href="#L-334"><span class="linenos"> 334</span></a>            <span class="n">composite</span><span class="o">=</span><span class="n">composite</span><span class="o">-</span><span class="n">lagged_means</span>
</span><span id="L-335"><a href="#L-335"><span class="linenos"> 335</span></a>            
</span><span id="L-336"><a href="#L-336"><span class="linenos"> 336</span></a>        <span class="n">composite</span><span class="o">=</span><span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">composite</span><span class="p">)</span>
</span><span id="L-337"><a href="#L-337"><span class="linenos"> 337</span></a>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">composite</span><span class="o">.</span><span class="n">data_vars</span><span class="p">):</span>
</span><span id="L-338"><a href="#L-338"><span class="linenos"> 338</span></a>            <span class="n">composite</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span>
</span><span id="L-339"><a href="#L-339"><span class="linenos"> 339</span></a>        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
</span><span id="L-340"><a href="#L-340"><span class="linenos"> 340</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="o">=</span><span class="n">composite</span>
</span><span id="L-341"><a href="#L-341"><span class="linenos"> 341</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">composite_func</span><span class="o">=</span><span class="p">(</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="L-342"><a href="#L-342"><span class="linenos"> 342</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">composites_are_anomaly</span><span class="o">=</span><span class="n">as_anomaly</span>
</span><span id="L-343"><a href="#L-343"><span class="linenos"> 343</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="o">=</span><span class="n">lagged_means</span>
</span><span id="L-344"><a href="#L-344"><span class="linenos"> 344</span></a>        <span class="k">return</span> <span class="n">composite</span>
</span><span id="L-345"><a href="#L-345"><span class="linenos"> 345</span></a>
</span><span id="L-346"><a href="#L-346"><span class="linenos"> 346</span></a>    <span class="c1">#Aggregates variables over all time points where event is defined, regardless of its value</span>
</span><span id="L-347"><a href="#L-347"><span class="linenos"> 347</span></a>    <span class="k">def</span> <span class="nf">aggregate_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">lag_vals</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">con_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">mean_ds</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">cat_occ_ds</span><span class="p">):</span>
</span><span id="L-348"><a href="#L-348"><span class="linenos"> 348</span></a><span class="w">        </span>
</span><span id="L-349"><a href="#L-349"><span class="linenos"> 349</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates a summary metric from *LaggedAnalyser.variables* at all points where *LaggedAnalyser.event* is defined, regardless of its value.</span>
</span><span id="L-350"><a href="#L-350"><span class="linenos"> 350</span></a><span class="sd">        </span>
</span><span id="L-351"><a href="#L-351"><span class="linenos"> 351</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-352"><a href="#L-352"><span class="linenos"> 352</span></a><span class="sd">        </span>
</span><span id="L-353"><a href="#L-353"><span class="linenos"> 353</span></a><span class="sd">        *dim*</span>
</span><span id="L-354"><a href="#L-354"><span class="linenos"> 354</span></a><span class="sd">        </span>
</span><span id="L-355"><a href="#L-355"><span class="linenos"> 355</span></a><span class="sd">        A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*.</span>
</span><span id="L-356"><a href="#L-356"><span class="linenos"> 356</span></a><span class="sd">        </span>
</span><span id="L-357"><a href="#L-357"><span class="linenos"> 357</span></a><span class="sd">        *lag_vals*</span>
</span><span id="L-358"><a href="#L-358"><span class="linenos"> 358</span></a><span class="sd">        </span>
</span><span id="L-359"><a href="#L-359"><span class="linenos"> 359</span></a><span class="sd">        &#39;all&#39; or a iterable of integers, specifying for which lag values to compute the summary metric.</span>
</span><span id="L-360"><a href="#L-360"><span class="linenos"> 360</span></a><span class="sd">        </span>
</span><span id="L-361"><a href="#L-361"><span class="linenos"> 361</span></a><span class="sd">        *con_func*</span>
</span><span id="L-362"><a href="#L-362"><span class="linenos"> 362</span></a><span class="sd">        </span>
</span><span id="L-363"><a href="#L-363"><span class="linenos"> 363</span></a><span class="sd">        The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</span>
</span><span id="L-364"><a href="#L-364"><span class="linenos"> 364</span></a><span class="sd">            </span>
</span><span id="L-365"><a href="#L-365"><span class="linenos"> 365</span></a><span class="sd">        *cat_func*</span>
</span><span id="L-366"><a href="#L-366"><span class="linenos"> 366</span></a><span class="sd">        </span>
</span><span id="L-367"><a href="#L-367"><span class="linenos"> 367</span></a><span class="sd">        The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</span>
</span><span id="L-368"><a href="#L-368"><span class="linenos"> 368</span></a>
</span><span id="L-369"><a href="#L-369"><span class="linenos"> 369</span></a><span class="sd">        **returns**</span>
</span><span id="L-370"><a href="#L-370"><span class="linenos"> 370</span></a><span class="sd">        </span>
</span><span id="L-371"><a href="#L-371"><span class="linenos"> 371</span></a><span class="sd">        An xarray.Dataset like  *LaggedAnalyser.variables* but summarised according to *con_func* and *cat_func*.</span>
</span><span id="L-372"><a href="#L-372"><span class="linenos"> 372</span></a>
</span><span id="L-373"><a href="#L-373"><span class="linenos"> 373</span></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-374"><a href="#L-374"><span class="linenos"> 374</span></a>        <span class="n">fake_event</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">))</span>
</span><span id="L-375"><a href="#L-375"><span class="linenos"> 375</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_aggregate_over_lags</span><span class="p">(</span><span class="n">fake_event</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">index_val</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="L-376"><a href="#L-376"><span class="linenos"> 376</span></a>
</span><span id="L-377"><a href="#L-377"><span class="linenos"> 377</span></a>    <span class="k">def</span> <span class="nf">add_derived_composite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-378"><a href="#L-378"><span class="linenos"> 378</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies *func* to one or multiple composites to calculate composites of derived quantities, and additionally, stores *func* to allow derived bootstrap composites to be calculated. For linear quantities, where Ex[f(x)]==f(Ex[x]), then this can minimise redundant memory use.</span>
</span><span id="L-379"><a href="#L-379"><span class="linenos"> 379</span></a><span class="sd">        </span>
</span><span id="L-380"><a href="#L-380"><span class="linenos"> 380</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-381"><a href="#L-381"><span class="linenos"> 381</span></a><span class="sd">        </span>
</span><span id="L-382"><a href="#L-382"><span class="linenos"> 382</span></a><span class="sd">        *name*</span>
</span><span id="L-383"><a href="#L-383"><span class="linenos"> 383</span></a><span class="sd">        </span>
</span><span id="L-384"><a href="#L-384"><span class="linenos"> 384</span></a><span class="sd">        A string, providing the name of the new variable to add.</span>
</span><span id="L-385"><a href="#L-385"><span class="linenos"> 385</span></a><span class="sd">            </span>
</span><span id="L-386"><a href="#L-386"><span class="linenos"> 386</span></a><span class="sd">        *func*</span>
</span><span id="L-387"><a href="#L-387"><span class="linenos"> 387</span></a><span class="sd">        </span>
</span><span id="L-388"><a href="#L-388"><span class="linenos"> 388</span></a><span class="sd">         A callable which must take 1 or more xarray.DataArrays as inputs</span>
</span><span id="L-389"><a href="#L-389"><span class="linenos"> 389</span></a><span class="sd">            </span>
</span><span id="L-390"><a href="#L-390"><span class="linenos"> 390</span></a><span class="sd">        *composite_vars*</span>
</span><span id="L-391"><a href="#L-391"><span class="linenos"> 391</span></a><span class="sd">        </span>
</span><span id="L-392"><a href="#L-392"><span class="linenos"> 392</span></a><span class="sd">        An iterable of strings, of the same length as the number of arguments taken by *func*. Each string must be the name of a variable in *LaggedAnalyser.variables* which will be passed into *func* in order.</span>
</span><span id="L-393"><a href="#L-393"><span class="linenos"> 393</span></a><span class="sd">        </span>
</span><span id="L-394"><a href="#L-394"><span class="linenos"> 394</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-395"><a href="#L-395"><span class="linenos"> 395</span></a><span class="sd">        </span>
</span><span id="L-396"><a href="#L-396"><span class="linenos"> 396</span></a><span class="sd">        *as_anomaly*</span>
</span><span id="L-397"><a href="#L-397"><span class="linenos"> 397</span></a><span class="sd">        </span>
</span><span id="L-398"><a href="#L-398"><span class="linenos"> 398</span></a><span class="sd">        A boolean. Whether anomaly composites or full composites should be passed in to func.</span>
</span><span id="L-399"><a href="#L-399"><span class="linenos"> 399</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-400"><a href="#L-400"><span class="linenos"> 400</span></a>        
</span><span id="L-401"><a href="#L-401"><span class="linenos"> 401</span></a>        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">as_anomaly</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
</span><span id="L-402"><a href="#L-402"><span class="linenos"> 402</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;variable-specific anomalies not yet implemented&#39;</span><span class="p">))</span>
</span><span id="L-403"><a href="#L-403"><span class="linenos"> 403</span></a>
</span><span id="L-404"><a href="#L-404"><span class="linenos"> 404</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="L-405"><a href="#L-405"><span class="linenos"> 405</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_derived_da</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="L-406"><a href="#L-406"><span class="linenos"> 406</span></a>        
</span><span id="L-407"><a href="#L-407"><span class="linenos"> 407</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-408"><a href="#L-408"><span class="linenos"> 408</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_derived_da</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="L-409"><a href="#L-409"><span class="linenos"> 409</span></a>            
</span><span id="L-410"><a href="#L-410"><span class="linenos"> 410</span></a>        <span class="k">return</span>
</span><span id="L-411"><a href="#L-411"><span class="linenos"> 411</span></a>
</span><span id="L-412"><a href="#L-412"><span class="linenos"> 412</span></a>    <span class="c1">### Compute bootstraps ###</span>
</span><span id="L-413"><a href="#L-413"><span class="linenos"> 413</span></a>    
</span><span id="L-414"><a href="#L-414"><span class="linenos"> 414</span></a>    <span class="c1">#Top level func</span>
</span><span id="L-415"><a href="#L-415"><span class="linenos"> 415</span></a>    <span class="k">def</span> <span class="nf">compute_bootstraps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">con_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">mean_ds</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">cat_occ_ds</span><span class="p">,</span><span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">synth_mode</span><span class="o">=</span><span class="s1">&#39;markov&#39;</span><span class="p">,</span><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">reuse_ixs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-416"><a href="#L-416"><span class="linenos"> 416</span></a><span class="w">        </span>
</span><span id="L-417"><a href="#L-417"><span class="linenos"> 417</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes composites from synthetic event indices, which can be used to assess whether composites are insignificant.</span>
</span><span id="L-418"><a href="#L-418"><span class="linenos"> 418</span></a><span class="sd">        </span>
</span><span id="L-419"><a href="#L-419"><span class="linenos"> 419</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-420"><a href="#L-420"><span class="linenos"> 420</span></a><span class="sd">        </span>
</span><span id="L-421"><a href="#L-421"><span class="linenos"> 421</span></a><span class="sd">        *bootnum*</span>
</span><span id="L-422"><a href="#L-422"><span class="linenos"> 422</span></a><span class="sd">        </span>
</span><span id="L-423"><a href="#L-423"><span class="linenos"> 423</span></a><span class="sd">        An integer, the number of bootstrapped composites to compute</span>
</span><span id="L-424"><a href="#L-424"><span class="linenos"> 424</span></a><span class="sd">            </span>
</span><span id="L-425"><a href="#L-425"><span class="linenos"> 425</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-426"><a href="#L-426"><span class="linenos"> 426</span></a><span class="sd">        </span>
</span><span id="L-427"><a href="#L-427"><span class="linenos"> 427</span></a><span class="sd">        *dim*</span>
</span><span id="L-428"><a href="#L-428"><span class="linenos"> 428</span></a><span class="sd">        </span>
</span><span id="L-429"><a href="#L-429"><span class="linenos"> 429</span></a><span class="sd">        A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*.</span>
</span><span id="L-430"><a href="#L-430"><span class="linenos"> 430</span></a><span class="sd">            </span>
</span><span id="L-431"><a href="#L-431"><span class="linenos"> 431</span></a><span class="sd">        *con_func*</span>
</span><span id="L-432"><a href="#L-432"><span class="linenos"> 432</span></a><span class="sd">        </span>
</span><span id="L-433"><a href="#L-433"><span class="linenos"> 433</span></a><span class="sd">        The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</span>
</span><span id="L-434"><a href="#L-434"><span class="linenos"> 434</span></a><span class="sd">            </span>
</span><span id="L-435"><a href="#L-435"><span class="linenos"> 435</span></a><span class="sd">        *cat_func*</span>
</span><span id="L-436"><a href="#L-436"><span class="linenos"> 436</span></a><span class="sd">        </span>
</span><span id="L-437"><a href="#L-437"><span class="linenos"> 437</span></a><span class="sd">        The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</span>
</span><span id="L-438"><a href="#L-438"><span class="linenos"> 438</span></a>
</span><span id="L-439"><a href="#L-439"><span class="linenos"> 439</span></a><span class="sd">        *lag*</span>
</span><span id="L-440"><a href="#L-440"><span class="linenos"> 440</span></a><span class="sd">        </span>
</span><span id="L-441"><a href="#L-441"><span class="linenos"> 441</span></a><span class="sd">        An integer, specifying which lagged variables to use for the bootstraps. i.e. bootstraps for lag=90 will be from a completely different season than those for lag=0.</span>
</span><span id="L-442"><a href="#L-442"><span class="linenos"> 442</span></a><span class="sd">            </span>
</span><span id="L-443"><a href="#L-443"><span class="linenos"> 443</span></a><span class="sd">        *synth_mode*</span>
</span><span id="L-444"><a href="#L-444"><span class="linenos"> 444</span></a><span class="sd">        </span>
</span><span id="L-445"><a href="#L-445"><span class="linenos"> 445</span></a><span class="sd">        A string, specifying how synthetic event indices are to be computed. Valid options are:</span>
</span><span id="L-446"><a href="#L-446"><span class="linenos"> 446</span></a><span class="sd">            </span>
</span><span id="L-447"><a href="#L-447"><span class="linenos"> 447</span></a><span class="sd">        &quot;random&quot;: </span>
</span><span id="L-448"><a href="#L-448"><span class="linenos"> 448</span></a><span class="sd">        </span>
</span><span id="L-449"><a href="#L-449"><span class="linenos"> 449</span></a><span class="sd">        categorical values are randomly chosen with the same probability of occurrence as those found in *LaggedAnalyser.event*, but with no autocorrelation.</span>
</span><span id="L-450"><a href="#L-450"><span class="linenos"> 450</span></a>
</span><span id="L-451"><a href="#L-451"><span class="linenos"> 451</span></a><span class="sd">        &quot;markov&quot;: </span>
</span><span id="L-452"><a href="#L-452"><span class="linenos"> 452</span></a><span class="sd">        </span>
</span><span id="L-453"><a href="#L-453"><span class="linenos"> 453</span></a><span class="sd">        A first order Markov chain is fitted to *LaggedAnalyser.event*, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than &quot;random&quot; and so should normally be used.</span>
</span><span id="L-454"><a href="#L-454"><span class="linenos"> 454</span></a>
</span><span id="L-455"><a href="#L-455"><span class="linenos"> 455</span></a><span class="sd">        &quot;shuffle&quot;: </span>
</span><span id="L-456"><a href="#L-456"><span class="linenos"> 456</span></a><span class="sd">        </span>
</span><span id="L-457"><a href="#L-457"><span class="linenos"> 457</span></a><span class="sd">        The values are randomly reordered. This means that each value will occur exactly the same amount of times as in the original index, and so is ideal for particularly rare events or short series.</span>
</span><span id="L-458"><a href="#L-458"><span class="linenos"> 458</span></a><span class="sd">            </span>
</span><span id="L-459"><a href="#L-459"><span class="linenos"> 459</span></a><span class="sd">        *data_vars*</span>
</span><span id="L-460"><a href="#L-460"><span class="linenos"> 460</span></a><span class="sd">        </span>
</span><span id="L-461"><a href="#L-461"><span class="linenos"> 461</span></a><span class="sd">        An iterable of strings, specifying for which variables bootstraps should be computed.</span>
</span><span id="L-462"><a href="#L-462"><span class="linenos"> 462</span></a><span class="sd">                </span>
</span><span id="L-463"><a href="#L-463"><span class="linenos"> 463</span></a><span class="sd">        **returns**</span>
</span><span id="L-464"><a href="#L-464"><span class="linenos"> 464</span></a><span class="sd">        </span>
</span><span id="L-465"><a href="#L-465"><span class="linenos"> 465</span></a><span class="sd">        An xarray.Dataset like *LaggedAnalyser.variables* but summarised according to *con_func* and *cat_func*, and with a new coordinate &#39;bootnum&#39; of length *bootnum*.</span>
</span><span id="L-466"><a href="#L-466"><span class="linenos"> 466</span></a>
</span><span id="L-467"><a href="#L-467"><span class="linenos"> 467</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-468"><a href="#L-468"><span class="linenos"> 468</span></a>        <span class="k">if</span> <span class="n">data_vars</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
</span><span id="L-469"><a href="#L-469"><span class="linenos"> 469</span></a>            <span class="n">data_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
</span><span id="L-470"><a href="#L-470"><span class="linenos"> 470</span></a>
</span><span id="L-471"><a href="#L-471"><span class="linenos"> 471</span></a>        <span class="n">boots</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_derived_boots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_bootstraps</span><span class="p">(</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">,</span><span class="n">reuse_ixs</span><span class="p">))</span>
</span><span id="L-472"><a href="#L-472"><span class="linenos"> 472</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">composites_are_anomaly</span><span class="p">:</span>
</span><span id="L-473"><a href="#L-473"><span class="linenos"> 473</span></a>            <span class="n">boots</span><span class="o">=</span><span class="n">boots</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">)</span>
</span><span id="L-474"><a href="#L-474"><span class="linenos"> 474</span></a>        <span class="k">return</span> <span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">boots</span><span class="p">)</span>
</span><span id="L-475"><a href="#L-475"><span class="linenos"> 475</span></a>    
</span><span id="L-476"><a href="#L-476"><span class="linenos"> 476</span></a>    
</span><span id="L-477"><a href="#L-477"><span class="linenos"> 477</span></a>    <span class="k">def</span> <span class="nf">_compute_derived_da</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">varnames</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">):</span>
</span><span id="L-478"><a href="#L-478"><span class="linenos"> 478</span></a>        <span class="k">if</span> <span class="n">as_anomaly</span><span class="p">:</span>
</span><span id="L-479"><a href="#L-479"><span class="linenos"> 479</span></a>            <span class="n">input_vars</span><span class="o">=</span><span class="p">[</span><span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varnames</span><span class="p">]</span>
</span><span id="L-480"><a href="#L-480"><span class="linenos"> 480</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-481"><a href="#L-481"><span class="linenos"> 481</span></a>            <span class="n">input_vars</span><span class="o">=</span><span class="p">[</span><span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varnames</span><span class="p">]</span>
</span><span id="L-482"><a href="#L-482"><span class="linenos"> 482</span></a>        <span class="k">return</span> <span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">input_vars</span><span class="p">))</span>
</span><span id="L-483"><a href="#L-483"><span class="linenos"> 483</span></a>    
</span><span id="L-484"><a href="#L-484"><span class="linenos"> 484</span></a>    
</span><span id="L-485"><a href="#L-485"><span class="linenos"> 485</span></a>    <span class="k">def</span> <span class="nf">_add_derived_boots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">boots</span><span class="p">):</span>
</span><span id="L-486"><a href="#L-486"><span class="linenos"> 486</span></a>        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="p">:</span>
</span><span id="L-487"><a href="#L-487"><span class="linenos"> 487</span></a>            <span class="n">func</span><span class="p">,</span><span class="n">input_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="L-488"><a href="#L-488"><span class="linenos"> 488</span></a>            <span class="n">boots</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_derived_da</span><span class="p">(</span><span class="n">boots</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">input_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="L-489"><a href="#L-489"><span class="linenos"> 489</span></a>        <span class="k">return</span> <span class="n">boots</span>
</span><span id="L-490"><a href="#L-490"><span class="linenos"> 490</span></a>
</span><span id="L-491"><a href="#L-491"><span class="linenos"> 491</span></a>    <span class="k">def</span> <span class="nf">_compute_bootstraps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">,</span><span class="n">reuse_ixs</span><span class="p">):</span>
</span><span id="L-492"><a href="#L-492"><span class="linenos"> 492</span></a>
</span><span id="L-493"><a href="#L-493"><span class="linenos"> 493</span></a>        <span class="n">da</span><span class="p">,</span><span class="n">ds</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_variables</span><span class="p">(</span><span class="n">lag</span><span class="p">))</span>
</span><span id="L-494"><a href="#L-494"><span class="linenos"> 494</span></a>        <span class="n">ds</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="n">data_vars</span><span class="p">]</span>
</span><span id="L-495"><a href="#L-495"><span class="linenos"> 495</span></a>        
</span><span id="L-496"><a href="#L-496"><span class="linenos"> 496</span></a>        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boot_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="ow">not</span> <span class="n">reuse_ixs</span><span class="p">):</span>
</span><span id="L-497"><a href="#L-497"><span class="linenos"> 497</span></a>            
</span><span id="L-498"><a href="#L-498"><span class="linenos"> 498</span></a>            <span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_bootparams</span><span class="p">(</span><span class="n">da</span><span class="p">)</span>
</span><span id="L-499"><a href="#L-499"><span class="linenos"> 499</span></a>            <span class="n">ixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_synth_indices</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">da</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
</span><span id="L-500"><a href="#L-500"><span class="linenos"> 500</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">boot_indices</span><span class="o">=</span><span class="n">ixs</span>
</span><span id="L-501"><a href="#L-501"><span class="linenos"> 501</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-502"><a href="#L-502"><span class="linenos"> 502</span></a>            <span class="n">ixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">boot_indices</span>
</span><span id="L-503"><a href="#L-503"><span class="linenos"> 503</span></a>            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reusing stored boot_indices, ignoring new boot parameters.&#39;</span><span class="p">)</span>
</span><span id="L-504"><a href="#L-504"><span class="linenos"> 504</span></a>        
</span><span id="L-505"><a href="#L-505"><span class="linenos"> 505</span></a>        <span class="n">boots</span><span class="o">=</span><span class="p">[</span><span class="n">make_all_dims_coords</span><span class="p">(</span>\
</span><span id="L-506"><a href="#L-506"><span class="linenos"> 506</span></a>                <span class="bp">self</span><span class="o">.</span><span class="n">_composite_from_ix</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span><span class="n">ds</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="p">)</span>\
</span><span id="L-507"><a href="#L-507"><span class="linenos"> 507</span></a>             <span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">ixs</span><span class="p">]</span>
</span><span id="L-508"><a href="#L-508"><span class="linenos"> 508</span></a>        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">boots</span><span class="p">,</span><span class="s1">&#39;boot_num&#39;</span><span class="p">)</span>
</span><span id="L-509"><a href="#L-509"><span class="linenos"> 509</span></a>    
</span><span id="L-510"><a href="#L-510"><span class="linenos"> 510</span></a>    <span class="c1">#Gets some necessary variables</span>
</span><span id="L-511"><a href="#L-511"><span class="linenos"> 511</span></a>    <span class="k">def</span> <span class="nf">_get_bootparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">da</span><span class="p">):</span>
</span><span id="L-512"><a href="#L-512"><span class="linenos"> 512</span></a>        <span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="L-513"><a href="#L-513"><span class="linenos"> 513</span></a>        <span class="k">return</span> <span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">da</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">da</span><span class="p">)</span>
</span><span id="L-514"><a href="#L-514"><span class="linenos"> 514</span></a>    
</span><span id="L-515"><a href="#L-515"><span class="linenos"> 515</span></a>    <span class="c1">#compute indices</span>
</span><span id="L-516"><a href="#L-516"><span class="linenos"> 516</span></a>    <span class="k">def</span> <span class="nf">_get_synth_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="n">da</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
</span><span id="L-517"><a href="#L-517"><span class="linenos"> 517</span></a>        
</span><span id="L-518"><a href="#L-518"><span class="linenos"> 518</span></a>        <span class="n">ixs</span><span class="o">=</span><span class="p">[]</span>
</span><span id="L-519"><a href="#L-519"><span class="linenos"> 519</span></a>        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;markov&#39;</span><span class="p">:</span>
</span><span id="L-520"><a href="#L-520"><span class="linenos"> 520</span></a>            <span class="n">xs</span><span class="o">=</span><span class="n">split_to_contiguous</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">x_arr</span><span class="o">=</span><span class="n">da</span><span class="p">)</span>
</span><span id="L-521"><a href="#L-521"><span class="linenos"> 521</span></a>            <span class="n">T</span><span class="o">=</span><span class="n">get_transmat</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
</span><span id="L-522"><a href="#L-522"><span class="linenos"> 522</span></a>            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bootnum</span><span class="p">):</span>
</span><span id="L-523"><a href="#L-523"><span class="linenos"> 523</span></a>                <span class="n">ixs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synthetic_states_from_transmat</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</span><span id="L-524"><a href="#L-524"><span class="linenos"> 524</span></a>                
</span><span id="L-525"><a href="#L-525"><span class="linenos"> 525</span></a>        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;random&#39;</span><span class="p">:</span>
</span><span id="L-526"><a href="#L-526"><span class="linenos"> 526</span></a>            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bootnum</span><span class="p">):</span>
</span><span id="L-527"><a href="#L-527"><span class="linenos"> 527</span></a>                <span class="n">ixs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ix_vals</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">ix_probs</span><span class="p">)))</span>
</span><span id="L-528"><a href="#L-528"><span class="linenos"> 528</span></a>                
</span><span id="L-529"><a href="#L-529"><span class="linenos"> 529</span></a>        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;shuffle&#39;</span><span class="p">:</span>
</span><span id="L-530"><a href="#L-530"><span class="linenos"> 530</span></a>            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bootnum</span><span class="p">):</span>
</span><span id="L-531"><a href="#L-531"><span class="linenos"> 531</span></a>                <span class="n">ixv</span><span class="o">=</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span><span id="L-532"><a href="#L-532"><span class="linenos"> 532</span></a>                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">ixv</span><span class="p">)</span>
</span><span id="L-533"><a href="#L-533"><span class="linenos"> 533</span></a>                
</span><span id="L-534"><a href="#L-534"><span class="linenos"> 534</span></a>                <span class="n">ixs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ixv</span><span class="p">)</span>
</span><span id="L-535"><a href="#L-535"><span class="linenos"> 535</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-536"><a href="#L-536"><span class="linenos"> 536</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;synth_mode=</span><span class="si">{</span><span class="n">synth_mode</span><span class="si">}</span><span class="s1"> is not valid.&#39;</span><span class="p">))</span>
</span><span id="L-537"><a href="#L-537"><span class="linenos"> 537</span></a>            
</span><span id="L-538"><a href="#L-538"><span class="linenos"> 538</span></a>        <span class="k">return</span> <span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">ixs</span><span class="p">]</span>
</span><span id="L-539"><a href="#L-539"><span class="linenos"> 539</span></a>        
</span><span id="L-540"><a href="#L-540"><span class="linenos"> 540</span></a>    <span class="c1">### apply significance test ###</span>
</span><span id="L-541"><a href="#L-541"><span class="linenos"> 541</span></a>    
</span><span id="L-542"><a href="#L-542"><span class="linenos"> 542</span></a>    <span class="k">def</span> <span class="nf">get_significance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootstraps</span><span class="p">,</span><span class="n">comp</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">hb_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-543"><a href="#L-543"><span class="linenos"> 543</span></a><span class="w">        </span>
</span><span id="L-544"><a href="#L-544"><span class="linenos"> 544</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes whether a composite is significant with respect to a given distribution of bootstrapped composites. </span>
</span><span id="L-545"><a href="#L-545"><span class="linenos"> 545</span></a><span class="sd">        </span>
</span><span id="L-546"><a href="#L-546"><span class="linenos"> 546</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-547"><a href="#L-547"><span class="linenos"> 547</span></a><span class="sd">        </span>
</span><span id="L-548"><a href="#L-548"><span class="linenos"> 548</span></a><span class="sd">        *bootstraps*</span>
</span><span id="L-549"><a href="#L-549"><span class="linenos"> 549</span></a>
</span><span id="L-550"><a href="#L-550"><span class="linenos"> 550</span></a><span class="sd">        An xarray.Dataset with a coordinate &#39;bootnum&#39;, such as produced by *LaggedAnalyser.compute_bootstraps*</span>
</span><span id="L-551"><a href="#L-551"><span class="linenos"> 551</span></a>
</span><span id="L-552"><a href="#L-552"><span class="linenos"> 552</span></a><span class="sd">        *comp*</span>
</span><span id="L-553"><a href="#L-553"><span class="linenos"> 553</span></a>
</span><span id="L-554"><a href="#L-554"><span class="linenos"> 554</span></a><span class="sd">        An xarray Dataset of the same shape as *bootstraps* but without a &#39;bootnum&#39; coordinate. Missing or additional variables are allowed, and are simply ignored.</span>
</span><span id="L-555"><a href="#L-555"><span class="linenos"> 555</span></a><span class="sd">        *p*</span>
</span><span id="L-556"><a href="#L-556"><span class="linenos"> 556</span></a>
</span><span id="L-557"><a href="#L-557"><span class="linenos"> 557</span></a><span class="sd">        A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </span>
</span><span id="L-558"><a href="#L-558"><span class="linenos"> 558</span></a><span class="sd">            </span>
</span><span id="L-559"><a href="#L-559"><span class="linenos"> 559</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-560"><a href="#L-560"><span class="linenos"> 560</span></a>
</span><span id="L-561"><a href="#L-561"><span class="linenos"> 561</span></a><span class="sd">        *data_vars*</span>
</span><span id="L-562"><a href="#L-562"><span class="linenos"> 562</span></a><span class="sd">            </span>
</span><span id="L-563"><a href="#L-563"><span class="linenos"> 563</span></a><span class="sd">        An iterable of strings, specifying for which variables significance should be computed.</span>
</span><span id="L-564"><a href="#L-564"><span class="linenos"> 564</span></a><span class="sd">            </span>
</span><span id="L-565"><a href="#L-565"><span class="linenos"> 565</span></a><span class="sd">        *hb_correction*</span>
</span><span id="L-566"><a href="#L-566"><span class="linenos"> 566</span></a><span class="sd">        </span>
</span><span id="L-567"><a href="#L-567"><span class="linenos"> 567</span></a><span class="sd">        A Boolean, specifying whether a Holm-Bonferroni correction should be applied to *p*, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in *comp* independently, and so will have no impact on scalar variables.</span>
</span><span id="L-568"><a href="#L-568"><span class="linenos"> 568</span></a><span class="sd">        </span>
</span><span id="L-569"><a href="#L-569"><span class="linenos"> 569</span></a><span class="sd">        **returns**</span>
</span><span id="L-570"><a href="#L-570"><span class="linenos"> 570</span></a><span class="sd">        </span>
</span><span id="L-571"><a href="#L-571"><span class="linenos"> 571</span></a><span class="sd">        An xarray.Dataset like *comp* but with boolean data, specifying whether each feature of each variable passed the significance test.</span>
</span><span id="L-572"><a href="#L-572"><span class="linenos"> 572</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-573"><a href="#L-573"><span class="linenos"> 573</span></a>        <span class="k">if</span> <span class="n">data_vars</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
</span><span id="L-574"><a href="#L-574"><span class="linenos"> 574</span></a>            <span class="n">data_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">bootstraps</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
</span><span id="L-575"><a href="#L-575"><span class="linenos"> 575</span></a>
</span><span id="L-576"><a href="#L-576"><span class="linenos"> 576</span></a>        <span class="n">bootnum</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bootstraps</span><span class="o">.</span><span class="n">boot_num</span><span class="p">)</span>
</span><span id="L-577"><a href="#L-577"><span class="linenos"> 577</span></a>        <span class="n">comp</span><span class="o">=</span><span class="n">comp</span><span class="p">[</span><span class="n">data_vars</span><span class="p">]</span>
</span><span id="L-578"><a href="#L-578"><span class="linenos"> 578</span></a>        <span class="n">bootstraps</span><span class="o">=</span><span class="n">bootstraps</span><span class="p">[</span><span class="n">data_vars</span><span class="p">]</span>
</span><span id="L-579"><a href="#L-579"><span class="linenos"> 579</span></a>        <span class="n">frac</span><span class="o">=</span><span class="p">(</span><span class="n">comp</span><span class="o">&lt;</span><span class="n">bootstraps</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="s1">&#39;boot_num&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">bootnum</span>
</span><span id="L-580"><a href="#L-580"><span class="linenos"> 580</span></a>        <span class="n">pval_ds</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
</span><span id="L-581"><a href="#L-581"><span class="linenos"> 581</span></a>        <span class="k">if</span> <span class="n">hb_correction</span><span class="p">:</span>
</span><span id="L-582"><a href="#L-582"><span class="linenos"> 582</span></a>            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">pval_ds</span><span class="p">:</span>
</span><span id="L-583"><a href="#L-583"><span class="linenos"> 583</span></a>                <span class="n">corrected_pval</span><span class="o">=</span><span class="n">holm_bonferroni_correction</span><span class="p">(</span><span class="n">pval_ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">p</span><span class="p">)</span>\
</span><span id="L-584"><a href="#L-584"><span class="linenos"> 584</span></a>                            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pval_ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span><span id="L-585"><a href="#L-585"><span class="linenos"> 585</span></a>                <span class="n">pval_ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">corrected_pval</span>
</span><span id="L-586"><a href="#L-586"><span class="linenos"> 586</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-587"><a href="#L-587"><span class="linenos"> 587</span></a>            <span class="n">pval_ds</span><span class="o">=</span><span class="n">pval_ds</span><span class="o">&lt;</span><span class="n">p</span>
</span><span id="L-588"><a href="#L-588"><span class="linenos"> 588</span></a>            
</span><span id="L-589"><a href="#L-589"><span class="linenos"> 589</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span><span class="o">=</span><span class="n">pval_ds</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">lag</span><span class="o">=</span><span class="n">comp</span><span class="o">.</span><span class="n">lag</span><span class="p">)</span>
</span><span id="L-590"><a href="#L-590"><span class="linenos"> 590</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span>
</span><span id="L-591"><a href="#L-591"><span class="linenos"> 591</span></a>    
</span><span id="L-592"><a href="#L-592"><span class="linenos"> 592</span></a>    <span class="k">def</span> <span class="nf">bootstrap_significance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">synth_mode</span><span class="o">=</span><span class="s1">&#39;markov&#39;</span><span class="p">,</span><span class="n">reuse_lag0_boots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">hb_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-593"><a href="#L-593"><span class="linenos"> 593</span></a><span class="w">        </span>
</span><span id="L-594"><a href="#L-594"><span class="linenos"> 594</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;A wrapper around *compute_bootstraps* and *get_significance*, that calculates bootstraps and applies a significance test to a number of time lagged composites simulataneously.</span>
</span><span id="L-595"><a href="#L-595"><span class="linenos"> 595</span></a><span class="sd">        </span>
</span><span id="L-596"><a href="#L-596"><span class="linenos"> 596</span></a><span class="sd">    **Arguments**</span>
</span><span id="L-597"><a href="#L-597"><span class="linenos"> 597</span></a>
</span><span id="L-598"><a href="#L-598"><span class="linenos"> 598</span></a><span class="sd">    *bootnum*</span>
</span><span id="L-599"><a href="#L-599"><span class="linenos"> 599</span></a>
</span><span id="L-600"><a href="#L-600"><span class="linenos"> 600</span></a><span class="sd">    An integer, the number of bootstrapped composites to compute</span>
</span><span id="L-601"><a href="#L-601"><span class="linenos"> 601</span></a>
</span><span id="L-602"><a href="#L-602"><span class="linenos"> 602</span></a><span class="sd">    *p*</span>
</span><span id="L-603"><a href="#L-603"><span class="linenos"> 603</span></a>
</span><span id="L-604"><a href="#L-604"><span class="linenos"> 604</span></a><span class="sd">    A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </span>
</span><span id="L-605"><a href="#L-605"><span class="linenos"> 605</span></a>
</span><span id="L-606"><a href="#L-606"><span class="linenos"> 606</span></a><span class="sd">    **Optional arguments**</span>
</span><span id="L-607"><a href="#L-607"><span class="linenos"> 607</span></a>
</span><span id="L-608"><a href="#L-608"><span class="linenos"> 608</span></a><span class="sd">    *dim*</span>
</span><span id="L-609"><a href="#L-609"><span class="linenos"> 609</span></a>
</span><span id="L-610"><a href="#L-610"><span class="linenos"> 610</span></a><span class="sd">    A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*.</span>
</span><span id="L-611"><a href="#L-611"><span class="linenos"> 611</span></a>
</span><span id="L-612"><a href="#L-612"><span class="linenos"> 612</span></a><span class="sd">    *synth_mode*</span>
</span><span id="L-613"><a href="#L-613"><span class="linenos"> 613</span></a>
</span><span id="L-614"><a href="#L-614"><span class="linenos"> 614</span></a><span class="sd">    A string, specifying how synthetic event indices are to be computed. Valid options are:</span>
</span><span id="L-615"><a href="#L-615"><span class="linenos"> 615</span></a><span class="sd">    &quot;random&quot;: categorical values are randomly chosen with the same probability of occurrence as those found in *LaggedAnalyser.event*, but with no autocorrelation.</span>
</span><span id="L-616"><a href="#L-616"><span class="linenos"> 616</span></a><span class="sd">    &#39;markov&#39;: A first order Markov chain is fitted to *LaggedAnalyser.event*, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than &quot;random&quot; and so should normally be used.</span>
</span><span id="L-617"><a href="#L-617"><span class="linenos"> 617</span></a>
</span><span id="L-618"><a href="#L-618"><span class="linenos"> 618</span></a><span class="sd">    *reuse_lag0_boots*</span>
</span><span id="L-619"><a href="#L-619"><span class="linenos"> 619</span></a><span class="sd">        A Boolean. If True, bootstraps are only computed for lag=0, and then used as a null distribution to assess all lagged composites. For variables which are approximately stationary across the lag timescale, then this is a good approximation and can increase performance. However if used incorrectly, it may lead to &#39;significant composites&#39; which simply reflect the seasonal cycle. if False, separate bootstraps are computed for all time lags.</span>
</span><span id="L-620"><a href="#L-620"><span class="linenos"> 620</span></a>
</span><span id="L-621"><a href="#L-621"><span class="linenos"> 621</span></a><span class="sd">    *data_vars*</span>
</span><span id="L-622"><a href="#L-622"><span class="linenos"> 622</span></a><span class="sd">        An iterable of strings, specifying for which variables significance should be computed.</span>
</span><span id="L-623"><a href="#L-623"><span class="linenos"> 623</span></a>
</span><span id="L-624"><a href="#L-624"><span class="linenos"> 624</span></a><span class="sd">    *hb_correction*</span>
</span><span id="L-625"><a href="#L-625"><span class="linenos"> 625</span></a><span class="sd">        A Boolean, specifying whether a Holm-Bonferroni correction should be applied to *p*, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in *comp* independently, and so will have no impact on scalar variables.</span>
</span><span id="L-626"><a href="#L-626"><span class="linenos"> 626</span></a><span class="sd">        </span>
</span><span id="L-627"><a href="#L-627"><span class="linenos"> 627</span></a><span class="sd">    **returns**</span>
</span><span id="L-628"><a href="#L-628"><span class="linenos"> 628</span></a>
</span><span id="L-629"><a href="#L-629"><span class="linenos"> 629</span></a><span class="sd">    An xarray.Dataset like *LaggedAnalyser.variables* but with the *dim* dimension summarised according to *con_func* and *cat_func*, an additional *lag* coordinate, and with boolean data specifying whether each feature of each variable passed the significance test.</span>
</span><span id="L-630"><a href="#L-630"><span class="linenos"> 630</span></a>
</span><span id="L-631"><a href="#L-631"><span class="linenos"> 631</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-632"><a href="#L-632"><span class="linenos"> 632</span></a>        <span class="n">lag_vals</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)</span>
</span><span id="L-633"><a href="#L-633"><span class="linenos"> 633</span></a>        
</span><span id="L-634"><a href="#L-634"><span class="linenos"> 634</span></a>        <span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">composite_func</span>
</span><span id="L-635"><a href="#L-635"><span class="linenos"> 635</span></a>        
</span><span id="L-636"><a href="#L-636"><span class="linenos"> 636</span></a>        <span class="n">boots</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_bootstraps</span><span class="p">(</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">)</span>
</span><span id="L-637"><a href="#L-637"><span class="linenos"> 637</span></a>        
</span><span id="L-638"><a href="#L-638"><span class="linenos"> 638</span></a>        <span class="c1">#reuse_lag0_boots=True can substantially reduce run time!</span>
</span><span id="L-639"><a href="#L-639"><span class="linenos"> 639</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="n">reuse_lag0_boots</span><span class="p">:</span>
</span><span id="L-640"><a href="#L-640"><span class="linenos"> 640</span></a>                    <span class="n">boots</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">boots</span><span class="p">,</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_bootstraps</span><span class="p">(</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">)</span>\
</span><span id="L-641"><a href="#L-641"><span class="linenos"> 641</span></a>                        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lag_vals</span><span class="p">]],</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span>
</span><span id="L-642"><a href="#L-642"><span class="linenos"> 642</span></a>                
</span><span id="L-643"><a href="#L-643"><span class="linenos"> 643</span></a>        <span class="n">sig_composite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_significance</span><span class="p">(</span><span class="n">boots</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">data_vars</span><span class="p">,</span><span class="n">hb_correction</span><span class="o">=</span><span class="n">hb_correction</span><span class="p">)</span>
</span><span id="L-644"><a href="#L-644"><span class="linenos"> 644</span></a>        
</span><span id="L-645"><a href="#L-645"><span class="linenos"> 645</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span><span class="o">=</span><span class="n">sig_composite</span>
</span><span id="L-646"><a href="#L-646"><span class="linenos"> 646</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span>
</span><span id="L-647"><a href="#L-647"><span class="linenos"> 647</span></a>    
</span><span id="L-648"><a href="#L-648"><span class="linenos"> 648</span></a>    
</span><span id="L-649"><a href="#L-649"><span class="linenos"> 649</span></a>    <span class="k">def</span> <span class="nf">deseasonalise_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">variable_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">agg</span><span class="o">=</span><span class="s1">&#39;dayofyear&#39;</span><span class="p">,</span><span class="n">smooth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">coeffs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="L-650"><a href="#L-650"><span class="linenos"> 650</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes a seasonal cycle for each variable in *LaggedAnalyser.variables* and subtracts it inplace, turning *LaggedAnalyser.variables* into deseasonalised anomalies. The seasonal cycle is computed via temporal aggregation of each variable over a given period - by default the calendar day of the year. This cycle can then be smoothed with an n-point rolling average.</span>
</span><span id="L-651"><a href="#L-651"><span class="linenos"> 651</span></a>
</span><span id="L-652"><a href="#L-652"><span class="linenos"> 652</span></a><span class="sd">                **Optional arguments**</span>
</span><span id="L-653"><a href="#L-653"><span class="linenos"> 653</span></a>
</span><span id="L-654"><a href="#L-654"><span class="linenos"> 654</span></a><span class="sd">                *variable_list*</span>
</span><span id="L-655"><a href="#L-655"><span class="linenos"> 655</span></a><span class="sd">                </span>
</span><span id="L-656"><a href="#L-656"><span class="linenos"> 656</span></a><span class="sd">                A list of variables to deseasonalise. Defaults to all variables in the *LaggedAnalyser.variables*</span>
</span><span id="L-657"><a href="#L-657"><span class="linenos"> 657</span></a>
</span><span id="L-658"><a href="#L-658"><span class="linenos"> 658</span></a><span class="sd">                *dim*</span>
</span><span id="L-659"><a href="#L-659"><span class="linenos"> 659</span></a><span class="sd">                </span>
</span><span id="L-660"><a href="#L-660"><span class="linenos"> 660</span></a><span class="sd">                A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*, along which the seasonal cycle is computed. Currently, only timelike coordinates are supported.</span>
</span><span id="L-661"><a href="#L-661"><span class="linenos"> 661</span></a><span class="sd">                </span>
</span><span id="L-662"><a href="#L-662"><span class="linenos"> 662</span></a><span class="sd">                *agg*</span>
</span><span id="L-663"><a href="#L-663"><span class="linenos"> 663</span></a><span class="sd">                </span>
</span><span id="L-664"><a href="#L-664"><span class="linenos"> 664</span></a><span class="sd">                A string specifying the datetime-like field to aggregate over. Useful and supported values are &#39;season&#39;, &#39;month&#39;, &#39;weekofyear&#39;, and &#39;dayofyear&#39;</span>
</span><span id="L-665"><a href="#L-665"><span class="linenos"> 665</span></a><span class="sd">                    </span>
</span><span id="L-666"><a href="#L-666"><span class="linenos"> 666</span></a><span class="sd">                *smooth*</span>
</span><span id="L-667"><a href="#L-667"><span class="linenos"> 667</span></a><span class="sd">                </span>
</span><span id="L-668"><a href="#L-668"><span class="linenos"> 668</span></a><span class="sd">                An integer, specifying the size of the n-timestep centred rolling mean applied to the aggregated seasonal cycle. By default *smooth*=1 results in no smoothing.</span>
</span><span id="L-669"><a href="#L-669"><span class="linenos"> 669</span></a>
</span><span id="L-670"><a href="#L-670"><span class="linenos"> 670</span></a><span class="sd">                *coeffs*</span>
</span><span id="L-671"><a href="#L-671"><span class="linenos"> 671</span></a><span class="sd">                </span>
</span><span id="L-672"><a href="#L-672"><span class="linenos"> 672</span></a><span class="sd">                A Dataset containing a precomputed seasonal cycle, which, if *LaggedAnalyser.variables* has coordinates (*dim*,[X,Y,...,Z]), has coords (*agg*,[X,Y,...,Z]), and has the same data variables as *LaggedAnalyser.variables*. If *coeffs* is provided, no seasonal cycle is fitted to *LaggedAnalyser.variables*, *coeffs* is used instead.</span>
</span><span id="L-673"><a href="#L-673"><span class="linenos"> 673</span></a>
</span><span id="L-674"><a href="#L-674"><span class="linenos"> 674</span></a><span class="sd">        &quot;&quot;&quot;</span>        
</span><span id="L-675"><a href="#L-675"><span class="linenos"> 675</span></a>
</span><span id="L-676"><a href="#L-676"><span class="linenos"> 676</span></a>        <span class="k">if</span> <span class="n">variable_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-677"><a href="#L-677"><span class="linenos"> 677</span></a>            <span class="n">variable_list</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
</span><span id="L-678"><a href="#L-678"><span class="linenos"> 678</span></a>        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">:</span>
</span><span id="L-679"><a href="#L-679"><span class="linenos"> 679</span></a>            <span class="n">da</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="L-680"><a href="#L-680"><span class="linenos"> 680</span></a>            <span class="n">dsnlsr</span><span class="o">=</span><span class="n">Agg_Deseasonaliser</span><span class="p">()</span>
</span><span id="L-681"><a href="#L-681"><span class="linenos"> 681</span></a>            <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-682"><a href="#L-682"><span class="linenos"> 682</span></a>                <span class="n">dsnlsr</span><span class="o">.</span><span class="n">fit_cycle</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span><span class="n">agg</span><span class="o">=</span><span class="n">agg</span><span class="p">)</span>
</span><span id="L-683"><a href="#L-683"><span class="linenos"> 683</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="L-684"><a href="#L-684"><span class="linenos"> 684</span></a>                <span class="n">dsnslr</span><span class="o">.</span><span class="n">cycle_coeffs</span><span class="o">=</span><span class="n">coeffs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="L-685"><a href="#L-685"><span class="linenos"> 685</span></a>
</span><span id="L-686"><a href="#L-686"><span class="linenos"> 686</span></a>            <span class="n">cycle</span><span class="o">=</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">evaluate_cycle</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">da</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
</span><span id="L-687"><a href="#L-687"><span class="linenos"> 687</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">data</span><span class="o">-</span><span class="n">cycle</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</span><span id="L-688"><a href="#L-688"><span class="linenos"> 688</span></a>            <span class="n">dsnlsr</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span> <span class="c1">#Prevents excess memory storage</span>
</span><span id="L-689"><a href="#L-689"><span class="linenos"> 689</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">dsnlsr</span>
</span><span id="L-690"><a href="#L-690"><span class="linenos"> 690</span></a>        <span class="k">return</span>   
</span><span id="L-691"><a href="#L-691"><span class="linenos"> 691</span></a>    
</span><span id="L-692"><a href="#L-692"><span class="linenos"> 692</span></a>    <span class="k">def</span> <span class="nf">get_seasonal_cycle_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-693"><a href="#L-693"><span class="linenos"> 693</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Retrieve seasonal cycle coeffs computed with *LaggedAnalyser.deseasonalise_variables*, suitable for passing into *coeffs* in other *LaggedAnalyser.deseasonalise_variables* function calls as a precomputed cycle.</span>
</span><span id="L-694"><a href="#L-694"><span class="linenos"> 694</span></a><span class="sd">        </span>
</span><span id="L-695"><a href="#L-695"><span class="linenos"> 695</span></a><span class="sd">        **Returns**</span>
</span><span id="L-696"><a href="#L-696"><span class="linenos"> 696</span></a><span class="sd">        An xarray.Dataset, as specified in  the *LaggedAnalyser.deseasonalise_variables* *coeff* optional keyword.</span>
</span><span id="L-697"><a href="#L-697"><span class="linenos"> 697</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-698"><a href="#L-698"><span class="linenos"> 698</span></a>        <span class="n">coeffs</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">({</span><span class="n">v</span><span class="p">:</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">cycle_coeffs</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">dsnlsr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
</span><span id="L-699"><a href="#L-699"><span class="linenos"> 699</span></a>        <span class="k">return</span> <span class="n">coeffs</span>
</span><span id="L-700"><a href="#L-700"><span class="linenos"> 700</span></a>
</span><span id="L-701"><a href="#L-701"><span class="linenos"> 701</span></a>    <span class="c1">#If deseasonalise_variables has been called, then this func can be used to compute the</span>
</span><span id="L-702"><a href="#L-702"><span class="linenos"> 702</span></a>    <span class="c1">#seasonal mean state corresponding to a given composite. This mean state+ the composite</span>
</span><span id="L-703"><a href="#L-703"><span class="linenos"> 703</span></a>    <span class="c1"># produced by self.compute_composites gives the full field composite pattern.</span>
</span><span id="L-704"><a href="#L-704"><span class="linenos"> 704</span></a>    <span class="k">def</span> <span class="nf">get_composite_seasonal_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-705"><a href="#L-705"><span class="linenos"> 705</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="L-706"><a href="#L-706"><span class="linenos"> 706</span></a><span class="sd">        If *LaggedAnalyser.deseasonalise_variables* has been called, then this function returns the seasonal mean state corresponding to a given composite, given by a sum of the seasonal cycle weighted by the time-varying occurrence of each categorical value in *LaggedAnalyser.events*. This mean state + the deseasonalised anomaly composite</span>
</span><span id="L-707"><a href="#L-707"><span class="linenos"> 707</span></a><span class="sd">    produced by *LaggedAnalyser.compute_composites* then retrieves the full composite pattern.</span>
</span><span id="L-708"><a href="#L-708"><span class="linenos"> 708</span></a><span class="sd">    </span>
</span><span id="L-709"><a href="#L-709"><span class="linenos"> 709</span></a><span class="sd">    **Returns**</span>
</span><span id="L-710"><a href="#L-710"><span class="linenos"> 710</span></a><span class="sd">        An xarray.Dataset containing the composite seasonal mean values.</span>
</span><span id="L-711"><a href="#L-711"><span class="linenos"> 711</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-712"><a href="#L-712"><span class="linenos"> 712</span></a>        <span class="n">variable_list</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="p">)</span>
</span><span id="L-713"><a href="#L-713"><span class="linenos"> 713</span></a>        <span class="n">ts</span><span class="o">=</span><span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">==</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">)}</span>
</span><span id="L-714"><a href="#L-714"><span class="linenos"> 714</span></a>        <span class="n">lags</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)])</span>
</span><span id="L-715"><a href="#L-715"><span class="linenos"> 715</span></a>        
</span><span id="L-716"><a href="#L-716"><span class="linenos"> 716</span></a>        <span class="n">mean_states</span><span class="o">=</span><span class="p">{}</span>
</span><span id="L-717"><a href="#L-717"><span class="linenos"> 717</span></a>        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">:</span>
</span><span id="L-718"><a href="#L-718"><span class="linenos"> 718</span></a>            <span class="n">dsnlsr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="L-719"><a href="#L-719"><span class="linenos"> 719</span></a>            <span class="n">agg</span><span class="o">=</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">agg</span>
</span><span id="L-720"><a href="#L-720"><span class="linenos"> 720</span></a>            <span class="n">mean_states</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>\
</span><span id="L-721"><a href="#L-721"><span class="linenos"> 721</span></a>                                 <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>\
</span><span id="L-722"><a href="#L-722"><span class="linenos"> 722</span></a>                                    <span class="bp">self</span><span class="o">.</span><span class="n">_lag_average_cycle</span><span class="p">(</span><span class="n">dsnlsr</span><span class="p">,</span><span class="n">agg</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>\
</span><span id="L-723"><a href="#L-723"><span class="linenos"> 723</span></a>                                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">],</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span>\
</span><span id="L-724"><a href="#L-724"><span class="linenos"> 724</span></a>                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span><span class="s1">&#39;index_val&#39;</span><span class="p">)</span>
</span><span id="L-725"><a href="#L-725"><span class="linenos"> 725</span></a>            
</span><span id="L-726"><a href="#L-726"><span class="linenos"> 726</span></a>        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">mean_states</span><span class="p">)</span>
</span><span id="L-727"><a href="#L-727"><span class="linenos"> 727</span></a>        
</span><span id="L-728"><a href="#L-728"><span class="linenos"> 728</span></a>    <span class="k">def</span> <span class="nf">_lag_average_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dsnlsr</span><span class="p">,</span><span class="n">agg</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
</span><span id="L-729"><a href="#L-729"><span class="linenos"> 729</span></a>        
</span><span id="L-730"><a href="#L-730"><span class="linenos"> 730</span></a>        <span class="n">dt</span><span class="o">=</span><span class="n">durel</span><span class="o">.</span><span class="n">relativedelta</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">offset_unit</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">)})</span>
</span><span id="L-731"><a href="#L-731"><span class="linenos"> 731</span></a>        <span class="n">tvals</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span><span class="o">+</span><span class="n">dt</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
</span><span id="L-732"><a href="#L-732"><span class="linenos"> 732</span></a>        <span class="n">cycle_eval</span><span class="o">=</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">cycle_coeffs</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">agg</span><span class="p">:</span><span class="nb">getattr</span><span class="p">(</span><span class="n">tvals</span><span class="p">,</span><span class="n">agg</span><span class="p">)})</span>
</span><span id="L-733"><a href="#L-733"><span class="linenos"> 733</span></a>        <span class="n">cycle_mean</span><span class="o">=</span><span class="n">cycle_eval</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;lag&#39;</span><span class="p">:</span><span class="n">l</span><span class="p">,</span><span class="s1">&#39;index_val&#39;</span><span class="p">:</span><span class="n">i</span><span class="p">})</span>
</span><span id="L-734"><a href="#L-734"><span class="linenos"> 734</span></a>        <span class="k">return</span> <span class="n">cycle_mean</span>
</span><span id="L-735"><a href="#L-735"><span class="linenos"> 735</span></a>    
</span><span id="L-736"><a href="#L-736"><span class="linenos"> 736</span></a><span class="k">class</span> <span class="nc">PatternFilter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span id="L-737"><a href="#L-737"><span class="linenos"> 737</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;Provides filtering methods to refine n-dimensional boolean masks, and apply them to an underlying dataset.</span>
</span><span id="L-738"><a href="#L-738"><span class="linenos"> 738</span></a><span class="sd">    </span>
</span><span id="L-739"><a href="#L-739"><span class="linenos"> 739</span></a><span class="sd">        **Optional arguments:**</span>
</span><span id="L-740"><a href="#L-740"><span class="linenos"> 740</span></a><span class="sd">        </span>
</span><span id="L-741"><a href="#L-741"><span class="linenos"> 741</span></a><span class="sd">        *mask_ds*</span>
</span><span id="L-742"><a href="#L-742"><span class="linenos"> 742</span></a><span class="sd">        </span>
</span><span id="L-743"><a href="#L-743"><span class="linenos"> 743</span></a><span class="sd">        An xarray boolean Dataset of arbitrary dimensions which provides the initial mask dataset. If *mask_ds*=None  and *analyser*=None, then *mask_ds* will be initialised as a Dataset of the same dimensions and data_vars as *val_ds*, with all values = 1 (i.e. initially unmasked). </span>
</span><span id="L-744"><a href="#L-744"><span class="linenos"> 744</span></a><span class="sd">        </span>
</span><span id="L-745"><a href="#L-745"><span class="linenos"> 745</span></a><span class="sd">        *val_ds*</span>
</span><span id="L-746"><a href="#L-746"><span class="linenos"> 746</span></a><span class="sd">        </span>
</span><span id="L-747"><a href="#L-747"><span class="linenos"> 747</span></a><span class="sd">        An xarray Dataset with the same dimensions as *mask_ds* if provided, otherwise arbitrary, consisting of an underlying dataset to which the mask is applied. If *val_ds*=None and *analyser*=None, then *PatternFilter.apply_value_mask* will raise an Error</span>
</span><span id="L-748"><a href="#L-748"><span class="linenos"> 748</span></a><span class="sd">            </span>
</span><span id="L-749"><a href="#L-749"><span class="linenos"> 749</span></a><span class="sd">        *analyser*</span>
</span><span id="L-750"><a href="#L-750"><span class="linenos"> 750</span></a><span class="sd">        </span>
</span><span id="L-751"><a href="#L-751"><span class="linenos"> 751</span></a><span class="sd">        An instance of a  core.LaggedAnalyser class for which both composites and significance masks have been computed, used to infer the *val_ds* and *mask_ds* arguments respectively. This overrides any values passed explicitly to  *mask_ds* and *val_ds*.</span>
</span><span id="L-752"><a href="#L-752"><span class="linenos"> 752</span></a><span class="sd">            </span>
</span><span id="L-753"><a href="#L-753"><span class="linenos"> 753</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="L-754"><a href="#L-754"><span class="linenos"> 754</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mask_ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">val_ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">analyser</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="L-755"><a href="#L-755"><span class="linenos"> 755</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise a new PatternFilter object&quot;&quot;&quot;</span>
</span><span id="L-756"><a href="#L-756"><span class="linenos"> 756</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">mask_ds</span>
</span><span id="L-757"><a href="#L-757"><span class="linenos"> 757</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-758"><a href="#L-758"><span class="linenos"> 758</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="o">=</span><span class="n">val_ds</span>
</span><span id="L-759"><a href="#L-759"><span class="linenos"> 759</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-760"><a href="#L-760"><span class="linenos"> 760</span></a>
</span><span id="L-761"><a href="#L-761"><span class="linenos"> 761</span></a>        <span class="k">if</span> <span class="n">analyser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-762"><a href="#L-762"><span class="linenos"> 762</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_analyser</span><span class="p">(</span><span class="n">analyser</span><span class="p">)</span>
</span><span id="L-763"><a href="#L-763"><span class="linenos"> 763</span></a>            
</span><span id="L-764"><a href="#L-764"><span class="linenos"> 764</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-765"><a href="#L-765"><span class="linenos"> 765</span></a>            <span class="k">if</span> <span class="n">mask_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-766"><a href="#L-766"><span class="linenos"> 766</span></a>                <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask_ds_like_val_ds</span><span class="p">()</span>
</span><span id="L-767"><a href="#L-767"><span class="linenos"> 767</span></a>                
</span><span id="L-768"><a href="#L-768"><span class="linenos"> 768</span></a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-769"><a href="#L-769"><span class="linenos"> 769</span></a>        <span class="k">return</span> <span class="s1">&#39;A PatternFilter object&#39;</span>
</span><span id="L-770"><a href="#L-770"><span class="linenos"> 770</span></a>        
</span><span id="L-771"><a href="#L-771"><span class="linenos"> 771</span></a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-772"><a href="#L-772"><span class="linenos"> 772</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span>
</span><span id="L-773"><a href="#L-773"><span class="linenos"> 773</span></a>        
</span><span id="L-774"><a href="#L-774"><span class="linenos"> 774</span></a>    <span class="k">def</span> <span class="nf">_parse_analyser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">analyser</span><span class="p">):</span>
</span><span id="L-775"><a href="#L-775"><span class="linenos"> 775</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">analyser</span><span class="o">.</span><span class="n">composite_sigs</span>
</span><span id="L-776"><a href="#L-776"><span class="linenos"> 776</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="o">=</span><span class="n">analyser</span><span class="o">.</span><span class="n">composites</span>
</span><span id="L-777"><a href="#L-777"><span class="linenos"> 777</span></a>        
</span><span id="L-778"><a href="#L-778"><span class="linenos"> 778</span></a>    <span class="k">def</span> <span class="nf">_mask_ds_like_val_ds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-779"><a href="#L-779"><span class="linenos"> 779</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-780"><a href="#L-780"><span class="linenos"> 780</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one of &quot;mask_ds&quot;, &quot;val_ds&quot; and &quot;analyser&quot; must be provided.&#39;</span><span class="p">))</span>
</span><span id="L-781"><a href="#L-781"><span class="linenos"> 781</span></a>        
</span><span id="L-782"><a href="#L-782"><span class="linenos"> 782</span></a>        <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span>
</span><span id="L-783"><a href="#L-783"><span class="linenos"> 783</span></a>        <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#replace nans and 0s with 1</span>
</span><span id="L-784"><a href="#L-784"><span class="linenos"> 784</span></a>        <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1">#make everything 1 via division and assert integer type.</span>
</span><span id="L-785"><a href="#L-785"><span class="linenos"> 785</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">y</span>
</span><span id="L-786"><a href="#L-786"><span class="linenos"> 786</span></a>        <span class="k">return</span>
</span><span id="L-787"><a href="#L-787"><span class="linenos"> 787</span></a>    
</span><span id="L-788"><a href="#L-788"><span class="linenos"> 788</span></a>    <span class="k">def</span> <span class="nf">update_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_mask</span><span class="p">,</span><span class="n">mode</span><span class="p">):</span>
</span><span id="L-789"><a href="#L-789"><span class="linenos"> 789</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Update *PatternFilter.mask_ds* with a new mask, either taking their union or intersection, or replacing the current mask with new_mask.</span>
</span><span id="L-790"><a href="#L-790"><span class="linenos"> 790</span></a><span class="sd">        </span>
</span><span id="L-791"><a href="#L-791"><span class="linenos"> 791</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-792"><a href="#L-792"><span class="linenos"> 792</span></a><span class="sd">        </span>
</span><span id="L-793"><a href="#L-793"><span class="linenos"> 793</span></a><span class="sd">        *new_mask*</span>
</span><span id="L-794"><a href="#L-794"><span class="linenos"> 794</span></a>
</span><span id="L-795"><a href="#L-795"><span class="linenos"> 795</span></a><span class="sd">        An xarray.Dataset with the same coords and variables as *PatternFilter.mask_ds*.</span>
</span><span id="L-796"><a href="#L-796"><span class="linenos"> 796</span></a>
</span><span id="L-797"><a href="#L-797"><span class="linenos"> 797</span></a><span class="sd">        *mode*</span>
</span><span id="L-798"><a href="#L-798"><span class="linenos"> 798</span></a>
</span><span id="L-799"><a href="#L-799"><span class="linenos"> 799</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how *new_mask* should be used to update the mask.</span>
</span><span id="L-800"><a href="#L-800"><span class="linenos"> 800</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-801"><a href="#L-801"><span class="linenos"> 801</span></a>        <span class="n">new_mask</span><span class="o">=</span><span class="n">new_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</span><span id="L-802"><a href="#L-802"><span class="linenos"> 802</span></a>        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;replace&#39;</span><span class="p">:</span>
</span><span id="L-803"><a href="#L-803"><span class="linenos"> 803</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">new_mask</span>
</span><span id="L-804"><a href="#L-804"><span class="linenos"> 804</span></a>        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;intersection&#39;</span><span class="p">:</span>
</span><span id="L-805"><a href="#L-805"><span class="linenos"> 805</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">*</span><span class="n">new_mask</span>
</span><span id="L-806"><a href="#L-806"><span class="linenos"> 806</span></a>        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;union&#39;</span><span class="p">:</span>
</span><span id="L-807"><a href="#L-807"><span class="linenos"> 807</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">|</span><span class="n">new_mask</span>
</span><span id="L-808"><a href="#L-808"><span class="linenos"> 808</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-809"><a href="#L-809"><span class="linenos"> 809</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid mode, </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span>
</span><span id="L-810"><a href="#L-810"><span class="linenos"> 810</span></a>        <span class="k">return</span>
</span><span id="L-811"><a href="#L-811"><span class="linenos"> 811</span></a>                  
</span><span id="L-812"><a href="#L-812"><span class="linenos"> 812</span></a>    <span class="k">def</span> <span class="nf">apply_value_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">truth_function</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">):</span>
</span><span id="L-813"><a href="#L-813"><span class="linenos"> 813</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply a filter to *PatternFilter.mask_ds* based on a user-specified truth function which is applied to *PatternFilter.val_ds. </span>
</span><span id="L-814"><a href="#L-814"><span class="linenos"> 814</span></a><span class="sd">        </span>
</span><span id="L-815"><a href="#L-815"><span class="linenos"> 815</span></a><span class="sd">        **Examples**</span>
</span><span id="L-816"><a href="#L-816"><span class="linenos"> 816</span></a><span class="sd">        </span>
</span><span id="L-817"><a href="#L-817"><span class="linenos"> 817</span></a><span class="sd">            #Mask values beneath a threshold:</span>
</span><span id="L-818"><a href="#L-818"><span class="linenos"> 818</span></a><span class="sd">            def larger_than_thresh(ds,thresh):</span>
</span><span id="L-819"><a href="#L-819"><span class="linenos"> 819</span></a><span class="sd">                return ds&gt;thresh</span>
</span><span id="L-820"><a href="#L-820"><span class="linenos"> 820</span></a><span class="sd">            patternfilter.apply_value_mask(is_positive,thresh)</span>
</span><span id="L-821"><a href="#L-821"><span class="linenos"> 821</span></a>
</span><span id="L-822"><a href="#L-822"><span class="linenos"> 822</span></a><span class="sd">            #Mask values where absolute value is less than a reference field:</span>
</span><span id="L-823"><a href="#L-823"><span class="linenos"> 823</span></a><span class="sd">            def amp_greater_than_reference(ds,ref_ds):</span>
</span><span id="L-824"><a href="#L-824"><span class="linenos"> 824</span></a><span class="sd">                return np.abs(ds)&gt;ref_ds</span>
</span><span id="L-825"><a href="#L-825"><span class="linenos"> 825</span></a><span class="sd">            pattern_filter.apply_value_mask(amp_greater_than_reference,ref_ds)</span>
</span><span id="L-826"><a href="#L-826"><span class="linenos"> 826</span></a>
</span><span id="L-827"><a href="#L-827"><span class="linenos"> 827</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-828"><a href="#L-828"><span class="linenos"> 828</span></a>
</span><span id="L-829"><a href="#L-829"><span class="linenos"> 829</span></a><span class="sd">        *truth_function*</span>
</span><span id="L-830"><a href="#L-830"><span class="linenos"> 830</span></a><span class="sd">        </span>
</span><span id="L-831"><a href="#L-831"><span class="linenos"> 831</span></a><span class="sd">        A function with inputs (val_ds,*args) that returns a boolean dataset with the same coords and data variables as *PatternFilter.val_ds*.</span>
</span><span id="L-832"><a href="#L-832"><span class="linenos"> 832</span></a>
</span><span id="L-833"><a href="#L-833"><span class="linenos"> 833</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-834"><a href="#L-834"><span class="linenos"> 834</span></a><span class="sd">        </span>
</span><span id="L-835"><a href="#L-835"><span class="linenos"> 835</span></a><span class="sd">        *mode*</span>
</span><span id="L-836"><a href="#L-836"><span class="linenos"> 836</span></a><span class="sd">            </span>
</span><span id="L-837"><a href="#L-837"><span class="linenos"> 837</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how the value filter should be used to update the *PatternFilter.mask_ds*.</span>
</span><span id="L-838"><a href="#L-838"><span class="linenos"> 838</span></a><span class="sd">        &quot;&quot;&quot;</span>        
</span><span id="L-839"><a href="#L-839"><span class="linenos"> 839</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-840"><a href="#L-840"><span class="linenos"> 840</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;val_ds must be provided to apply value mask.&#39;</span><span class="p">))</span>
</span><span id="L-841"><a href="#L-841"><span class="linenos"> 841</span></a>        <span class="n">value_mask</span><span class="o">=</span><span class="n">truth_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span id="L-842"><a href="#L-842"><span class="linenos"> 842</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">update_mask</span><span class="p">(</span><span class="n">value_mask</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="L-843"><a href="#L-843"><span class="linenos"> 843</span></a>        <span class="k">return</span>
</span><span id="L-844"><a href="#L-844"><span class="linenos"> 844</span></a>    
</span><span id="L-845"><a href="#L-845"><span class="linenos"> 845</span></a>    <span class="k">def</span> <span class="nf">apply_area_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">,</span><span class="n">area_type</span><span class="o">=</span><span class="s1">&#39;gridpoint&#39;</span><span class="p">):</span>
</span><span id="L-846"><a href="#L-846"><span class="linenos"> 846</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply a filter to *PatternFilter.mask_ds* that identifies connected groups of True values within a subspace of the Dataset&#39;s dimensions specified by *dims*, and masks out groups which are beneath a threshold size *n*. This is done through the application of *scipy.ndimage.label* using the default structuring element (https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.label.html). </span>
</span><span id="L-847"><a href="#L-847"><span class="linenos"> 847</span></a><span class="sd">    </span>
</span><span id="L-848"><a href="#L-848"><span class="linenos"> 848</span></a><span class="sd">        When *area_type*=&#39;gridpoint&#39;, *n* specifies the number of connected datapoints within each connected region. For the special case where *dims* consists of a latitude- and longitude-like coordinate, area_type=&#39;spherical&#39; applies a cosine-latitude weighting, such that *n* can be interpreted as a measure of area, where a datapoint with lat=0 would have area 1. </span>
</span><span id="L-849"><a href="#L-849"><span class="linenos"> 849</span></a><span class="sd">        </span>
</span><span id="L-850"><a href="#L-850"><span class="linenos"> 850</span></a><span class="sd">        **Examples**</span>
</span><span id="L-851"><a href="#L-851"><span class="linenos"> 851</span></a><span class="sd">        </span>
</span><span id="L-852"><a href="#L-852"><span class="linenos"> 852</span></a><span class="sd">            #Keep groups of True values consisting of an area &gt;=30 square equatorial gridpoints</span>
</span><span id="L-853"><a href="#L-853"><span class="linenos"> 853</span></a><span class="sd">            patternfilter.apply_area_mask(30,dims=(&#39;lat&#39;,&#39;lon&#39;),area_type=&#39;spherical&#39;)</span>
</span><span id="L-854"><a href="#L-854"><span class="linenos"> 854</span></a><span class="sd">            </span>
</span><span id="L-855"><a href="#L-855"><span class="linenos"> 855</span></a><span class="sd">            #Keep groups of True values that are consistent for at least 3 neighbouring time lags</span>
</span><span id="L-856"><a href="#L-856"><span class="linenos"> 856</span></a><span class="sd">            patternfilter.apply_area_mask(3,dims=(&#39;time&#39;))</span>
</span><span id="L-857"><a href="#L-857"><span class="linenos"> 857</span></a><span class="sd">            </span>
</span><span id="L-858"><a href="#L-858"><span class="linenos"> 858</span></a><span class="sd">            #Keep groups of true values consisting of &gt;=10 longitudinal values, or &gt;=30 values in longitude and altitude if the variables have an altitude coord:</span>
</span><span id="L-859"><a href="#L-859"><span class="linenos"> 859</span></a><span class="sd">            patternfilter.apply_area_mask(10,dims=(&#39;longitude&#39;))</span>
</span><span id="L-860"><a href="#L-860"><span class="linenos"> 860</span></a><span class="sd">            patternfilter.apply_area_mask(30,dims=(&#39;longitude,altitude&#39;),mode=&#39;union&#39;)</span>
</span><span id="L-861"><a href="#L-861"><span class="linenos"> 861</span></a>
</span><span id="L-862"><a href="#L-862"><span class="linenos"> 862</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-863"><a href="#L-863"><span class="linenos"> 863</span></a>
</span><span id="L-864"><a href="#L-864"><span class="linenos"> 864</span></a><span class="sd">        *n*</span>
</span><span id="L-865"><a href="#L-865"><span class="linenos"> 865</span></a><span class="sd">            </span>
</span><span id="L-866"><a href="#L-866"><span class="linenos"> 866</span></a><span class="sd">        A scalar indicating the minimum size of an unmasked group, in terms of number of gridpoints (for *area_type*=gridpoint) or the weighted area (for *area_type*=spherical), beneath which the group will be masked.</span>
</span><span id="L-867"><a href="#L-867"><span class="linenos"> 867</span></a>
</span><span id="L-868"><a href="#L-868"><span class="linenos"> 868</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-869"><a href="#L-869"><span class="linenos"> 869</span></a><span class="sd">        </span>
</span><span id="L-870"><a href="#L-870"><span class="linenos"> 870</span></a><span class="sd">        *dims*</span>
</span><span id="L-871"><a href="#L-871"><span class="linenos"> 871</span></a><span class="sd">            </span>
</span><span id="L-872"><a href="#L-872"><span class="linenos"> 872</span></a><span class="sd">        An iterable of strings specifying coords in *PatternFilter.mask_ds* which define the subspace in which groups of connected True values are identified. Other dims will be iterated over. DataArrays within *PatternFilter.mask_ds* that do not contain all the *dims* will be ignored. If *dims*=None, all dims in each DataArray will be used.</span>
</span><span id="L-873"><a href="#L-873"><span class="linenos"> 873</span></a><span class="sd">            </span>
</span><span id="L-874"><a href="#L-874"><span class="linenos"> 874</span></a><span class="sd">        *mode*</span>
</span><span id="L-875"><a href="#L-875"><span class="linenos"> 875</span></a>
</span><span id="L-876"><a href="#L-876"><span class="linenos"> 876</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how the area filter should be used to update the *PatternFilter.mask_ds*.</span>
</span><span id="L-877"><a href="#L-877"><span class="linenos"> 877</span></a><span class="sd">            </span>
</span><span id="L-878"><a href="#L-878"><span class="linenos"> 878</span></a><span class="sd">        *area_type*</span>
</span><span id="L-879"><a href="#L-879"><span class="linenos"> 879</span></a>
</span><span id="L-880"><a href="#L-880"><span class="linenos"> 880</span></a><span class="sd">        A string, one of &#39;gridpoint&#39; or &#39;spherical&#39; as specified above. &#39;spherical&#39; is currently only supported for len-2 *dims* kwargs, with the first assumed to be latitude-like. </span>
</span><span id="L-881"><a href="#L-881"><span class="linenos"> 881</span></a><span class="sd">            </span>
</span><span id="L-882"><a href="#L-882"><span class="linenos"> 882</span></a><span class="sd">        &quot;&quot;&quot;</span>        
</span><span id="L-883"><a href="#L-883"><span class="linenos"> 883</span></a>        <span class="k">if</span> <span class="n">area_type</span><span class="o">==</span><span class="s1">&#39;gridpoint&#39;</span><span class="p">:</span>
</span><span id="L-884"><a href="#L-884"><span class="linenos"> 884</span></a>            <span class="n">area_based</span><span class="o">=</span><span class="kc">False</span>
</span><span id="L-885"><a href="#L-885"><span class="linenos"> 885</span></a>        <span class="k">elif</span> <span class="n">area_type</span><span class="o">==</span><span class="s1">&#39;spherical&#39;</span><span class="p">:</span>
</span><span id="L-886"><a href="#L-886"><span class="linenos"> 886</span></a>            <span class="n">area_based</span><span class="o">=</span><span class="kc">True</span>
</span><span id="L-887"><a href="#L-887"><span class="linenos"> 887</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-888"><a href="#L-888"><span class="linenos"> 888</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown area_type </span><span class="si">{</span><span class="n">area_type</span><span class="si">}</span><span class="s2">. Valid options are &#39;gridpoint&#39; and &#39;spherical&#39;&quot;</span><span class="p">))</span>
</span><span id="L-889"><a href="#L-889"><span class="linenos"> 889</span></a>        <span class="n">area_mask</span><span class="o">=</span><span class="n">ds_large_regions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span><span class="n">area_based</span><span class="o">=</span><span class="n">area_based</span><span class="p">)</span>
</span><span id="L-890"><a href="#L-890"><span class="linenos"> 890</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">update_mask</span><span class="p">(</span><span class="n">area_mask</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="L-891"><a href="#L-891"><span class="linenos"> 891</span></a>        <span class="k">return</span>
</span><span id="L-892"><a href="#L-892"><span class="linenos"> 892</span></a>    
</span><span id="L-893"><a href="#L-893"><span class="linenos"> 893</span></a>    
</span><span id="L-894"><a href="#L-894"><span class="linenos"> 894</span></a>    <span class="k">def</span> <span class="nf">apply_convolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">):</span>
</span><span id="L-895"><a href="#L-895"><span class="linenos"> 895</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply a square n-point convolution filter to *PatternFilter.mask_ds* in one or two dimensions specified by *dims*, iterated over remaining dimensions. This has the effect of extending the unmasked regions and smoothing the mask overall.</span>
</span><span id="L-896"><a href="#L-896"><span class="linenos"> 896</span></a><span class="sd">        </span>
</span><span id="L-897"><a href="#L-897"><span class="linenos"> 897</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-898"><a href="#L-898"><span class="linenos"> 898</span></a><span class="sd">        </span>
</span><span id="L-899"><a href="#L-899"><span class="linenos"> 899</span></a><span class="sd">        *n*</span>
</span><span id="L-900"><a href="#L-900"><span class="linenos"> 900</span></a><span class="sd">            </span>
</span><span id="L-901"><a href="#L-901"><span class="linenos"> 901</span></a><span class="sd">        A positive integer specifying the size of the convolution filter. *n*=1 leaves the mask unchanged. Even *n* are asymmetric and shifted right. </span>
</span><span id="L-902"><a href="#L-902"><span class="linenos"> 902</span></a>
</span><span id="L-903"><a href="#L-903"><span class="linenos"> 903</span></a><span class="sd">        *dims*</span>
</span><span id="L-904"><a href="#L-904"><span class="linenos"> 904</span></a>
</span><span id="L-905"><a href="#L-905"><span class="linenos"> 905</span></a><span class="sd">        A length 1 or 2 iterable of strings specifying the dims in which the convolution is applied. Other dims will be iterated over. DataArrays within *PatternFilter.mask_ds* that do not contain all the *dims* will be ignored. </span>
</span><span id="L-906"><a href="#L-906"><span class="linenos"> 906</span></a>
</span><span id="L-907"><a href="#L-907"><span class="linenos"> 907</span></a><span class="sd">        *mode*</span>
</span><span id="L-908"><a href="#L-908"><span class="linenos"> 908</span></a>
</span><span id="L-909"><a href="#L-909"><span class="linenos"> 909</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how the area filter should be used to update the *PatternFilter.mask_ds*.</span>
</span><span id="L-910"><a href="#L-910"><span class="linenos"> 910</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-911"><a href="#L-911"><span class="linenos"> 911</span></a>        
</span><span id="L-912"><a href="#L-912"><span class="linenos"> 912</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
</span><span id="L-913"><a href="#L-913"><span class="linenos"> 913</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only 1 and 2D dims currently supported&#39;</span><span class="p">))</span>
</span><span id="L-914"><a href="#L-914"><span class="linenos"> 914</span></a>            
</span><span id="L-915"><a href="#L-915"><span class="linenos"> 915</span></a>        <span class="n">convolution</span><span class="o">=</span><span class="n">convolve_pad_ds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
</span><span id="L-916"><a href="#L-916"><span class="linenos"> 916</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">update_mask</span><span class="p">(</span><span class="n">convolution</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="L-917"><a href="#L-917"><span class="linenos"> 917</span></a>        <span class="k">return</span>
</span><span id="L-918"><a href="#L-918"><span class="linenos"> 918</span></a>    
</span><span id="L-919"><a href="#L-919"><span class="linenos"> 919</span></a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-920"><a href="#L-920"><span class="linenos"> 920</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot; Retrieve the mask with all filters applied.</span>
</span><span id="L-921"><a href="#L-921"><span class="linenos"> 921</span></a><span class="sd">        **Returns**</span>
</span><span id="L-922"><a href="#L-922"><span class="linenos"> 922</span></a><span class="sd">        An xarray.Dataset of boolean values.</span>
</span><span id="L-923"><a href="#L-923"><span class="linenos"> 923</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-924"><a href="#L-924"><span class="linenos"> 924</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span>
</span><span id="L-925"><a href="#L-925"><span class="linenos"> 925</span></a>    
</span><span id="L-926"><a href="#L-926"><span class="linenos"> 926</span></a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">drop_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">fill_val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
</span><span id="L-927"><a href="#L-927"><span class="linenos"> 927</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply the current mask to *ds* or to *PatternFilter.val_ds* (if *ds* is None), replacing masked gridpoints with *fill_val*.</span>
</span><span id="L-928"><a href="#L-928"><span class="linenos"> 928</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-929"><a href="#L-929"><span class="linenos"> 929</span></a><span class="sd">        </span>
</span><span id="L-930"><a href="#L-930"><span class="linenos"> 930</span></a><span class="sd">        *ds*</span>
</span><span id="L-931"><a href="#L-931"><span class="linenos"> 931</span></a><span class="sd">        </span>
</span><span id="L-932"><a href="#L-932"><span class="linenos"> 932</span></a><span class="sd">        An xarray.Dataset to apply the mask to. Should have the same coords and data_vars as *PatternFilter.mask_ds*. If None, the mask is applied to *PatternFilter.val_ds*.</span>
</span><span id="L-933"><a href="#L-933"><span class="linenos"> 933</span></a><span class="sd">        </span>
</span><span id="L-934"><a href="#L-934"><span class="linenos"> 934</span></a><span class="sd">        *drop_empty*</span>
</span><span id="L-935"><a href="#L-935"><span class="linenos"> 935</span></a><span class="sd">        </span>
</span><span id="L-936"><a href="#L-936"><span class="linenos"> 936</span></a><span class="sd">        A boolean value. If True, then completely masked variables are dropped from the returned masked Dataset.</span>
</span><span id="L-937"><a href="#L-937"><span class="linenos"> 937</span></a><span class="sd">        </span>
</span><span id="L-938"><a href="#L-938"><span class="linenos"> 938</span></a><span class="sd">        *fill_val*</span>
</span><span id="L-939"><a href="#L-939"><span class="linenos"> 939</span></a><span class="sd">        </span>
</span><span id="L-940"><a href="#L-940"><span class="linenos"> 940</span></a><span class="sd">        A scalar that defaults to np.nan. The value with which masked gridpoints in the Dataset are replaced.</span>
</span><span id="L-941"><a href="#L-941"><span class="linenos"> 941</span></a><span class="sd">        </span>
</span><span id="L-942"><a href="#L-942"><span class="linenos"> 942</span></a><span class="sd">        **Returns**</span>
</span><span id="L-943"><a href="#L-943"><span class="linenos"> 943</span></a><span class="sd">        </span>
</span><span id="L-944"><a href="#L-944"><span class="linenos"> 944</span></a><span class="sd">        A Dataset with masked values replaced by *fill_val*.</span>
</span><span id="L-945"><a href="#L-945"><span class="linenos"> 945</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-946"><a href="#L-946"><span class="linenos"> 946</span></a>        <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-947"><a href="#L-947"><span class="linenos"> 947</span></a>            <span class="n">ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="L-948"><a href="#L-948"><span class="linenos"> 948</span></a>            
</span><span id="L-949"><a href="#L-949"><span class="linenos"> 949</span></a>        <span class="n">ds</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="p">)</span>
</span><span id="L-950"><a href="#L-950"><span class="linenos"> 950</span></a>        <span class="k">if</span> <span class="n">drop_empty</span><span class="p">:</span>
</span><span id="L-951"><a href="#L-951"><span class="linenos"> 951</span></a>            <span class="n">drop_vars</span><span class="o">=</span><span class="p">((</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="s1">&#39;vars&#39;</span><span class="p">)</span>
</span><span id="L-952"><a href="#L-952"><span class="linenos"> 952</span></a>            <span class="n">ds</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">drop_vars</span><span class="p">[</span><span class="n">drop_vars</span><span class="p">]</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</span><span id="L-953"><a href="#L-953"><span class="linenos"> 953</span></a>        <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_val</span><span class="p">)</span>
</span><span id="L-954"><a href="#L-954"><span class="linenos"> 954</span></a>    
</span><span id="L-955"><a href="#L-955"><span class="linenos"> 955</span></a><span class="k">def</span> <span class="nf">_DEFAULT_RENAME_FUNC</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">d</span><span class="p">):</span>
</span><span id="L-956"><a href="#L-956"><span class="linenos"> 956</span></a>    
</span><span id="L-957"><a href="#L-957"><span class="linenos"> 957</span></a>    <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span><span id="L-958"><a href="#L-958"><span class="linenos"> 958</span></a>        <span class="n">v</span><span class="o">=</span><span class="n">v</span><span class="o">+</span><span class="sa">f</span><span class="s1">&#39;_</span><span class="si">{</span><span class="n">k</span><span class="si">}{</span><span class="n">x</span><span class="si">}</span><span class="s1">&#39;</span>
</span><span id="L-959"><a href="#L-959"><span class="linenos"> 959</span></a>    <span class="k">return</span> <span class="n">v</span>
</span><span id="L-960"><a href="#L-960"><span class="linenos"> 960</span></a>    
</span><span id="L-961"><a href="#L-961"><span class="linenos"> 961</span></a><span class="k">def</span> <span class="nf">_Dataset_to_dict</span><span class="p">(</span><span class="n">ds</span><span class="p">):</span>
</span><span id="L-962"><a href="#L-962"><span class="linenos"> 962</span></a>    <span class="k">return</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()[</span><span class="s1">&#39;data_vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
</span><span id="L-963"><a href="#L-963"><span class="linenos"> 963</span></a>
</span><span id="L-964"><a href="#L-964"><span class="linenos"> 964</span></a><span class="k">class</span> <span class="nc">IndexGenerator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span id="L-965"><a href="#L-965"><span class="linenos"> 965</span></a><span class="w">    </span>
</span><span id="L-966"><a href="#L-966"><span class="linenos"> 966</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot; Computes dot-products between a Dataset of patterns and a Dataset of variables, reducing them to standardised scalar indices.</span>
</span><span id="L-967"><a href="#L-967"><span class="linenos"> 967</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="L-968"><a href="#L-968"><span class="linenos"> 968</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-969"><a href="#L-969"><span class="linenos"> 969</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_means</span><span class="o">=</span><span class="p">[]</span>
</span><span id="L-970"><a href="#L-970"><span class="linenos"> 970</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_stds</span><span class="o">=</span><span class="p">[]</span>
</span><span id="L-971"><a href="#L-971"><span class="linenos"> 971</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_rename_function</span><span class="o">=</span><span class="n">_DEFAULT_RENAME_FUNC</span>
</span><span id="L-972"><a href="#L-972"><span class="linenos"> 972</span></a>        
</span><span id="L-973"><a href="#L-973"><span class="linenos"> 973</span></a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-974"><a href="#L-974"><span class="linenos"> 974</span></a>        <span class="k">return</span> <span class="s1">&#39;An IndexGenerator object&#39;</span>
</span><span id="L-975"><a href="#L-975"><span class="linenos"> 975</span></a>        
</span><span id="L-976"><a href="#L-976"><span class="linenos"> 976</span></a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="L-977"><a href="#L-977"><span class="linenos"> 977</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span>
</span><span id="L-978"><a href="#L-978"><span class="linenos"> 978</span></a>    
</span><span id="L-979"><a href="#L-979"><span class="linenos"> 979</span></a>    
</span><span id="L-980"><a href="#L-980"><span class="linenos"> 980</span></a>    <span class="k">def</span> <span class="nf">centre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="L-981"><a href="#L-981"><span class="linenos"> 981</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-982"><a href="#L-982"><span class="linenos"> 982</span></a>
</span><span id="L-983"><a href="#L-983"><span class="linenos"> 983</span></a>        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-984"><a href="#L-984"><span class="linenos"> 984</span></a>            <span class="n">ref</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
</span><span id="L-985"><a href="#L-985"><span class="linenos"> 985</span></a>        <span class="k">return</span> <span class="n">x</span><span class="o">-</span><span class="n">ref</span>
</span><span id="L-986"><a href="#L-986"><span class="linenos"> 986</span></a>    
</span><span id="L-987"><a href="#L-987"><span class="linenos"> 987</span></a>    <span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="L-988"><a href="#L-988"><span class="linenos"> 988</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-989"><a href="#L-989"><span class="linenos"> 989</span></a>
</span><span id="L-990"><a href="#L-990"><span class="linenos"> 990</span></a>        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-991"><a href="#L-991"><span class="linenos"> 991</span></a>            <span class="n">ref</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
</span><span id="L-992"><a href="#L-992"><span class="linenos"> 992</span></a>        <span class="k">return</span> <span class="n">x</span><span class="o">/</span><span class="n">ref</span>
</span><span id="L-993"><a href="#L-993"><span class="linenos"> 993</span></a>    
</span><span id="L-994"><a href="#L-994"><span class="linenos"> 994</span></a>    <span class="k">def</span> <span class="nf">standardise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">mean_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">std_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="L-995"><a href="#L-995"><span class="linenos"> 995</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-996"><a href="#L-996"><span class="linenos"> 996</span></a>        <span class="n">centred_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centre</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">mean_ref</span><span class="p">)</span>
</span><span id="L-997"><a href="#L-997"><span class="linenos"> 997</span></a>        <span class="n">standardised_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="n">centred_x</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">std_ref</span><span class="p">)</span>
</span><span id="L-998"><a href="#L-998"><span class="linenos"> 998</span></a>        <span class="k">return</span> <span class="n">standardised_x</span>
</span><span id="L-999"><a href="#L-999"><span class="linenos"> 999</span></a>        
</span><span id="L-1000"><a href="#L-1000"><span class="linenos">1000</span></a>    <span class="k">def</span> <span class="nf">collapse_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dims</span><span class="p">):</span>
</span><span id="L-1001"><a href="#L-1001"><span class="linenos">1001</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="L-1002"><a href="#L-1002"><span class="linenos">1002</span></a>        <span class="n">lat_coords</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span><span class="s1">&#39;grid_latitude&#39;</span><span class="p">]</span>
</span><span id="L-1003"><a href="#L-1003"><span class="linenos">1003</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">lat_coords</span><span class="p">,</span><span class="n">dims</span><span class="p">)):</span>
</span><span id="L-1004"><a href="#L-1004"><span class="linenos">1004</span></a>            <span class="k">return</span> <span class="n">ix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
</span><span id="L-1005"><a href="#L-1005"><span class="linenos">1005</span></a>        
</span><span id="L-1006"><a href="#L-1006"><span class="linenos">1006</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-1007"><a href="#L-1007"><span class="linenos">1007</span></a>            <span class="c1">#assumes only one lat coord: seems safe.</span>
</span><span id="L-1008"><a href="#L-1008"><span class="linenos">1008</span></a>            <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_coords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">lat_coords</span><span class="p">,</span><span class="n">dims</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
</span><span id="L-1009"><a href="#L-1009"><span class="linenos">1009</span></a>            <span class="n">weights</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">]))</span>
</span><span id="L-1010"><a href="#L-1010"><span class="linenos">1010</span></a>            <span class="k">return</span> <span class="n">ix</span><span class="o">.</span><span class="n">weighted</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
</span><span id="L-1011"><a href="#L-1011"><span class="linenos">1011</span></a>            
</span><span id="L-1012"><a href="#L-1012"><span class="linenos">1012</span></a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">slices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ix_means</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ix_stds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">drop_blank</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">strict_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-1013"><a href="#L-1013"><span class="linenos">1013</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute standardised indices from an xarray.Dataset of patterns and an xarray.Dataset of arbitrary dimension variables.</span>
</span><span id="L-1014"><a href="#L-1014"><span class="linenos">1014</span></a><span class="sd">        </span>
</span><span id="L-1015"><a href="#L-1015"><span class="linenos">1015</span></a><span class="sd">        **Arguments**</span>
</span><span id="L-1016"><a href="#L-1016"><span class="linenos">1016</span></a><span class="sd">        </span>
</span><span id="L-1017"><a href="#L-1017"><span class="linenos">1017</span></a><span class="sd">        *pattern_ds*</span>
</span><span id="L-1018"><a href="#L-1018"><span class="linenos">1018</span></a><span class="sd">        </span>
</span><span id="L-1019"><a href="#L-1019"><span class="linenos">1019</span></a><span class="sd">        An xarray.Dataset of patterns to project onto with arbitrary dimensions.</span>
</span><span id="L-1020"><a href="#L-1020"><span class="linenos">1020</span></a><span class="sd">        </span>
</span><span id="L-1021"><a href="#L-1021"><span class="linenos">1021</span></a><span class="sd">        *series_ds*</span>
</span><span id="L-1022"><a href="#L-1022"><span class="linenos">1022</span></a><span class="sd">        </span>
</span><span id="L-1023"><a href="#L-1023"><span class="linenos">1023</span></a><span class="sd">        An xarray.Dataset of variables to project onto the patterns. Coordinates of *series_ds* once subsetted using *slices* must match the dimensions of *pattern_ds* + the extra coord *dim*.</span>
</span><span id="L-1024"><a href="#L-1024"><span class="linenos">1024</span></a><span class="sd">        </span>
</span><span id="L-1025"><a href="#L-1025"><span class="linenos">1025</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="L-1026"><a href="#L-1026"><span class="linenos">1026</span></a><span class="sd">        </span>
</span><span id="L-1027"><a href="#L-1027"><span class="linenos">1027</span></a><span class="sd">        *dim*:</span>
</span><span id="L-1028"><a href="#L-1028"><span class="linenos">1028</span></a><span class="sd">        </span>
</span><span id="L-1029"><a href="#L-1029"><span class="linenos">1029</span></a><span class="sd">        A string specifying the remaining coord of the scalar indices. Defaults to &#39;time&#39;, which should be the choice for most use cases.</span>
</span><span id="L-1030"><a href="#L-1030"><span class="linenos">1030</span></a><span class="sd">        </span>
</span><span id="L-1031"><a href="#L-1031"><span class="linenos">1031</span></a><span class="sd">        *slices*</span>
</span><span id="L-1032"><a href="#L-1032"><span class="linenos">1032</span></a><span class="sd">        </span>
</span><span id="L-1033"><a href="#L-1033"><span class="linenos">1033</span></a><span class="sd">        A dictionary or iterable of dictionaries, each specifying a subset of *pattern_ds* to take before computing an index, with one index returned for each dictionary and for each variable. Subsetting is based on the *xr.Dataset.sel* method: e.g. *slices*=[dict(lag=0,index_val=1)] will produce 1 set of indices based on pattern_ds.sel(lag=0,index_val=1). If *slices*=None, no subsets are computed.</span>
</span><span id="L-1034"><a href="#L-1034"><span class="linenos">1034</span></a><span class="sd">        </span>
</span><span id="L-1035"><a href="#L-1035"><span class="linenos">1035</span></a><span class="sd">        *ix_means*</span>
</span><span id="L-1036"><a href="#L-1036"><span class="linenos">1036</span></a><span class="sd">        </span>
</span><span id="L-1037"><a href="#L-1037"><span class="linenos">1037</span></a><span class="sd">        If None, the mean of each index is calculated and subtracted, resulting in centred indices. Otherwise, *ix_means* should be a dictionary of index names and predefined mean values which are subtracted instead. Of most use for online computations, updating a precomputed index in a new dataset.</span>
</span><span id="L-1038"><a href="#L-1038"><span class="linenos">1038</span></a><span class="sd">        </span>
</span><span id="L-1039"><a href="#L-1039"><span class="linenos">1039</span></a><span class="sd">        *ix_stds*</span>
</span><span id="L-1040"><a href="#L-1040"><span class="linenos">1040</span></a><span class="sd">        </span>
</span><span id="L-1041"><a href="#L-1041"><span class="linenos">1041</span></a><span class="sd">        If None, the standard deviation of each index is calculated and is divided by, resulting in standardised indices. Otherwise, *ix_stds* should be a dictionary of index names and predefined std values which are divided by instead. Of most use for online computations, updating a precomputed index in a new dataset.</span>
</span><span id="L-1042"><a href="#L-1042"><span class="linenos">1042</span></a>
</span><span id="L-1043"><a href="#L-1043"><span class="linenos">1043</span></a><span class="sd">        *drop_blank*</span>
</span><span id="L-1044"><a href="#L-1044"><span class="linenos">1044</span></a><span class="sd">        </span>
</span><span id="L-1045"><a href="#L-1045"><span class="linenos">1045</span></a><span class="sd">        A boolean. If True, drop indices where the corresponding pattern is entirely blank. If False, returns an all np.nan time series.</span>
</span><span id="L-1046"><a href="#L-1046"><span class="linenos">1046</span></a><span class="sd">        *in_place*</span>
</span><span id="L-1047"><a href="#L-1047"><span class="linenos">1047</span></a><span class="sd">        </span>
</span><span id="L-1048"><a href="#L-1048"><span class="linenos">1048</span></a><span class="sd">        *strict_metadata*</span>
</span><span id="L-1049"><a href="#L-1049"><span class="linenos">1049</span></a><span class="sd">        </span>
</span><span id="L-1050"><a href="#L-1050"><span class="linenos">1050</span></a><span class="sd">        If False, indices will be merged into a common dataset regardless of metadata. If True, nonmatching metadata will raise a ValueError.</span>
</span><span id="L-1051"><a href="#L-1051"><span class="linenos">1051</span></a><span class="sd">        </span>
</span><span id="L-1052"><a href="#L-1052"><span class="linenos">1052</span></a><span class="sd">        **Returns</span>
</span><span id="L-1053"><a href="#L-1053"><span class="linenos">1053</span></a><span class="sd">        </span>
</span><span id="L-1054"><a href="#L-1054"><span class="linenos">1054</span></a><span class="sd">        An xarray.Dataset of indices with a single coordinate (*dim*).</span>
</span><span id="L-1055"><a href="#L-1055"><span class="linenos">1055</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-1056"><a href="#L-1056"><span class="linenos">1056</span></a>        <span class="c1">#Parse inputs</span>
</span><span id="L-1057"><a href="#L-1057"><span class="linenos">1057</span></a>        
</span><span id="L-1058"><a href="#L-1058"><span class="linenos">1058</span></a>        <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-1059"><a href="#L-1059"><span class="linenos">1059</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="o">=</span><span class="p">[{}]</span>
</span><span id="L-1060"><a href="#L-1060"><span class="linenos">1060</span></a>        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
</span><span id="L-1061"><a href="#L-1061"><span class="linenos">1061</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="o">=</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
</span><span id="L-1062"><a href="#L-1062"><span class="linenos">1062</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-1063"><a href="#L-1063"><span class="linenos">1063</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="o">=</span><span class="n">slices</span>
</span><span id="L-1064"><a href="#L-1064"><span class="linenos">1064</span></a>            
</span><span id="L-1065"><a href="#L-1065"><span class="linenos">1065</span></a>        <span class="k">if</span> <span class="n">ix_means</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ix_stds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="L-1066"><a href="#L-1066"><span class="linenos">1066</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">user_params</span><span class="o">=</span><span class="kc">True</span>
</span><span id="L-1067"><a href="#L-1067"><span class="linenos">1067</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">=</span><span class="n">ix_means</span>
</span><span id="L-1068"><a href="#L-1068"><span class="linenos">1068</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">=</span><span class="n">ix_stds</span>
</span><span id="L-1069"><a href="#L-1069"><span class="linenos">1069</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-1070"><a href="#L-1070"><span class="linenos">1070</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">user_params</span><span class="o">=</span><span class="kc">False</span>
</span><span id="L-1071"><a href="#L-1071"><span class="linenos">1071</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">=</span><span class="p">{}</span>
</span><span id="L-1072"><a href="#L-1072"><span class="linenos">1072</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">=</span><span class="p">{}</span>
</span><span id="L-1073"><a href="#L-1073"><span class="linenos">1073</span></a>            
</span><span id="L-1074"><a href="#L-1074"><span class="linenos">1074</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">=</span><span class="kc">None</span>
</span><span id="L-1075"><a href="#L-1075"><span class="linenos">1075</span></a>        
</span><span id="L-1076"><a href="#L-1076"><span class="linenos">1076</span></a>        <span class="c1">#Compute indices</span>
</span><span id="L-1077"><a href="#L-1077"><span class="linenos">1077</span></a>        <span class="n">indices</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_index</span><span class="p">(</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">sl</span><span class="p">)</span>\
</span><span id="L-1078"><a href="#L-1078"><span class="linenos">1078</span></a>                <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="p">]</span>
</span><span id="L-1079"><a href="#L-1079"><span class="linenos">1079</span></a>        <span class="k">try</span><span class="p">:</span>
</span><span id="L-1080"><a href="#L-1080"><span class="linenos">1080</span></a>            <span class="n">indices</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
</span><span id="L-1081"><a href="#L-1081"><span class="linenos">1081</span></a>        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span id="L-1082"><a href="#L-1082"><span class="linenos">1082</span></a>            <span class="k">if</span> <span class="n">strict_metadata</span><span class="p">:</span>
</span><span id="L-1083"><a href="#L-1083"><span class="linenos">1083</span></a>                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merge of indices failed. Consider &#39;strict_metadata=False&#39;&quot;</span><span class="p">)</span>
</span><span id="L-1084"><a href="#L-1084"><span class="linenos">1084</span></a>                <span class="k">raise</span> <span class="n">e</span>
</span><span id="L-1085"><a href="#L-1085"><span class="linenos">1085</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="L-1086"><a href="#L-1086"><span class="linenos">1086</span></a>                <span class="n">indices</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="n">compat</span><span class="o">=</span><span class="s1">&#39;override&#39;</span><span class="p">)</span>
</span><span id="L-1087"><a href="#L-1087"><span class="linenos">1087</span></a>            
</span><span id="L-1088"><a href="#L-1088"><span class="linenos">1088</span></a>        <span class="c1">#Optionally remove indices which are all nan    </span>
</span><span id="L-1089"><a href="#L-1089"><span class="linenos">1089</span></a>        <span class="k">if</span> <span class="n">drop_blank</span><span class="p">:</span>
</span><span id="L-1090"><a href="#L-1090"><span class="linenos">1090</span></a>            <span class="n">drop</span><span class="o">=</span><span class="p">(</span><span class="o">~</span><span class="n">indices</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span>
</span><span id="L-1091"><a href="#L-1091"><span class="linenos">1091</span></a>            <span class="n">drop</span><span class="o">=</span><span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="n">drop</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()[</span><span class="s1">&#39;data_vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]]</span>
</span><span id="L-1092"><a href="#L-1092"><span class="linenos">1092</span></a>            <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">drop</span><span class="p">)</span>
</span><span id="L-1093"><a href="#L-1093"><span class="linenos">1093</span></a>            <span class="n">_</span><span class="o">=</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">drop</span><span class="p">]</span>
</span><span id="L-1094"><a href="#L-1094"><span class="linenos">1094</span></a>        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
</span><span id="L-1095"><a href="#L-1095"><span class="linenos">1095</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span>
</span><span id="L-1096"><a href="#L-1096"><span class="linenos">1096</span></a>        <span class="k">return</span> <span class="n">indices</span>
</span><span id="L-1097"><a href="#L-1097"><span class="linenos">1097</span></a>    
</span><span id="L-1098"><a href="#L-1098"><span class="linenos">1098</span></a>    <span class="k">def</span> <span class="nf">_generate_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">sl</span><span class="p">):</span>
</span><span id="L-1099"><a href="#L-1099"><span class="linenos">1099</span></a>                
</span><span id="L-1100"><a href="#L-1100"><span class="linenos">1100</span></a>        <span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">)</span>
</span><span id="L-1101"><a href="#L-1101"><span class="linenos">1101</span></a>        <span class="n">pattern_ds</span><span class="o">=</span><span class="n">pattern_ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
</span><span id="L-1102"><a href="#L-1102"><span class="linenos">1102</span></a>        <span class="n">dims</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">pattern_ds</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
</span><span id="L-1103"><a href="#L-1103"><span class="linenos">1103</span></a>
</span><span id="L-1104"><a href="#L-1104"><span class="linenos">1104</span></a>        <span class="n">index</span><span class="o">=</span><span class="n">pattern_ds</span><span class="o">*</span><span class="n">series_ds</span>
</span><span id="L-1105"><a href="#L-1105"><span class="linenos">1105</span></a>        <span class="c1">#coslat weights lat coords</span>
</span><span id="L-1106"><a href="#L-1106"><span class="linenos">1106</span></a>        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collapse_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">dims</span><span class="p">)</span>
</span><span id="L-1107"><a href="#L-1107"><span class="linenos">1107</span></a>        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rename_index_vars</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">sl</span><span class="p">)</span>
</span><span id="L-1108"><a href="#L-1108"><span class="linenos">1108</span></a>
</span><span id="L-1109"><a href="#L-1109"><span class="linenos">1109</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_params</span><span class="p">:</span>
</span><span id="L-1110"><a href="#L-1110"><span class="linenos">1110</span></a>            <span class="n">mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span>
</span><span id="L-1111"><a href="#L-1111"><span class="linenos">1111</span></a>            <span class="n">std</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span>
</span><span id="L-1112"><a href="#L-1112"><span class="linenos">1112</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-1113"><a href="#L-1113"><span class="linenos">1113</span></a>            <span class="n">mean</span><span class="o">=</span><span class="n">_Dataset_to_dict</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
</span><span id="L-1114"><a href="#L-1114"><span class="linenos">1114</span></a>            <span class="n">std</span><span class="o">=</span><span class="n">_Dataset_to_dict</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
</span><span id="L-1115"><a href="#L-1115"><span class="linenos">1115</span></a>            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mean</span><span class="p">:</span>
</span><span id="L-1116"><a href="#L-1116"><span class="linenos">1116</span></a>                <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">mean</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
</span><span id="L-1117"><a href="#L-1117"><span class="linenos">1117</span></a>            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">std</span><span class="p">:</span>
</span><span id="L-1118"><a href="#L-1118"><span class="linenos">1118</span></a>                <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">std</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
</span><span id="L-1119"><a href="#L-1119"><span class="linenos">1119</span></a>                
</span><span id="L-1120"><a href="#L-1120"><span class="linenos">1120</span></a>        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">standardise</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">mean_ref</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span><span class="n">std_ref</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>
</span><span id="L-1121"><a href="#L-1121"><span class="linenos">1121</span></a>        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_index_attrs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">sl</span><span class="p">,</span><span class="n">mean</span><span class="p">,</span><span class="n">std</span><span class="p">)</span>
</span><span id="L-1122"><a href="#L-1122"><span class="linenos">1122</span></a>
</span><span id="L-1123"><a href="#L-1123"><span class="linenos">1123</span></a>        
</span><span id="L-1124"><a href="#L-1124"><span class="linenos">1124</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">generated_index</span><span class="o">=</span><span class="n">index</span>
</span><span id="L-1125"><a href="#L-1125"><span class="linenos">1125</span></a>        <span class="k">return</span> <span class="n">index</span>
</span><span id="L-1126"><a href="#L-1126"><span class="linenos">1126</span></a>    
</span><span id="L-1127"><a href="#L-1127"><span class="linenos">1127</span></a>    <span class="k">def</span> <span class="nf">_add_index_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">sl</span><span class="p">,</span><span class="n">mean</span><span class="p">,</span><span class="n">std</span><span class="p">):</span>
</span><span id="L-1128"><a href="#L-1128"><span class="linenos">1128</span></a>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
</span><span id="L-1129"><a href="#L-1129"><span class="linenos">1129</span></a>            <span class="n">ix</span><span class="o">=</span><span class="n">index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
</span><span id="L-1130"><a href="#L-1130"><span class="linenos">1130</span></a>            <span class="n">ix</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mean</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
</span><span id="L-1131"><a href="#L-1131"><span class="linenos">1131</span></a>            <span class="n">ix</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">std</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
</span><span id="L-1132"><a href="#L-1132"><span class="linenos">1132</span></a>            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">sl</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span><span id="L-1133"><a href="#L-1133"><span class="linenos">1133</span></a>                <span class="n">ix</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
</span><span id="L-1134"><a href="#L-1134"><span class="linenos">1134</span></a>            <span class="n">index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">ix</span>
</span><span id="L-1135"><a href="#L-1135"><span class="linenos">1135</span></a>        <span class="k">return</span> <span class="n">index</span>
</span><span id="L-1136"><a href="#L-1136"><span class="linenos">1136</span></a>    
</span><span id="L-1137"><a href="#L-1137"><span class="linenos">1137</span></a>    <span class="k">def</span> <span class="nf">_rename_index_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">sl</span><span class="p">):</span>
</span><span id="L-1138"><a href="#L-1138"><span class="linenos">1138</span></a>        <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rename_function</span>
</span><span id="L-1139"><a href="#L-1139"><span class="linenos">1139</span></a>        <span class="k">return</span> <span class="n">index</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="n">v</span><span class="p">:</span><span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">sl</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">data_vars</span><span class="p">})</span>
</span><span id="L-1140"><a href="#L-1140"><span class="linenos">1140</span></a>    
</span><span id="L-1141"><a href="#L-1141"><span class="linenos">1141</span></a>    <span class="k">def</span> <span class="nf">get_standardisation_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="L-1142"><a href="#L-1142"><span class="linenos">1142</span></a><span class="w">        </span>
</span><span id="L-1143"><a href="#L-1143"><span class="linenos">1143</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Retrieve index means and stds for computed indices, for use as future inputs into index_means or index_stds in *IndexGenerator.Generate*</span>
</span><span id="L-1144"><a href="#L-1144"><span class="linenos">1144</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="L-1145"><a href="#L-1145"><span class="linenos">1145</span></a>        <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
</span><span id="L-1146"><a href="#L-1146"><span class="linenos">1146</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span>
</span><span id="L-1147"><a href="#L-1147"><span class="linenos">1147</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="L-1148"><a href="#L-1148"><span class="linenos">1148</span></a>            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">),</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">)]</span>
</span><span id="L-1149"><a href="#L-1149"><span class="linenos">1149</span></a>            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="s1">&#39;param&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;param&#39;</span><span class="p">:[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="s1">&#39;std&#39;</span><span class="p">]})</span>
</span></pre></div>


            </section>
                <section id="LaggedAnalyser">
                            <input id="LaggedAnalyser-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr class">
            
    <span class="def">class</span>
    <span class="name">LaggedAnalyser</span>:

                <label class="view-source-button" for="LaggedAnalyser-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser-16"><a href="#LaggedAnalyser-16"><span class="linenos"> 16</span></a><span class="k">class</span> <span class="nc">LaggedAnalyser</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span id="LaggedAnalyser-17"><a href="#LaggedAnalyser-17"><span class="linenos"> 17</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes lagged composites of variables with respect to a categorical categorical event series, with support for bootstrap resampling to provide a non-parametric assessment of composite significance, and for deseasonalisation of variables.</span>
</span><span id="LaggedAnalyser-18"><a href="#LaggedAnalyser-18"><span class="linenos"> 18</span></a><span class="sd">    </span>
</span><span id="LaggedAnalyser-19"><a href="#LaggedAnalyser-19"><span class="linenos"> 19</span></a><span class="sd">    **Arguments:**</span>
</span><span id="LaggedAnalyser-20"><a href="#LaggedAnalyser-20"><span class="linenos"> 20</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-21"><a href="#LaggedAnalyser-21"><span class="linenos"> 21</span></a><span class="sd">    *event*</span>
</span><span id="LaggedAnalyser-22"><a href="#LaggedAnalyser-22"><span class="linenos"> 22</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-23"><a href="#LaggedAnalyser-23"><span class="linenos"> 23</span></a><span class="sd">    An xarray.DataArray with one dimension taking on categorical values, each defining a class of event (or non-event).</span>
</span><span id="LaggedAnalyser-24"><a href="#LaggedAnalyser-24"><span class="linenos"> 24</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-25"><a href="#LaggedAnalyser-25"><span class="linenos"> 25</span></a><span class="sd">    **Optional arguments**</span>
</span><span id="LaggedAnalyser-26"><a href="#LaggedAnalyser-26"><span class="linenos"> 26</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-27"><a href="#LaggedAnalyser-27"><span class="linenos"> 27</span></a><span class="sd">    *variables, name, is_categorical*</span>
</span><span id="LaggedAnalyser-28"><a href="#LaggedAnalyser-28"><span class="linenos"> 28</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-29"><a href="#LaggedAnalyser-29"><span class="linenos"> 29</span></a><span class="sd">    Arguments for adding variables to the LaggedAnalyser. Identical behaviour to calling *LaggedAnalyser.add_variables* directly.</span>
</span><span id="LaggedAnalyser-30"><a href="#LaggedAnalyser-30"><span class="linenos"> 30</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-31"><a href="#LaggedAnalyser-31"><span class="linenos"> 31</span></a>    
</span><span id="LaggedAnalyser-32"><a href="#LaggedAnalyser-32"><span class="linenos"> 32</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="p">,</span><span class="n">variables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">is_categorical</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="LaggedAnalyser-33"><a href="#LaggedAnalyser-33"><span class="linenos"> 33</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise a new LaggedAnalyser object.&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-34"><a href="#LaggedAnalyser-34"><span class="linenos"> 34</span></a>        
</span><span id="LaggedAnalyser-35"><a href="#LaggedAnalyser-35"><span class="linenos"> 35</span></a>        <span class="c1">#: event is a dataarray</span>
</span><span id="LaggedAnalyser-36"><a href="#LaggedAnalyser-36"><span class="linenos"> 36</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="c1">#: This is a docstring?</span>
</span><span id="LaggedAnalyser-37"><a href="#LaggedAnalyser-37"><span class="linenos"> 37</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-38"><a href="#LaggedAnalyser-38"><span class="linenos"> 38</span></a>        
</span><span id="LaggedAnalyser-39"><a href="#LaggedAnalyser-39"><span class="linenos"> 39</span></a>        <span class="c1">#variables are stored in a dataset, and can be added later,</span>
</span><span id="LaggedAnalyser-40"><a href="#LaggedAnalyser-40"><span class="linenos"> 40</span></a>        <span class="c1">#or passed as a DataArray, a Dataset or as a dict of DataArrays</span>
</span><span id="LaggedAnalyser-41"><a href="#LaggedAnalyser-41"><span class="linenos"> 41</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
</span><span id="LaggedAnalyser-42"><a href="#LaggedAnalyser-42"><span class="linenos"> 42</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-43"><a href="#LaggedAnalyser-43"><span class="linenos"> 43</span></a>
</span><span id="LaggedAnalyser-44"><a href="#LaggedAnalyser-44"><span class="linenos"> 44</span></a>        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-45"><a href="#LaggedAnalyser-45"><span class="linenos"> 45</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
</span><span id="LaggedAnalyser-46"><a href="#LaggedAnalyser-46"><span class="linenos"> 46</span></a>            
</span><span id="LaggedAnalyser-47"><a href="#LaggedAnalyser-47"><span class="linenos"> 47</span></a>        <span class="c1">#Time lagged versions of the dataset self.variables will be stored here, with a key</span>
</span><span id="LaggedAnalyser-48"><a href="#LaggedAnalyser-48"><span class="linenos"> 48</span></a>        <span class="c1">#equal to the lag applied. Designed to be accessed by the self.lagged_variables function</span>
</span><span id="LaggedAnalyser-49"><a href="#LaggedAnalyser-49"><span class="linenos"> 49</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="o">=</span><span class="p">{}</span>
</span><span id="LaggedAnalyser-50"><a href="#LaggedAnalyser-50"><span class="linenos"> 50</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="o">=</span><span class="kc">None</span>
</span><span id="LaggedAnalyser-51"><a href="#LaggedAnalyser-51"><span class="linenos"> 51</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-52"><a href="#LaggedAnalyser-52"><span class="linenos"> 52</span></a>
</span><span id="LaggedAnalyser-53"><a href="#LaggedAnalyser-53"><span class="linenos"> 53</span></a>        <span class="c1">#variables that are a linear combination of other variables are more efficiently</span>
</span><span id="LaggedAnalyser-54"><a href="#LaggedAnalyser-54"><span class="linenos"> 54</span></a>        <span class="c1">#computed after compositing using the self.add_derived_composite method</span>
</span><span id="LaggedAnalyser-55"><a href="#LaggedAnalyser-55"><span class="linenos"> 55</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="o">=</span><span class="p">{}</span>
</span><span id="LaggedAnalyser-56"><a href="#LaggedAnalyser-56"><span class="linenos"> 56</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="o">=</span><span class="p">{}</span>
</span><span id="LaggedAnalyser-57"><a href="#LaggedAnalyser-57"><span class="linenos"> 57</span></a>        
</span><span id="LaggedAnalyser-58"><a href="#LaggedAnalyser-58"><span class="linenos"> 58</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composite_mask</span><span class="o">=</span><span class="kc">None</span>
</span><span id="LaggedAnalyser-59"><a href="#LaggedAnalyser-59"><span class="linenos"> 59</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-60"><a href="#LaggedAnalyser-60"><span class="linenos"> 60</span></a>
</span><span id="LaggedAnalyser-61"><a href="#LaggedAnalyser-61"><span class="linenos"> 61</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">boot_indices</span><span class="o">=</span><span class="kc">None</span>
</span><span id="LaggedAnalyser-62"><a href="#LaggedAnalyser-62"><span class="linenos"> 62</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-63"><a href="#LaggedAnalyser-63"><span class="linenos"> 63</span></a>
</span><span id="LaggedAnalyser-64"><a href="#LaggedAnalyser-64"><span class="linenos"> 64</span></a>        <span class="k">return</span>
</span><span id="LaggedAnalyser-65"><a href="#LaggedAnalyser-65"><span class="linenos"> 65</span></a>    
</span><span id="LaggedAnalyser-66"><a href="#LaggedAnalyser-66"><span class="linenos"> 66</span></a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="LaggedAnalyser-67"><a href="#LaggedAnalyser-67"><span class="linenos"> 67</span></a>        <span class="n">l1</span><span class="o">=</span><span class="s1">&#39;A LaggedAnalyser object</span><span class="se">\n</span><span class="s1">&#39;</span>
</span><span id="LaggedAnalyser-68"><a href="#LaggedAnalyser-68"><span class="linenos"> 68</span></a>        <span class="n">l2</span><span class="o">=</span><span class="s1">&#39;event:</span><span class="se">\n\n</span><span class="s1">&#39;</span>
</span><span id="LaggedAnalyser-69"><a href="#LaggedAnalyser-69"><span class="linenos"> 69</span></a>        <span class="n">da_string</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
</span><span id="LaggedAnalyser-70"><a href="#LaggedAnalyser-70"><span class="linenos"> 70</span></a>        <span class="n">l3</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">variables:</span><span class="se">\n\n</span><span class="s1">&#39;</span>
</span><span id="LaggedAnalyser-71"><a href="#LaggedAnalyser-71"><span class="linenos"> 71</span></a>        <span class="n">ds_string</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
</span><span id="LaggedAnalyser-72"><a href="#LaggedAnalyser-72"><span class="linenos"> 72</span></a>        <span class="n">ds_string</span><span class="o">=</span><span class="n">ds_string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="s1">&#39; &#39;</span><span class="o">+</span><span class="n">ds_string</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</span><span id="LaggedAnalyser-73"><a href="#LaggedAnalyser-73"><span class="linenos"> 73</span></a>        <span class="n">ds_string2</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>
</span><span id="LaggedAnalyser-74"><a href="#LaggedAnalyser-74"><span class="linenos"> 74</span></a>        <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">!=</span><span class="p">[]:</span>
</span><span id="LaggedAnalyser-75"><a href="#LaggedAnalyser-75"><span class="linenos"> 75</span></a>            <span class="n">lag_string</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> Lagged variables at time intervals:</span><span class="se">\n</span><span class="s1"> </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s1">&#39;</span>
</span><span id="LaggedAnalyser-76"><a href="#LaggedAnalyser-76"><span class="linenos"> 76</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-77"><a href="#LaggedAnalyser-77"><span class="linenos"> 77</span></a>            <span class="n">lag_string</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
</span><span id="LaggedAnalyser-78"><a href="#LaggedAnalyser-78"><span class="linenos"> 78</span></a>        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">l1</span><span class="p">,</span><span class="n">l2</span><span class="p">,</span><span class="n">da_string</span><span class="p">,</span><span class="n">l3</span><span class="p">,</span><span class="n">ds_string</span><span class="p">,</span><span class="n">ds_string2</span><span class="p">,</span><span class="n">lag_string</span><span class="p">])</span>
</span><span id="LaggedAnalyser-79"><a href="#LaggedAnalyser-79"><span class="linenos"> 79</span></a>    
</span><span id="LaggedAnalyser-80"><a href="#LaggedAnalyser-80"><span class="linenos"> 80</span></a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="LaggedAnalyser-81"><a href="#LaggedAnalyser-81"><span class="linenos"> 81</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
</span><span id="LaggedAnalyser-82"><a href="#LaggedAnalyser-82"><span class="linenos"> 82</span></a>
</span><span id="LaggedAnalyser-83"><a href="#LaggedAnalyser-83"><span class="linenos"> 83</span></a>    <span class="k">def</span> <span class="nf">add_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">variables</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">is_categorical</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">join_type</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">):</span>
</span><span id="LaggedAnalyser-84"><a href="#LaggedAnalyser-84"><span class="linenos"> 84</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds an additional variable to LaggedAnalyser.variables.</span>
</span><span id="LaggedAnalyser-85"><a href="#LaggedAnalyser-85"><span class="linenos"> 85</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-86"><a href="#LaggedAnalyser-86"><span class="linenos"> 86</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser-87"><a href="#LaggedAnalyser-87"><span class="linenos"> 87</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-88"><a href="#LaggedAnalyser-88"><span class="linenos"> 88</span></a><span class="sd">        *variables* </span>
</span><span id="LaggedAnalyser-89"><a href="#LaggedAnalyser-89"><span class="linenos"> 89</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-90"><a href="#LaggedAnalyser-90"><span class="linenos"> 90</span></a><span class="sd">        An xarray.DataArray, xarray.Dataset or dictionary of xarray.DataArrays, containing data to be composited with respect to *event*. One of the coordinates of *variables* should have the same name as the coordinate of *events*. Stored internally as an xarray.Dataset. If a dictionary is passed, the DataArrays are joined according to the method *join_type* which defaults to &#39;outer&#39;.</span>
</span><span id="LaggedAnalyser-91"><a href="#LaggedAnalyser-91"><span class="linenos"> 91</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-92"><a href="#LaggedAnalyser-92"><span class="linenos"> 92</span></a><span class="sd">        **Optional Arguments**</span>
</span><span id="LaggedAnalyser-93"><a href="#LaggedAnalyser-93"><span class="linenos"> 93</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-94"><a href="#LaggedAnalyser-94"><span class="linenos"> 94</span></a><span class="sd">        *name* </span>
</span><span id="LaggedAnalyser-95"><a href="#LaggedAnalyser-95"><span class="linenos"> 95</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-96"><a href="#LaggedAnalyser-96"><span class="linenos"> 96</span></a><span class="sd">        A string. If *variables* is a single xarray.DataArray then *name* will be used as the name of the array in the LaggedAnalyser.variables DataArray. Otherwise ignored.</span>
</span><span id="LaggedAnalyser-97"><a href="#LaggedAnalyser-97"><span class="linenos"> 97</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-98"><a href="#LaggedAnalyser-98"><span class="linenos"> 98</span></a><span class="sd">        *is_categorical* </span>
</span><span id="LaggedAnalyser-99"><a href="#LaggedAnalyser-99"><span class="linenos"> 99</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-100"><a href="#LaggedAnalyser-100"><span class="linenos">100</span></a><span class="sd">        An integer, if *variables* is an xarray.DataArray, or else a dictionary of integers with keys corresponding to DataArrays in the xarray.Dataset/dictionary. 0 indicates that the variable is continuous, and 1 indicates that it is categorical. Note that continuous and categorical variables are by default composited differently (see LaggedAnalyser.compute_composites). Default assumption is all DataArrays are continuous, unless a DataAarray contains an &#39;is_categorical&#39; key in its DataArray.attrs, in which case this value is used.</span>
</span><span id="LaggedAnalyser-101"><a href="#LaggedAnalyser-101"><span class="linenos">101</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-102"><a href="#LaggedAnalyser-102"><span class="linenos">102</span></a><span class="sd">        *overwrite*</span>
</span><span id="LaggedAnalyser-103"><a href="#LaggedAnalyser-103"><span class="linenos">103</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-104"><a href="#LaggedAnalyser-104"><span class="linenos">104</span></a><span class="sd">        A boolean. If False then attempts to assign a variable who&#39;s name is already in *LaggedAnalyser.variables* will raise a ValueError</span>
</span><span id="LaggedAnalyser-105"><a href="#LaggedAnalyser-105"><span class="linenos">105</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-106"><a href="#LaggedAnalyser-106"><span class="linenos">106</span></a><span class="sd">        *join_type*</span>
</span><span id="LaggedAnalyser-107"><a href="#LaggedAnalyser-107"><span class="linenos">107</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-108"><a href="#LaggedAnalyser-108"><span class="linenos">108</span></a><span class="sd">        A string setting the rules for how differences in the coordinate indices of different variables are handled:</span>
</span><span id="LaggedAnalyser-109"><a href="#LaggedAnalyser-109"><span class="linenos">109</span></a><span class="sd">        outer: use the union of object indexes</span>
</span><span id="LaggedAnalyser-110"><a href="#LaggedAnalyser-110"><span class="linenos">110</span></a><span class="sd">        inner: use the intersection of object indexes</span>
</span><span id="LaggedAnalyser-111"><a href="#LaggedAnalyser-111"><span class="linenos">111</span></a>
</span><span id="LaggedAnalyser-112"><a href="#LaggedAnalyser-112"><span class="linenos">112</span></a><span class="sd">        left: use indexes from the pre-existing *LaggedAnalyser.variables* with each dimension</span>
</span><span id="LaggedAnalyser-113"><a href="#LaggedAnalyser-113"><span class="linenos">113</span></a>
</span><span id="LaggedAnalyser-114"><a href="#LaggedAnalyser-114"><span class="linenos">114</span></a><span class="sd">        right: use indexes from the new *variables* with each dimension</span>
</span><span id="LaggedAnalyser-115"><a href="#LaggedAnalyser-115"><span class="linenos">115</span></a>
</span><span id="LaggedAnalyser-116"><a href="#LaggedAnalyser-116"><span class="linenos">116</span></a><span class="sd">        exact: instead of aligning, raise ValueError when indexes to be aligned are not equal</span>
</span><span id="LaggedAnalyser-117"><a href="#LaggedAnalyser-117"><span class="linenos">117</span></a>
</span><span id="LaggedAnalyser-118"><a href="#LaggedAnalyser-118"><span class="linenos">118</span></a><span class="sd">        override: if indexes are of same size, rewrite indexes to be those of the pre-existing *LaggedAnalyser.variables*. Indexes for the same dimension must have the same size in all objects.</span>
</span><span id="LaggedAnalyser-119"><a href="#LaggedAnalyser-119"><span class="linenos">119</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-120"><a href="#LaggedAnalyser-120"><span class="linenos">120</span></a>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
</span><span id="LaggedAnalyser-121"><a href="#LaggedAnalyser-121"><span class="linenos">121</span></a>            
</span><span id="LaggedAnalyser-122"><a href="#LaggedAnalyser-122"><span class="linenos">122</span></a>            <span class="k">if</span> <span class="n">is_categorical</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-123"><a href="#LaggedAnalyser-123"><span class="linenos">123</span></a>                <span class="n">is_categorical</span><span class="o">=</span><span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
</span><span id="LaggedAnalyser-124"><a href="#LaggedAnalyser-124"><span class="linenos">124</span></a>                
</span><span id="LaggedAnalyser-125"><a href="#LaggedAnalyser-125"><span class="linenos">125</span></a>            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_variable</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">da</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
</span><span id="LaggedAnalyser-126"><a href="#LaggedAnalyser-126"><span class="linenos">126</span></a>            
</span><span id="LaggedAnalyser-127"><a href="#LaggedAnalyser-127"><span class="linenos">127</span></a>        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
</span><span id="LaggedAnalyser-128"><a href="#LaggedAnalyser-128"><span class="linenos">128</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">add_variable</span><span class="p">({</span><span class="n">v</span><span class="p">:</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">data_vars</span><span class="p">},</span><span class="kc">None</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">)</span>
</span><span id="LaggedAnalyser-129"><a href="#LaggedAnalyser-129"><span class="linenos">129</span></a>            
</span><span id="LaggedAnalyser-130"><a href="#LaggedAnalyser-130"><span class="linenos">130</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-131"><a href="#LaggedAnalyser-131"><span class="linenos">131</span></a>            
</span><span id="LaggedAnalyser-132"><a href="#LaggedAnalyser-132"><span class="linenos">132</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">_add_variable</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">)</span>            
</span><span id="LaggedAnalyser-133"><a href="#LaggedAnalyser-133"><span class="linenos">133</span></a>        <span class="k">return</span>
</span><span id="LaggedAnalyser-134"><a href="#LaggedAnalyser-134"><span class="linenos">134</span></a>    
</span><span id="LaggedAnalyser-135"><a href="#LaggedAnalyser-135"><span class="linenos">135</span></a>    <span class="k">def</span> <span class="nf">_more_mergable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="p">):</span>
</span><span id="LaggedAnalyser-136"><a href="#LaggedAnalyser-136"><span class="linenos">136</span></a>        
</span><span id="LaggedAnalyser-137"><a href="#LaggedAnalyser-137"><span class="linenos">137</span></a>        <span class="k">return</span> <span class="n">drop_scalar_coords</span><span class="p">(</span><span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span>
</span><span id="LaggedAnalyser-138"><a href="#LaggedAnalyser-138"><span class="linenos">138</span></a>    
</span><span id="LaggedAnalyser-139"><a href="#LaggedAnalyser-139"><span class="linenos">139</span></a>    <span class="k">def</span> <span class="nf">_add_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">da</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">):</span>
</span><span id="LaggedAnalyser-140"><a href="#LaggedAnalyser-140"><span class="linenos">140</span></a>        
</span><span id="LaggedAnalyser-141"><a href="#LaggedAnalyser-141"><span class="linenos">141</span></a>        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-142"><a href="#LaggedAnalyser-142"><span class="linenos">142</span></a>            <span class="n">name</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">name</span>
</span><span id="LaggedAnalyser-143"><a href="#LaggedAnalyser-143"><span class="linenos">143</span></a>        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="ow">not</span> <span class="n">overwrite</span><span class="p">):</span>
</span><span id="LaggedAnalyser-144"><a href="#LaggedAnalyser-144"><span class="linenos">144</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Key &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; is already in variables.&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser-145"><a href="#LaggedAnalyser-145"><span class="linenos">145</span></a>        
</span><span id="LaggedAnalyser-146"><a href="#LaggedAnalyser-146"><span class="linenos">146</span></a>        <span class="k">try</span><span class="p">:</span>
</span><span id="LaggedAnalyser-147"><a href="#LaggedAnalyser-147"><span class="linenos">147</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">squeeze_da</span><span class="p">(</span><span class="n">da</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">),</span><span class="n">join</span><span class="o">=</span><span class="n">join_type</span><span class="p">)</span>
</span><span id="LaggedAnalyser-148"><a href="#LaggedAnalyser-148"><span class="linenos">148</span></a>        <span class="k">except</span><span class="p">:</span>
</span><span id="LaggedAnalyser-149"><a href="#LaggedAnalyser-149"><span class="linenos">149</span></a>            <span class="c1">#Trying to make the merge work:</span>
</span><span id="LaggedAnalyser-150"><a href="#LaggedAnalyser-150"><span class="linenos">150</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_more_mergable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_more_mergable</span><span class="p">(</span><span class="n">squeeze_da</span><span class="p">(</span><span class="n">da</span><span class="p">)</span><span class="o">.</span><span class="n">to_dataset</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)),</span><span class="n">join</span><span class="o">=</span><span class="n">join_type</span><span class="p">)</span>
</span><span id="LaggedAnalyser-151"><a href="#LaggedAnalyser-151"><span class="linenos">151</span></a>
</span><span id="LaggedAnalyser-152"><a href="#LaggedAnalyser-152"><span class="linenos">152</span></a>        <span class="k">if</span> <span class="p">(</span><span class="n">is_categorical</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="s1">&#39;is_categorical&#39;</span> <span class="ow">in</span> <span class="n">da</span><span class="o">.</span><span class="n">attrs</span><span class="p">):</span>
</span><span id="LaggedAnalyser-153"><a href="#LaggedAnalyser-153"><span class="linenos">153</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;is_categorical&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
</span><span id="LaggedAnalyser-154"><a href="#LaggedAnalyser-154"><span class="linenos">154</span></a>        <span class="k">elif</span> <span class="n">is_categorical</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-155"><a href="#LaggedAnalyser-155"><span class="linenos">155</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;is_categorical&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">is_categorical</span>
</span><span id="LaggedAnalyser-156"><a href="#LaggedAnalyser-156"><span class="linenos">156</span></a>
</span><span id="LaggedAnalyser-157"><a href="#LaggedAnalyser-157"><span class="linenos">157</span></a>    <span class="k">def</span> <span class="nf">lagged_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
</span><span id="LaggedAnalyser-158"><a href="#LaggedAnalyser-158"><span class="linenos">158</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;A convenience function that retrieves variables at lag *t* from the *LaggedAnalyser*&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-159"><a href="#LaggedAnalyser-159"><span class="linenos">159</span></a>        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">:</span>
</span><span id="LaggedAnalyser-160"><a href="#LaggedAnalyser-160"><span class="linenos">160</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
</span><span id="LaggedAnalyser-161"><a href="#LaggedAnalyser-161"><span class="linenos">161</span></a>        <span class="k">elif</span> <span class="n">t</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
</span><span id="LaggedAnalyser-162"><a href="#LaggedAnalyser-162"><span class="linenos">162</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
</span><span id="LaggedAnalyser-163"><a href="#LaggedAnalyser-163"><span class="linenos">163</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-164"><a href="#LaggedAnalyser-164"><span class="linenos">164</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lag </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1"> is not in self._lagged_variables.&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser-165"><a href="#LaggedAnalyser-165"><span class="linenos">165</span></a>
</span><span id="LaggedAnalyser-166"><a href="#LaggedAnalyser-166"><span class="linenos">166</span></a>    <span class="k">def</span> <span class="nf">_lag_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="n">offset_unit</span><span class="o">=</span><span class="s1">&#39;days&#39;</span><span class="p">,</span><span class="n">offset_dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser-167"><a href="#LaggedAnalyser-167"><span class="linenos">167</span></a>        
</span><span id="LaggedAnalyser-168"><a href="#LaggedAnalyser-168"><span class="linenos">168</span></a>        <span class="k">if</span> <span class="n">offset</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
</span><span id="LaggedAnalyser-169"><a href="#LaggedAnalyser-169"><span class="linenos">169</span></a>            <span class="k">return</span>
</span><span id="LaggedAnalyser-170"><a href="#LaggedAnalyser-170"><span class="linenos">170</span></a>        <span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="ow">not</span> <span class="n">overwrite</span><span class="p">):</span>
</span><span id="LaggedAnalyser-171"><a href="#LaggedAnalyser-171"><span class="linenos">171</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Key &quot;</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s1">&quot; is already in lagged_variables.&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser-172"><a href="#LaggedAnalyser-172"><span class="linenos">172</span></a>            
</span><span id="LaggedAnalyser-173"><a href="#LaggedAnalyser-173"><span class="linenos">173</span></a>        <span class="c1">#We are really paranoid about mixing up our lags. So we implement this safety check</span>
</span><span id="LaggedAnalyser-174"><a href="#LaggedAnalyser-174"><span class="linenos">174</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_check_offset_is_valid</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="LaggedAnalyser-175"><a href="#LaggedAnalyser-175"><span class="linenos">175</span></a>        
</span><span id="LaggedAnalyser-176"><a href="#LaggedAnalyser-176"><span class="linenos">176</span></a>        <span class="c1">#REPLACED PREVIOUS IMPLEMENTATION WITH EQUIVALENT UTIL IMPORT.</span>
</span><span id="LaggedAnalyser-177"><a href="#LaggedAnalyser-177"><span class="linenos">177</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span><span class="o">=</span><span class="n">offset_time_dim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span><span class="o">-</span><span class="n">offset</span><span class="p">,</span><span class="n">offset_unit</span><span class="o">=</span><span class="n">offset_unit</span><span class="p">,</span><span class="n">offset_dim</span><span class="o">=</span><span class="n">offset_dim</span><span class="p">)</span>
</span><span id="LaggedAnalyser-178"><a href="#LaggedAnalyser-178"><span class="linenos">178</span></a>
</span><span id="LaggedAnalyser-179"><a href="#LaggedAnalyser-179"><span class="linenos">179</span></a>        <span class="k">return</span>
</span><span id="LaggedAnalyser-180"><a href="#LaggedAnalyser-180"><span class="linenos">180</span></a>    
</span><span id="LaggedAnalyser-181"><a href="#LaggedAnalyser-181"><span class="linenos">181</span></a>    <span class="c1">#For coords not in a time format</span>
</span><span id="LaggedAnalyser-182"><a href="#LaggedAnalyser-182"><span class="linenos">182</span></a>    <span class="k">def</span> <span class="nf">_ilag_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser-183"><a href="#LaggedAnalyser-183"><span class="linenos">183</span></a>        <span class="k">raise</span><span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Only lagging along timelike dimensions is currently supported.&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser-184"><a href="#LaggedAnalyser-184"><span class="linenos">184</span></a>        
</span><span id="LaggedAnalyser-185"><a href="#LaggedAnalyser-185"><span class="linenos">185</span></a>    <span class="k">def</span> <span class="nf">lag_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">offsets</span><span class="p">,</span><span class="n">offset_unit</span><span class="o">=</span><span class="s1">&#39;days&#39;</span><span class="p">,</span><span class="n">offset_dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser-186"><a href="#LaggedAnalyser-186"><span class="linenos">186</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Produces time lags of *LaggedAnalyser.variables*, which can be used to produce lagged composites.</span>
</span><span id="LaggedAnalyser-187"><a href="#LaggedAnalyser-187"><span class="linenos">187</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-188"><a href="#LaggedAnalyser-188"><span class="linenos">188</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser-189"><a href="#LaggedAnalyser-189"><span class="linenos">189</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-190"><a href="#LaggedAnalyser-190"><span class="linenos">190</span></a><span class="sd">        *offsets*</span>
</span><span id="LaggedAnalyser-191"><a href="#LaggedAnalyser-191"><span class="linenos">191</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-192"><a href="#LaggedAnalyser-192"><span class="linenos">192</span></a><span class="sd">        An iterable of integers which represent time lags at which to lag *LaggedAnalyser.variables* in the units specified by *offset_unit*. Positive offsets denote variables *preceding* the event.</span>
</span><span id="LaggedAnalyser-193"><a href="#LaggedAnalyser-193"><span class="linenos">193</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-194"><a href="#LaggedAnalyser-194"><span class="linenos">194</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser-195"><a href="#LaggedAnalyser-195"><span class="linenos">195</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-196"><a href="#LaggedAnalyser-196"><span class="linenos">196</span></a><span class="sd">        *offset_unit*</span>
</span><span id="LaggedAnalyser-197"><a href="#LaggedAnalyser-197"><span class="linenos">197</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-198"><a href="#LaggedAnalyser-198"><span class="linenos">198</span></a><span class="sd">        A string, defining the units of *offsets*. Valid options are weeks, days, hours, minutes, seconds, milliseconds, and microseconds.</span>
</span><span id="LaggedAnalyser-199"><a href="#LaggedAnalyser-199"><span class="linenos">199</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-200"><a href="#LaggedAnalyser-200"><span class="linenos">200</span></a><span class="sd">        *offset_dim*</span>
</span><span id="LaggedAnalyser-201"><a href="#LaggedAnalyser-201"><span class="linenos">201</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-202"><a href="#LaggedAnalyser-202"><span class="linenos">202</span></a><span class="sd">        A string, defining the coordinate of *LaggedAnalyser.variables* along which offsets are to be calculated.</span>
</span><span id="LaggedAnalyser-203"><a href="#LaggedAnalyser-203"><span class="linenos">203</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-204"><a href="#LaggedAnalyser-204"><span class="linenos">204</span></a><span class="sd">        *mode*</span>
</span><span id="LaggedAnalyser-205"><a href="#LaggedAnalyser-205"><span class="linenos">205</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-206"><a href="#LaggedAnalyser-206"><span class="linenos">206</span></a><span class="sd">        One of &#39;any&#39;, &#39;past&#39;, or &#39;future&#39;. If &#39;past&#39; or &#39;future&#39; is used then only positive or negative lags are valid, respectively.</span>
</span><span id="LaggedAnalyser-207"><a href="#LaggedAnalyser-207"><span class="linenos">207</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-208"><a href="#LaggedAnalyser-208"><span class="linenos">208</span></a><span class="sd">        *overwrite*</span>
</span><span id="LaggedAnalyser-209"><a href="#LaggedAnalyser-209"><span class="linenos">209</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-210"><a href="#LaggedAnalyser-210"><span class="linenos">210</span></a><span class="sd">        A boolean. If False, then attempts to produce a lag which already exist will raise a ValueError.</span>
</span><span id="LaggedAnalyser-211"><a href="#LaggedAnalyser-211"><span class="linenos">211</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-212"><a href="#LaggedAnalyser-212"><span class="linenos">212</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-213"><a href="#LaggedAnalyser-213"><span class="linenos">213</span></a>        <span class="n">time_type</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">is_time_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">offset_dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
</span><span id="LaggedAnalyser-214"><a href="#LaggedAnalyser-214"><span class="linenos">214</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">offset_unit</span><span class="o">=</span><span class="n">offset_unit</span>
</span><span id="LaggedAnalyser-215"><a href="#LaggedAnalyser-215"><span class="linenos">215</span></a>        <span class="n">lag_funcs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ilag_variables</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_lag_variables</span><span class="p">]</span>
</span><span id="LaggedAnalyser-216"><a href="#LaggedAnalyser-216"><span class="linenos">216</span></a>        <span class="n">offsets</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
</span><span id="LaggedAnalyser-217"><a href="#LaggedAnalyser-217"><span class="linenos">217</span></a>        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">:</span>
</span><span id="LaggedAnalyser-218"><a href="#LaggedAnalyser-218"><span class="linenos">218</span></a>            <span class="n">lag_funcs</span><span class="p">[</span><span class="n">time_type</span><span class="p">](</span><span class="nb">int</span><span class="p">(</span><span class="n">o</span><span class="p">),</span><span class="n">offset_unit</span><span class="p">,</span><span class="n">offset_dim</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="n">overwrite</span><span class="p">)</span>
</span><span id="LaggedAnalyser-219"><a href="#LaggedAnalyser-219"><span class="linenos">219</span></a>        
</span><span id="LaggedAnalyser-220"><a href="#LaggedAnalyser-220"><span class="linenos">220</span></a>    <span class="k">def</span> <span class="nf">_check_offset_is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">offset</span><span class="p">,</span><span class="n">mode</span><span class="p">):</span>
</span><span id="LaggedAnalyser-221"><a href="#LaggedAnalyser-221"><span class="linenos">221</span></a>        
</span><span id="LaggedAnalyser-222"><a href="#LaggedAnalyser-222"><span class="linenos">222</span></a>        <span class="n">valid_modes</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;any&#39;</span><span class="p">,</span><span class="s1">&#39;past&#39;</span><span class="p">,</span><span class="s1">&#39;future&#39;</span><span class="p">]</span>
</span><span id="LaggedAnalyser-223"><a href="#LaggedAnalyser-223"><span class="linenos">223</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">valid_modes</span><span class="p">:</span>
</span><span id="LaggedAnalyser-224"><a href="#LaggedAnalyser-224"><span class="linenos">224</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mode must be one of </span><span class="si">{</span><span class="n">valid_modes</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser-225"><a href="#LaggedAnalyser-225"><span class="linenos">225</span></a>        <span class="k">if</span> <span class="n">offset</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;past&#39;</span><span class="p">:</span>
</span><span id="LaggedAnalyser-226"><a href="#LaggedAnalyser-226"><span class="linenos">226</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Positive offset </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s1"> given, but mode is &quot;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser-227"><a href="#LaggedAnalyser-227"><span class="linenos">227</span></a>        <span class="k">if</span> <span class="n">offset</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;future&#39;</span><span class="p">:</span>
</span><span id="LaggedAnalyser-228"><a href="#LaggedAnalyser-228"><span class="linenos">228</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Negative offset </span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s1"> given, but mode is &quot;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser-229"><a href="#LaggedAnalyser-229"><span class="linenos">229</span></a>        <span class="k">return</span>
</span><span id="LaggedAnalyser-230"><a href="#LaggedAnalyser-230"><span class="linenos">230</span></a><span class="w">    </span>
</span><span id="LaggedAnalyser-231"><a href="#LaggedAnalyser-231"><span class="linenos">231</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-232"><a href="#LaggedAnalyser-232"><span class="linenos">232</span></a><span class="sd">        COMPOSITE COMPUTATION FUNCTIONS </span>
</span><span id="LaggedAnalyser-233"><a href="#LaggedAnalyser-233"><span class="linenos">233</span></a><span class="sd">        Composite computation is split over 4 function layers:</span>
</span><span id="LaggedAnalyser-234"><a href="#LaggedAnalyser-234"><span class="linenos">234</span></a><span class="sd">        compute_composites(): calls</span>
</span><span id="LaggedAnalyser-235"><a href="#LaggedAnalyser-235"><span class="linenos">235</span></a><span class="sd">            _compute_aggregate_over_lags(): calls</span>
</span><span id="LaggedAnalyser-236"><a href="#LaggedAnalyser-236"><span class="linenos">236</span></a><span class="sd">                _composite_from_ix(): splits data into cat vars</span>
</span><span id="LaggedAnalyser-237"><a href="#LaggedAnalyser-237"><span class="linenos">237</span></a><span class="sd">                and con vars and then calls</span>
</span><span id="LaggedAnalyser-238"><a href="#LaggedAnalyser-238"><span class="linenos">238</span></a><span class="sd">                    _aggregate_from_ix(): applies an operation to</span>
</span><span id="LaggedAnalyser-239"><a href="#LaggedAnalyser-239"><span class="linenos">239</span></a><span class="sd">                    subsets of ds, where the ix takes unique values</span>
</span><span id="LaggedAnalyser-240"><a href="#LaggedAnalyser-240"><span class="linenos">240</span></a><span class="sd">                then merges them together.</span>
</span><span id="LaggedAnalyser-241"><a href="#LaggedAnalyser-241"><span class="linenos">241</span></a><span class="sd">             then loops over lags and merges those.</span>
</span><span id="LaggedAnalyser-242"><a href="#LaggedAnalyser-242"><span class="linenos">242</span></a><span class="sd">        And then substracts any anomalies and returns the data.</span>
</span><span id="LaggedAnalyser-243"><a href="#LaggedAnalyser-243"><span class="linenos">243</span></a>
</span><span id="LaggedAnalyser-244"><a href="#LaggedAnalyser-244"><span class="linenos">244</span></a>
</span><span id="LaggedAnalyser-245"><a href="#LaggedAnalyser-245"><span class="linenos">245</span></a><span class="sd">        Example usage of the aggregate funcs:</span>
</span><span id="LaggedAnalyser-246"><a href="#LaggedAnalyser-246"><span class="linenos">246</span></a><span class="sd">        i.e. self._aggregate_from_ix(ds,ix,&#39;time&#39;,self._mean_ds)</span>
</span><span id="LaggedAnalyser-247"><a href="#LaggedAnalyser-247"><span class="linenos">247</span></a><span class="sd">        self._aggregate_from_ix(ds,ix,&#39;time&#39;,self._std_ds)</span>
</span><span id="LaggedAnalyser-248"><a href="#LaggedAnalyser-248"><span class="linenos">248</span></a><span class="sd">        self._aggregate_from_ix(ds,ix,&#39;time&#39;,self._cat_occ_ds,s=reg_ds)</span>
</span><span id="LaggedAnalyser-249"><a href="#LaggedAnalyser-249"><span class="linenos">249</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-250"><a href="#LaggedAnalyser-250"><span class="linenos">250</span></a>    
</span><span id="LaggedAnalyser-251"><a href="#LaggedAnalyser-251"><span class="linenos">251</span></a>    <span class="k">def</span> <span class="nf">_aggregate_from_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">agg_func</span><span class="p">,</span><span class="o">*</span><span class="n">agg_args</span><span class="p">):</span>
</span><span id="LaggedAnalyser-252"><a href="#LaggedAnalyser-252"><span class="linenos">252</span></a>        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">agg_func</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">dim</span><span class="p">:</span><span class="n">ix</span><span class="o">==</span><span class="n">i</span><span class="p">}),</span><span class="n">dim</span><span class="p">,</span><span class="o">*</span><span class="n">agg_args</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ix</span><span class="p">)],</span><span class="s1">&#39;index_val&#39;</span><span class="p">)</span>
</span><span id="LaggedAnalyser-253"><a href="#LaggedAnalyser-253"><span class="linenos">253</span></a>    
</span><span id="LaggedAnalyser-254"><a href="#LaggedAnalyser-254"><span class="linenos">254</span></a>    
</span><span id="LaggedAnalyser-255"><a href="#LaggedAnalyser-255"><span class="linenos">255</span></a>    <span class="c1">#Splits variables into cat and con and then combines the two different kinds of composites.</span>
</span><span id="LaggedAnalyser-256"><a href="#LaggedAnalyser-256"><span class="linenos">256</span></a>    <span class="c1">#Used with a synthetic &#39;ix&#39; for bootstrapping by self._compute_bootstraps.</span>
</span><span id="LaggedAnalyser-257"><a href="#LaggedAnalyser-257"><span class="linenos">257</span></a>    <span class="k">def</span> <span class="nf">_composite_from_ix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">ds</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
</span><span id="LaggedAnalyser-258"><a href="#LaggedAnalyser-258"><span class="linenos">258</span></a>                
</span><span id="LaggedAnalyser-259"><a href="#LaggedAnalyser-259"><span class="linenos">259</span></a>        <span class="n">ix</span><span class="o">=</span><span class="n">ix</span><span class="o">.</span><span class="n">values</span> <span class="c1">#passed in as a da</span>
</span><span id="LaggedAnalyser-260"><a href="#LaggedAnalyser-260"><span class="linenos">260</span></a>        <span class="n">cat_vars</span><span class="o">=</span><span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span> <span class="k">if</span> <span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;is_categorical&#39;</span><span class="p">]]</span>
</span><span id="LaggedAnalyser-261"><a href="#LaggedAnalyser-261"><span class="linenos">261</span></a>        <span class="n">con_vars</span><span class="o">=</span><span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ds</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cat_vars</span><span class="p">]</span>
</span><span id="LaggedAnalyser-262"><a href="#LaggedAnalyser-262"><span class="linenos">262</span></a>        <span class="n">cat_ds</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="n">cat_vars</span><span class="p">]</span>
</span><span id="LaggedAnalyser-263"><a href="#LaggedAnalyser-263"><span class="linenos">263</span></a>        <span class="n">con_ds</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="n">con_vars</span><span class="p">]</span>
</span><span id="LaggedAnalyser-264"><a href="#LaggedAnalyser-264"><span class="linenos">264</span></a>        <span class="n">cat_vals</span><span class="o">=</span><span class="n">cat_ds</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">)</span>
</span><span id="LaggedAnalyser-265"><a href="#LaggedAnalyser-265"><span class="linenos">265</span></a>
</span><span id="LaggedAnalyser-266"><a href="#LaggedAnalyser-266"><span class="linenos">266</span></a>        <span class="k">if</span> <span class="p">(</span><span class="n">con_vars</span><span class="o">!=</span><span class="p">[])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">con_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
</span><span id="LaggedAnalyser-267"><a href="#LaggedAnalyser-267"><span class="linenos">267</span></a>            <span class="k">if</span> <span class="p">(</span><span class="n">cat_vars</span><span class="o">!=</span><span class="p">[])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cat_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
</span><span id="LaggedAnalyser-268"><a href="#LaggedAnalyser-268"><span class="linenos">268</span></a>                <span class="n">con_comp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_from_ix</span><span class="p">(</span><span class="n">con_ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">)</span>
</span><span id="LaggedAnalyser-269"><a href="#LaggedAnalyser-269"><span class="linenos">269</span></a>                <span class="n">cat_comp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_from_ix</span><span class="p">(</span><span class="n">cat_ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">cat_vals</span><span class="p">)</span>
</span><span id="LaggedAnalyser-270"><a href="#LaggedAnalyser-270"><span class="linenos">270</span></a>                <span class="n">comp</span><span class="o">=</span><span class="n">con_comp</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">cat_comp</span><span class="p">)</span>
</span><span id="LaggedAnalyser-271"><a href="#LaggedAnalyser-271"><span class="linenos">271</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-272"><a href="#LaggedAnalyser-272"><span class="linenos">272</span></a>                <span class="n">comp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_from_ix</span><span class="p">(</span><span class="n">con_ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">)</span>
</span><span id="LaggedAnalyser-273"><a href="#LaggedAnalyser-273"><span class="linenos">273</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-274"><a href="#LaggedAnalyser-274"><span class="linenos">274</span></a>                <span class="n">comp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_from_ix</span><span class="p">(</span><span class="n">cat_ds</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">cat_vals</span><span class="p">)</span>
</span><span id="LaggedAnalyser-275"><a href="#LaggedAnalyser-275"><span class="linenos">275</span></a>        <span class="n">comp</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">attrs</span>
</span><span id="LaggedAnalyser-276"><a href="#LaggedAnalyser-276"><span class="linenos">276</span></a>        <span class="k">return</span> <span class="n">comp</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;lag&#39;</span><span class="p">:[</span><span class="n">lag</span><span class="p">]})</span>    
</span><span id="LaggedAnalyser-277"><a href="#LaggedAnalyser-277"><span class="linenos">277</span></a>    
</span><span id="LaggedAnalyser-278"><a href="#LaggedAnalyser-278"><span class="linenos">278</span></a>    <span class="c1">#loops over all lags, calling _composite_from_ix, and assembles composites into a single dataset</span>
</span><span id="LaggedAnalyser-279"><a href="#LaggedAnalyser-279"><span class="linenos">279</span></a>    <span class="k">def</span> <span class="nf">_compute_aggregate_over_lags</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">da</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">):</span>
</span><span id="LaggedAnalyser-280"><a href="#LaggedAnalyser-280"><span class="linenos">280</span></a>            
</span><span id="LaggedAnalyser-281"><a href="#LaggedAnalyser-281"><span class="linenos">281</span></a>        <span class="k">if</span> <span class="n">lag_vals</span><span class="o">==</span><span class="s1">&#39;all&#39;</span><span class="p">:</span>
</span><span id="LaggedAnalyser-282"><a href="#LaggedAnalyser-282"><span class="linenos">282</span></a>            <span class="n">lag_vals</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)</span>
</span><span id="LaggedAnalyser-283"><a href="#LaggedAnalyser-283"><span class="linenos">283</span></a>                    
</span><span id="LaggedAnalyser-284"><a href="#LaggedAnalyser-284"><span class="linenos">284</span></a>        <span class="n">composite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_composite_from_ix</span><span class="p">(</span><span class="o">*</span><span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="LaggedAnalyser-285"><a href="#LaggedAnalyser-285"><span class="linenos">285</span></a>              
</span><span id="LaggedAnalyser-286"><a href="#LaggedAnalyser-286"><span class="linenos">286</span></a>        <span class="k">if</span> <span class="n">lag_vals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-287"><a href="#LaggedAnalyser-287"><span class="linenos">287</span></a>            <span class="n">lag_composites</span><span class="o">=</span><span class="p">[]</span>
</span><span id="LaggedAnalyser-288"><a href="#LaggedAnalyser-288"><span class="linenos">288</span></a>            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lag_vals</span><span class="p">:</span>
</span><span id="LaggedAnalyser-289"><a href="#LaggedAnalyser-289"><span class="linenos">289</span></a>                <span class="n">lag_composites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_composite_from_ix</span><span class="p">(</span><span class="o">*</span><span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_variables</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="o">=</span><span class="n">t</span><span class="p">))</span>
</span><span id="LaggedAnalyser-290"><a href="#LaggedAnalyser-290"><span class="linenos">290</span></a>            <span class="n">composite</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">composite</span><span class="p">,</span><span class="o">*</span><span class="n">lag_composites</span><span class="p">],</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span>
</span><span id="LaggedAnalyser-291"><a href="#LaggedAnalyser-291"><span class="linenos">291</span></a>            
</span><span id="LaggedAnalyser-292"><a href="#LaggedAnalyser-292"><span class="linenos">292</span></a>        <span class="k">return</span> <span class="n">composite</span>
</span><span id="LaggedAnalyser-293"><a href="#LaggedAnalyser-293"><span class="linenos">293</span></a>
</span><span id="LaggedAnalyser-294"><a href="#LaggedAnalyser-294"><span class="linenos">294</span></a>    <span class="c1">#The top level wrapper for compositing</span>
</span><span id="LaggedAnalyser-295"><a href="#LaggedAnalyser-295"><span class="linenos">295</span></a>    <span class="k">def</span> <span class="nf">compute_composites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">lag_vals</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">as_anomaly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">con_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">mean_ds</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">cat_occ_ds</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="LaggedAnalyser-296"><a href="#LaggedAnalyser-296"><span class="linenos">296</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser-297"><a href="#LaggedAnalyser-297"><span class="linenos">297</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-298"><a href="#LaggedAnalyser-298"><span class="linenos">298</span></a><span class="sd">        Partitions *LaggedAnalyser.variables*, and any time-lagged equivalents, into subsets depending on the value of *LaggedAnalyser.event*, and then computes a bulk summary metric for each.</span>
</span><span id="LaggedAnalyser-299"><a href="#LaggedAnalyser-299"><span class="linenos">299</span></a>
</span><span id="LaggedAnalyser-300"><a href="#LaggedAnalyser-300"><span class="linenos">300</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser-301"><a href="#LaggedAnalyser-301"><span class="linenos">301</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-302"><a href="#LaggedAnalyser-302"><span class="linenos">302</span></a><span class="sd">        *dim*</span>
</span><span id="LaggedAnalyser-303"><a href="#LaggedAnalyser-303"><span class="linenos">303</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-304"><a href="#LaggedAnalyser-304"><span class="linenos">304</span></a><span class="sd">        A string, the coordinate along which to compute composites.</span>
</span><span id="LaggedAnalyser-305"><a href="#LaggedAnalyser-305"><span class="linenos">305</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-306"><a href="#LaggedAnalyser-306"><span class="linenos">306</span></a><span class="sd">        *lag_vals*</span>
</span><span id="LaggedAnalyser-307"><a href="#LaggedAnalyser-307"><span class="linenos">307</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-308"><a href="#LaggedAnalyser-308"><span class="linenos">308</span></a><span class="sd">        Either &#39;All&#39;, or a list of integers, denoting the time lags for which composites should be computed.</span>
</span><span id="LaggedAnalyser-309"><a href="#LaggedAnalyser-309"><span class="linenos">309</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-310"><a href="#LaggedAnalyser-310"><span class="linenos">310</span></a><span class="sd">        *as_anomaly*</span>
</span><span id="LaggedAnalyser-311"><a href="#LaggedAnalyser-311"><span class="linenos">311</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-312"><a href="#LaggedAnalyser-312"><span class="linenos">312</span></a><span class="sd">        A Boolean, defining whether composites should be given as absolute values or differences from the unpartitioned value.</span>
</span><span id="LaggedAnalyser-313"><a href="#LaggedAnalyser-313"><span class="linenos">313</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-314"><a href="#LaggedAnalyser-314"><span class="linenos">314</span></a><span class="sd">        *con_func*</span>
</span><span id="LaggedAnalyser-315"><a href="#LaggedAnalyser-315"><span class="linenos">315</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-316"><a href="#LaggedAnalyser-316"><span class="linenos">316</span></a><span class="sd">        The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser-317"><a href="#LaggedAnalyser-317"><span class="linenos">317</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-318"><a href="#LaggedAnalyser-318"><span class="linenos">318</span></a><span class="sd">        *cat_func*</span>
</span><span id="LaggedAnalyser-319"><a href="#LaggedAnalyser-319"><span class="linenos">319</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-320"><a href="#LaggedAnalyser-320"><span class="linenos">320</span></a><span class="sd">        The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then categorical variables will be ignored</span>
</span><span id="LaggedAnalyser-321"><a href="#LaggedAnalyser-321"><span class="linenos">321</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-322"><a href="#LaggedAnalyser-322"><span class="linenos">322</span></a><span class="sd">        *inplace*</span>
</span><span id="LaggedAnalyser-323"><a href="#LaggedAnalyser-323"><span class="linenos">323</span></a><span class="sd">    </span>
</span><span id="LaggedAnalyser-324"><a href="#LaggedAnalyser-324"><span class="linenos">324</span></a><span class="sd">        A boolean, defining whether the composite should be stored in *LaggedAnalyser.composites*</span>
</span><span id="LaggedAnalyser-325"><a href="#LaggedAnalyser-325"><span class="linenos">325</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-326"><a href="#LaggedAnalyser-326"><span class="linenos">326</span></a><span class="sd">        **returns**</span>
</span><span id="LaggedAnalyser-327"><a href="#LaggedAnalyser-327"><span class="linenos">327</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-328"><a href="#LaggedAnalyser-328"><span class="linenos">328</span></a><span class="sd">        An xarray.Dataset like  *LaggedAnalyser.variables* but summarised according to *con_func* and *cat_func*, and with an additional coordinate *index_val*, which indexes over the values taken by *LaggedAnalyser.event*.</span>
</span><span id="LaggedAnalyser-329"><a href="#LaggedAnalyser-329"><span class="linenos">329</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-330"><a href="#LaggedAnalyser-330"><span class="linenos">330</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-331"><a href="#LaggedAnalyser-331"><span class="linenos">331</span></a>        <span class="n">composite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_aggregate_over_lags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="LaggedAnalyser-332"><a href="#LaggedAnalyser-332"><span class="linenos">332</span></a>        <span class="n">lagged_means</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aggregate_variables</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="LaggedAnalyser-333"><a href="#LaggedAnalyser-333"><span class="linenos">333</span></a>
</span><span id="LaggedAnalyser-334"><a href="#LaggedAnalyser-334"><span class="linenos">334</span></a>        <span class="k">if</span> <span class="n">as_anomaly</span><span class="p">:</span>
</span><span id="LaggedAnalyser-335"><a href="#LaggedAnalyser-335"><span class="linenos">335</span></a>            <span class="n">composite</span><span class="o">=</span><span class="n">composite</span><span class="o">-</span><span class="n">lagged_means</span>
</span><span id="LaggedAnalyser-336"><a href="#LaggedAnalyser-336"><span class="linenos">336</span></a>            
</span><span id="LaggedAnalyser-337"><a href="#LaggedAnalyser-337"><span class="linenos">337</span></a>        <span class="n">composite</span><span class="o">=</span><span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">composite</span><span class="p">)</span>
</span><span id="LaggedAnalyser-338"><a href="#LaggedAnalyser-338"><span class="linenos">338</span></a>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">composite</span><span class="o">.</span><span class="n">data_vars</span><span class="p">):</span>
</span><span id="LaggedAnalyser-339"><a href="#LaggedAnalyser-339"><span class="linenos">339</span></a>            <span class="n">composite</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span>
</span><span id="LaggedAnalyser-340"><a href="#LaggedAnalyser-340"><span class="linenos">340</span></a>        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
</span><span id="LaggedAnalyser-341"><a href="#LaggedAnalyser-341"><span class="linenos">341</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="o">=</span><span class="n">composite</span>
</span><span id="LaggedAnalyser-342"><a href="#LaggedAnalyser-342"><span class="linenos">342</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">composite_func</span><span class="o">=</span><span class="p">(</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="LaggedAnalyser-343"><a href="#LaggedAnalyser-343"><span class="linenos">343</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">composites_are_anomaly</span><span class="o">=</span><span class="n">as_anomaly</span>
</span><span id="LaggedAnalyser-344"><a href="#LaggedAnalyser-344"><span class="linenos">344</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="o">=</span><span class="n">lagged_means</span>
</span><span id="LaggedAnalyser-345"><a href="#LaggedAnalyser-345"><span class="linenos">345</span></a>        <span class="k">return</span> <span class="n">composite</span>
</span><span id="LaggedAnalyser-346"><a href="#LaggedAnalyser-346"><span class="linenos">346</span></a>
</span><span id="LaggedAnalyser-347"><a href="#LaggedAnalyser-347"><span class="linenos">347</span></a>    <span class="c1">#Aggregates variables over all time points where event is defined, regardless of its value</span>
</span><span id="LaggedAnalyser-348"><a href="#LaggedAnalyser-348"><span class="linenos">348</span></a>    <span class="k">def</span> <span class="nf">aggregate_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">lag_vals</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">con_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">mean_ds</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">cat_occ_ds</span><span class="p">):</span>
</span><span id="LaggedAnalyser-349"><a href="#LaggedAnalyser-349"><span class="linenos">349</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser-350"><a href="#LaggedAnalyser-350"><span class="linenos">350</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates a summary metric from *LaggedAnalyser.variables* at all points where *LaggedAnalyser.event* is defined, regardless of its value.</span>
</span><span id="LaggedAnalyser-351"><a href="#LaggedAnalyser-351"><span class="linenos">351</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-352"><a href="#LaggedAnalyser-352"><span class="linenos">352</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser-353"><a href="#LaggedAnalyser-353"><span class="linenos">353</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-354"><a href="#LaggedAnalyser-354"><span class="linenos">354</span></a><span class="sd">        *dim*</span>
</span><span id="LaggedAnalyser-355"><a href="#LaggedAnalyser-355"><span class="linenos">355</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-356"><a href="#LaggedAnalyser-356"><span class="linenos">356</span></a><span class="sd">        A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*.</span>
</span><span id="LaggedAnalyser-357"><a href="#LaggedAnalyser-357"><span class="linenos">357</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-358"><a href="#LaggedAnalyser-358"><span class="linenos">358</span></a><span class="sd">        *lag_vals*</span>
</span><span id="LaggedAnalyser-359"><a href="#LaggedAnalyser-359"><span class="linenos">359</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-360"><a href="#LaggedAnalyser-360"><span class="linenos">360</span></a><span class="sd">        &#39;all&#39; or a iterable of integers, specifying for which lag values to compute the summary metric.</span>
</span><span id="LaggedAnalyser-361"><a href="#LaggedAnalyser-361"><span class="linenos">361</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-362"><a href="#LaggedAnalyser-362"><span class="linenos">362</span></a><span class="sd">        *con_func*</span>
</span><span id="LaggedAnalyser-363"><a href="#LaggedAnalyser-363"><span class="linenos">363</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-364"><a href="#LaggedAnalyser-364"><span class="linenos">364</span></a><span class="sd">        The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser-365"><a href="#LaggedAnalyser-365"><span class="linenos">365</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-366"><a href="#LaggedAnalyser-366"><span class="linenos">366</span></a><span class="sd">        *cat_func*</span>
</span><span id="LaggedAnalyser-367"><a href="#LaggedAnalyser-367"><span class="linenos">367</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-368"><a href="#LaggedAnalyser-368"><span class="linenos">368</span></a><span class="sd">        The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser-369"><a href="#LaggedAnalyser-369"><span class="linenos">369</span></a>
</span><span id="LaggedAnalyser-370"><a href="#LaggedAnalyser-370"><span class="linenos">370</span></a><span class="sd">        **returns**</span>
</span><span id="LaggedAnalyser-371"><a href="#LaggedAnalyser-371"><span class="linenos">371</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-372"><a href="#LaggedAnalyser-372"><span class="linenos">372</span></a><span class="sd">        An xarray.Dataset like  *LaggedAnalyser.variables* but summarised according to *con_func* and *cat_func*.</span>
</span><span id="LaggedAnalyser-373"><a href="#LaggedAnalyser-373"><span class="linenos">373</span></a>
</span><span id="LaggedAnalyser-374"><a href="#LaggedAnalyser-374"><span class="linenos">374</span></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-375"><a href="#LaggedAnalyser-375"><span class="linenos">375</span></a>        <span class="n">fake_event</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">))</span>
</span><span id="LaggedAnalyser-376"><a href="#LaggedAnalyser-376"><span class="linenos">376</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_aggregate_over_lags</span><span class="p">(</span><span class="n">fake_event</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">index_val</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span id="LaggedAnalyser-377"><a href="#LaggedAnalyser-377"><span class="linenos">377</span></a>
</span><span id="LaggedAnalyser-378"><a href="#LaggedAnalyser-378"><span class="linenos">378</span></a>    <span class="k">def</span> <span class="nf">add_derived_composite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser-379"><a href="#LaggedAnalyser-379"><span class="linenos">379</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies *func* to one or multiple composites to calculate composites of derived quantities, and additionally, stores *func* to allow derived bootstrap composites to be calculated. For linear quantities, where Ex[f(x)]==f(Ex[x]), then this can minimise redundant memory use.</span>
</span><span id="LaggedAnalyser-380"><a href="#LaggedAnalyser-380"><span class="linenos">380</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-381"><a href="#LaggedAnalyser-381"><span class="linenos">381</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser-382"><a href="#LaggedAnalyser-382"><span class="linenos">382</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-383"><a href="#LaggedAnalyser-383"><span class="linenos">383</span></a><span class="sd">        *name*</span>
</span><span id="LaggedAnalyser-384"><a href="#LaggedAnalyser-384"><span class="linenos">384</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-385"><a href="#LaggedAnalyser-385"><span class="linenos">385</span></a><span class="sd">        A string, providing the name of the new variable to add.</span>
</span><span id="LaggedAnalyser-386"><a href="#LaggedAnalyser-386"><span class="linenos">386</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-387"><a href="#LaggedAnalyser-387"><span class="linenos">387</span></a><span class="sd">        *func*</span>
</span><span id="LaggedAnalyser-388"><a href="#LaggedAnalyser-388"><span class="linenos">388</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-389"><a href="#LaggedAnalyser-389"><span class="linenos">389</span></a><span class="sd">         A callable which must take 1 or more xarray.DataArrays as inputs</span>
</span><span id="LaggedAnalyser-390"><a href="#LaggedAnalyser-390"><span class="linenos">390</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-391"><a href="#LaggedAnalyser-391"><span class="linenos">391</span></a><span class="sd">        *composite_vars*</span>
</span><span id="LaggedAnalyser-392"><a href="#LaggedAnalyser-392"><span class="linenos">392</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-393"><a href="#LaggedAnalyser-393"><span class="linenos">393</span></a><span class="sd">        An iterable of strings, of the same length as the number of arguments taken by *func*. Each string must be the name of a variable in *LaggedAnalyser.variables* which will be passed into *func* in order.</span>
</span><span id="LaggedAnalyser-394"><a href="#LaggedAnalyser-394"><span class="linenos">394</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-395"><a href="#LaggedAnalyser-395"><span class="linenos">395</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser-396"><a href="#LaggedAnalyser-396"><span class="linenos">396</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-397"><a href="#LaggedAnalyser-397"><span class="linenos">397</span></a><span class="sd">        *as_anomaly*</span>
</span><span id="LaggedAnalyser-398"><a href="#LaggedAnalyser-398"><span class="linenos">398</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-399"><a href="#LaggedAnalyser-399"><span class="linenos">399</span></a><span class="sd">        A boolean. Whether anomaly composites or full composites should be passed in to func.</span>
</span><span id="LaggedAnalyser-400"><a href="#LaggedAnalyser-400"><span class="linenos">400</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-401"><a href="#LaggedAnalyser-401"><span class="linenos">401</span></a>        
</span><span id="LaggedAnalyser-402"><a href="#LaggedAnalyser-402"><span class="linenos">402</span></a>        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">as_anomaly</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
</span><span id="LaggedAnalyser-403"><a href="#LaggedAnalyser-403"><span class="linenos">403</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;variable-specific anomalies not yet implemented&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser-404"><a href="#LaggedAnalyser-404"><span class="linenos">404</span></a>
</span><span id="LaggedAnalyser-405"><a href="#LaggedAnalyser-405"><span class="linenos">405</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="LaggedAnalyser-406"><a href="#LaggedAnalyser-406"><span class="linenos">406</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_derived_da</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="LaggedAnalyser-407"><a href="#LaggedAnalyser-407"><span class="linenos">407</span></a>        
</span><span id="LaggedAnalyser-408"><a href="#LaggedAnalyser-408"><span class="linenos">408</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-409"><a href="#LaggedAnalyser-409"><span class="linenos">409</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_derived_da</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="LaggedAnalyser-410"><a href="#LaggedAnalyser-410"><span class="linenos">410</span></a>            
</span><span id="LaggedAnalyser-411"><a href="#LaggedAnalyser-411"><span class="linenos">411</span></a>        <span class="k">return</span>
</span><span id="LaggedAnalyser-412"><a href="#LaggedAnalyser-412"><span class="linenos">412</span></a>
</span><span id="LaggedAnalyser-413"><a href="#LaggedAnalyser-413"><span class="linenos">413</span></a>    <span class="c1">### Compute bootstraps ###</span>
</span><span id="LaggedAnalyser-414"><a href="#LaggedAnalyser-414"><span class="linenos">414</span></a>    
</span><span id="LaggedAnalyser-415"><a href="#LaggedAnalyser-415"><span class="linenos">415</span></a>    <span class="c1">#Top level func</span>
</span><span id="LaggedAnalyser-416"><a href="#LaggedAnalyser-416"><span class="linenos">416</span></a>    <span class="k">def</span> <span class="nf">compute_bootstraps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">con_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">mean_ds</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">cat_occ_ds</span><span class="p">,</span><span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">synth_mode</span><span class="o">=</span><span class="s1">&#39;markov&#39;</span><span class="p">,</span><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">reuse_ixs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser-417"><a href="#LaggedAnalyser-417"><span class="linenos">417</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser-418"><a href="#LaggedAnalyser-418"><span class="linenos">418</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes composites from synthetic event indices, which can be used to assess whether composites are insignificant.</span>
</span><span id="LaggedAnalyser-419"><a href="#LaggedAnalyser-419"><span class="linenos">419</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-420"><a href="#LaggedAnalyser-420"><span class="linenos">420</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser-421"><a href="#LaggedAnalyser-421"><span class="linenos">421</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-422"><a href="#LaggedAnalyser-422"><span class="linenos">422</span></a><span class="sd">        *bootnum*</span>
</span><span id="LaggedAnalyser-423"><a href="#LaggedAnalyser-423"><span class="linenos">423</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-424"><a href="#LaggedAnalyser-424"><span class="linenos">424</span></a><span class="sd">        An integer, the number of bootstrapped composites to compute</span>
</span><span id="LaggedAnalyser-425"><a href="#LaggedAnalyser-425"><span class="linenos">425</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-426"><a href="#LaggedAnalyser-426"><span class="linenos">426</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser-427"><a href="#LaggedAnalyser-427"><span class="linenos">427</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-428"><a href="#LaggedAnalyser-428"><span class="linenos">428</span></a><span class="sd">        *dim*</span>
</span><span id="LaggedAnalyser-429"><a href="#LaggedAnalyser-429"><span class="linenos">429</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-430"><a href="#LaggedAnalyser-430"><span class="linenos">430</span></a><span class="sd">        A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*.</span>
</span><span id="LaggedAnalyser-431"><a href="#LaggedAnalyser-431"><span class="linenos">431</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-432"><a href="#LaggedAnalyser-432"><span class="linenos">432</span></a><span class="sd">        *con_func*</span>
</span><span id="LaggedAnalyser-433"><a href="#LaggedAnalyser-433"><span class="linenos">433</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-434"><a href="#LaggedAnalyser-434"><span class="linenos">434</span></a><span class="sd">        The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser-435"><a href="#LaggedAnalyser-435"><span class="linenos">435</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-436"><a href="#LaggedAnalyser-436"><span class="linenos">436</span></a><span class="sd">        *cat_func*</span>
</span><span id="LaggedAnalyser-437"><a href="#LaggedAnalyser-437"><span class="linenos">437</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-438"><a href="#LaggedAnalyser-438"><span class="linenos">438</span></a><span class="sd">        The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser-439"><a href="#LaggedAnalyser-439"><span class="linenos">439</span></a>
</span><span id="LaggedAnalyser-440"><a href="#LaggedAnalyser-440"><span class="linenos">440</span></a><span class="sd">        *lag*</span>
</span><span id="LaggedAnalyser-441"><a href="#LaggedAnalyser-441"><span class="linenos">441</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-442"><a href="#LaggedAnalyser-442"><span class="linenos">442</span></a><span class="sd">        An integer, specifying which lagged variables to use for the bootstraps. i.e. bootstraps for lag=90 will be from a completely different season than those for lag=0.</span>
</span><span id="LaggedAnalyser-443"><a href="#LaggedAnalyser-443"><span class="linenos">443</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-444"><a href="#LaggedAnalyser-444"><span class="linenos">444</span></a><span class="sd">        *synth_mode*</span>
</span><span id="LaggedAnalyser-445"><a href="#LaggedAnalyser-445"><span class="linenos">445</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-446"><a href="#LaggedAnalyser-446"><span class="linenos">446</span></a><span class="sd">        A string, specifying how synthetic event indices are to be computed. Valid options are:</span>
</span><span id="LaggedAnalyser-447"><a href="#LaggedAnalyser-447"><span class="linenos">447</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-448"><a href="#LaggedAnalyser-448"><span class="linenos">448</span></a><span class="sd">        &quot;random&quot;: </span>
</span><span id="LaggedAnalyser-449"><a href="#LaggedAnalyser-449"><span class="linenos">449</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-450"><a href="#LaggedAnalyser-450"><span class="linenos">450</span></a><span class="sd">        categorical values are randomly chosen with the same probability of occurrence as those found in *LaggedAnalyser.event*, but with no autocorrelation.</span>
</span><span id="LaggedAnalyser-451"><a href="#LaggedAnalyser-451"><span class="linenos">451</span></a>
</span><span id="LaggedAnalyser-452"><a href="#LaggedAnalyser-452"><span class="linenos">452</span></a><span class="sd">        &quot;markov&quot;: </span>
</span><span id="LaggedAnalyser-453"><a href="#LaggedAnalyser-453"><span class="linenos">453</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-454"><a href="#LaggedAnalyser-454"><span class="linenos">454</span></a><span class="sd">        A first order Markov chain is fitted to *LaggedAnalyser.event*, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than &quot;random&quot; and so should normally be used.</span>
</span><span id="LaggedAnalyser-455"><a href="#LaggedAnalyser-455"><span class="linenos">455</span></a>
</span><span id="LaggedAnalyser-456"><a href="#LaggedAnalyser-456"><span class="linenos">456</span></a><span class="sd">        &quot;shuffle&quot;: </span>
</span><span id="LaggedAnalyser-457"><a href="#LaggedAnalyser-457"><span class="linenos">457</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-458"><a href="#LaggedAnalyser-458"><span class="linenos">458</span></a><span class="sd">        The values are randomly reordered. This means that each value will occur exactly the same amount of times as in the original index, and so is ideal for particularly rare events or short series.</span>
</span><span id="LaggedAnalyser-459"><a href="#LaggedAnalyser-459"><span class="linenos">459</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-460"><a href="#LaggedAnalyser-460"><span class="linenos">460</span></a><span class="sd">        *data_vars*</span>
</span><span id="LaggedAnalyser-461"><a href="#LaggedAnalyser-461"><span class="linenos">461</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-462"><a href="#LaggedAnalyser-462"><span class="linenos">462</span></a><span class="sd">        An iterable of strings, specifying for which variables bootstraps should be computed.</span>
</span><span id="LaggedAnalyser-463"><a href="#LaggedAnalyser-463"><span class="linenos">463</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser-464"><a href="#LaggedAnalyser-464"><span class="linenos">464</span></a><span class="sd">        **returns**</span>
</span><span id="LaggedAnalyser-465"><a href="#LaggedAnalyser-465"><span class="linenos">465</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-466"><a href="#LaggedAnalyser-466"><span class="linenos">466</span></a><span class="sd">        An xarray.Dataset like *LaggedAnalyser.variables* but summarised according to *con_func* and *cat_func*, and with a new coordinate &#39;bootnum&#39; of length *bootnum*.</span>
</span><span id="LaggedAnalyser-467"><a href="#LaggedAnalyser-467"><span class="linenos">467</span></a>
</span><span id="LaggedAnalyser-468"><a href="#LaggedAnalyser-468"><span class="linenos">468</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-469"><a href="#LaggedAnalyser-469"><span class="linenos">469</span></a>        <span class="k">if</span> <span class="n">data_vars</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-470"><a href="#LaggedAnalyser-470"><span class="linenos">470</span></a>            <span class="n">data_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
</span><span id="LaggedAnalyser-471"><a href="#LaggedAnalyser-471"><span class="linenos">471</span></a>
</span><span id="LaggedAnalyser-472"><a href="#LaggedAnalyser-472"><span class="linenos">472</span></a>        <span class="n">boots</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_derived_boots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_bootstraps</span><span class="p">(</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">,</span><span class="n">reuse_ixs</span><span class="p">))</span>
</span><span id="LaggedAnalyser-473"><a href="#LaggedAnalyser-473"><span class="linenos">473</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">composites_are_anomaly</span><span class="p">:</span>
</span><span id="LaggedAnalyser-474"><a href="#LaggedAnalyser-474"><span class="linenos">474</span></a>            <span class="n">boots</span><span class="o">=</span><span class="n">boots</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">)</span>
</span><span id="LaggedAnalyser-475"><a href="#LaggedAnalyser-475"><span class="linenos">475</span></a>        <span class="k">return</span> <span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">boots</span><span class="p">)</span>
</span><span id="LaggedAnalyser-476"><a href="#LaggedAnalyser-476"><span class="linenos">476</span></a>    
</span><span id="LaggedAnalyser-477"><a href="#LaggedAnalyser-477"><span class="linenos">477</span></a>    
</span><span id="LaggedAnalyser-478"><a href="#LaggedAnalyser-478"><span class="linenos">478</span></a>    <span class="k">def</span> <span class="nf">_compute_derived_da</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">varnames</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">):</span>
</span><span id="LaggedAnalyser-479"><a href="#LaggedAnalyser-479"><span class="linenos">479</span></a>        <span class="k">if</span> <span class="n">as_anomaly</span><span class="p">:</span>
</span><span id="LaggedAnalyser-480"><a href="#LaggedAnalyser-480"><span class="linenos">480</span></a>            <span class="n">input_vars</span><span class="o">=</span><span class="p">[</span><span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varnames</span><span class="p">]</span>
</span><span id="LaggedAnalyser-481"><a href="#LaggedAnalyser-481"><span class="linenos">481</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-482"><a href="#LaggedAnalyser-482"><span class="linenos">482</span></a>            <span class="n">input_vars</span><span class="o">=</span><span class="p">[</span><span class="n">ds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">varnames</span><span class="p">]</span>
</span><span id="LaggedAnalyser-483"><a href="#LaggedAnalyser-483"><span class="linenos">483</span></a>        <span class="k">return</span> <span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">input_vars</span><span class="p">))</span>
</span><span id="LaggedAnalyser-484"><a href="#LaggedAnalyser-484"><span class="linenos">484</span></a>    
</span><span id="LaggedAnalyser-485"><a href="#LaggedAnalyser-485"><span class="linenos">485</span></a>    
</span><span id="LaggedAnalyser-486"><a href="#LaggedAnalyser-486"><span class="linenos">486</span></a>    <span class="k">def</span> <span class="nf">_add_derived_boots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">boots</span><span class="p">):</span>
</span><span id="LaggedAnalyser-487"><a href="#LaggedAnalyser-487"><span class="linenos">487</span></a>        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="p">:</span>
</span><span id="LaggedAnalyser-488"><a href="#LaggedAnalyser-488"><span class="linenos">488</span></a>            <span class="n">func</span><span class="p">,</span><span class="n">input_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="LaggedAnalyser-489"><a href="#LaggedAnalyser-489"><span class="linenos">489</span></a>            <span class="n">boots</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_derived_da</span><span class="p">(</span><span class="n">boots</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">input_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="LaggedAnalyser-490"><a href="#LaggedAnalyser-490"><span class="linenos">490</span></a>        <span class="k">return</span> <span class="n">boots</span>
</span><span id="LaggedAnalyser-491"><a href="#LaggedAnalyser-491"><span class="linenos">491</span></a>
</span><span id="LaggedAnalyser-492"><a href="#LaggedAnalyser-492"><span class="linenos">492</span></a>    <span class="k">def</span> <span class="nf">_compute_bootstraps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">,</span><span class="n">reuse_ixs</span><span class="p">):</span>
</span><span id="LaggedAnalyser-493"><a href="#LaggedAnalyser-493"><span class="linenos">493</span></a>
</span><span id="LaggedAnalyser-494"><a href="#LaggedAnalyser-494"><span class="linenos">494</span></a>        <span class="n">da</span><span class="p">,</span><span class="n">ds</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_variables</span><span class="p">(</span><span class="n">lag</span><span class="p">))</span>
</span><span id="LaggedAnalyser-495"><a href="#LaggedAnalyser-495"><span class="linenos">495</span></a>        <span class="n">ds</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="n">data_vars</span><span class="p">]</span>
</span><span id="LaggedAnalyser-496"><a href="#LaggedAnalyser-496"><span class="linenos">496</span></a>        
</span><span id="LaggedAnalyser-497"><a href="#LaggedAnalyser-497"><span class="linenos">497</span></a>        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">boot_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="ow">not</span> <span class="n">reuse_ixs</span><span class="p">):</span>
</span><span id="LaggedAnalyser-498"><a href="#LaggedAnalyser-498"><span class="linenos">498</span></a>            
</span><span id="LaggedAnalyser-499"><a href="#LaggedAnalyser-499"><span class="linenos">499</span></a>            <span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="p">,</span><span class="n">L</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_bootparams</span><span class="p">(</span><span class="n">da</span><span class="p">)</span>
</span><span id="LaggedAnalyser-500"><a href="#LaggedAnalyser-500"><span class="linenos">500</span></a>            <span class="n">ixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_synth_indices</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">da</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
</span><span id="LaggedAnalyser-501"><a href="#LaggedAnalyser-501"><span class="linenos">501</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">boot_indices</span><span class="o">=</span><span class="n">ixs</span>
</span><span id="LaggedAnalyser-502"><a href="#LaggedAnalyser-502"><span class="linenos">502</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-503"><a href="#LaggedAnalyser-503"><span class="linenos">503</span></a>            <span class="n">ixs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">boot_indices</span>
</span><span id="LaggedAnalyser-504"><a href="#LaggedAnalyser-504"><span class="linenos">504</span></a>            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reusing stored boot_indices, ignoring new boot parameters.&#39;</span><span class="p">)</span>
</span><span id="LaggedAnalyser-505"><a href="#LaggedAnalyser-505"><span class="linenos">505</span></a>        
</span><span id="LaggedAnalyser-506"><a href="#LaggedAnalyser-506"><span class="linenos">506</span></a>        <span class="n">boots</span><span class="o">=</span><span class="p">[</span><span class="n">make_all_dims_coords</span><span class="p">(</span>\
</span><span id="LaggedAnalyser-507"><a href="#LaggedAnalyser-507"><span class="linenos">507</span></a>                <span class="bp">self</span><span class="o">.</span><span class="n">_composite_from_ix</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span><span class="n">ds</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="p">)</span>\
</span><span id="LaggedAnalyser-508"><a href="#LaggedAnalyser-508"><span class="linenos">508</span></a>             <span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">ixs</span><span class="p">]</span>
</span><span id="LaggedAnalyser-509"><a href="#LaggedAnalyser-509"><span class="linenos">509</span></a>        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">boots</span><span class="p">,</span><span class="s1">&#39;boot_num&#39;</span><span class="p">)</span>
</span><span id="LaggedAnalyser-510"><a href="#LaggedAnalyser-510"><span class="linenos">510</span></a>    
</span><span id="LaggedAnalyser-511"><a href="#LaggedAnalyser-511"><span class="linenos">511</span></a>    <span class="c1">#Gets some necessary variables</span>
</span><span id="LaggedAnalyser-512"><a href="#LaggedAnalyser-512"><span class="linenos">512</span></a>    <span class="k">def</span> <span class="nf">_get_bootparams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">da</span><span class="p">):</span>
</span><span id="LaggedAnalyser-513"><a href="#LaggedAnalyser-513"><span class="linenos">513</span></a>        <span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">da</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="LaggedAnalyser-514"><a href="#LaggedAnalyser-514"><span class="linenos">514</span></a>        <span class="k">return</span> <span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">da</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">da</span><span class="p">)</span>
</span><span id="LaggedAnalyser-515"><a href="#LaggedAnalyser-515"><span class="linenos">515</span></a>    
</span><span id="LaggedAnalyser-516"><a href="#LaggedAnalyser-516"><span class="linenos">516</span></a>    <span class="c1">#compute indices</span>
</span><span id="LaggedAnalyser-517"><a href="#LaggedAnalyser-517"><span class="linenos">517</span></a>    <span class="k">def</span> <span class="nf">_get_synth_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="n">da</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">ix_vals</span><span class="p">,</span><span class="n">ix_probs</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
</span><span id="LaggedAnalyser-518"><a href="#LaggedAnalyser-518"><span class="linenos">518</span></a>        
</span><span id="LaggedAnalyser-519"><a href="#LaggedAnalyser-519"><span class="linenos">519</span></a>        <span class="n">ixs</span><span class="o">=</span><span class="p">[]</span>
</span><span id="LaggedAnalyser-520"><a href="#LaggedAnalyser-520"><span class="linenos">520</span></a>        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;markov&#39;</span><span class="p">:</span>
</span><span id="LaggedAnalyser-521"><a href="#LaggedAnalyser-521"><span class="linenos">521</span></a>            <span class="n">xs</span><span class="o">=</span><span class="n">split_to_contiguous</span><span class="p">(</span><span class="n">da</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span><span class="n">x_arr</span><span class="o">=</span><span class="n">da</span><span class="p">)</span>
</span><span id="LaggedAnalyser-522"><a href="#LaggedAnalyser-522"><span class="linenos">522</span></a>            <span class="n">T</span><span class="o">=</span><span class="n">get_transmat</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
</span><span id="LaggedAnalyser-523"><a href="#LaggedAnalyser-523"><span class="linenos">523</span></a>            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bootnum</span><span class="p">):</span>
</span><span id="LaggedAnalyser-524"><a href="#LaggedAnalyser-524"><span class="linenos">524</span></a>                <span class="n">ixs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">synthetic_states_from_transmat</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">L</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</span><span id="LaggedAnalyser-525"><a href="#LaggedAnalyser-525"><span class="linenos">525</span></a>                
</span><span id="LaggedAnalyser-526"><a href="#LaggedAnalyser-526"><span class="linenos">526</span></a>        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;random&#39;</span><span class="p">:</span>
</span><span id="LaggedAnalyser-527"><a href="#LaggedAnalyser-527"><span class="linenos">527</span></a>            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bootnum</span><span class="p">):</span>
</span><span id="LaggedAnalyser-528"><a href="#LaggedAnalyser-528"><span class="linenos">528</span></a>                <span class="n">ixs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ix_vals</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="n">L</span><span class="p">,</span><span class="n">p</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">ix_probs</span><span class="p">)))</span>
</span><span id="LaggedAnalyser-529"><a href="#LaggedAnalyser-529"><span class="linenos">529</span></a>                
</span><span id="LaggedAnalyser-530"><a href="#LaggedAnalyser-530"><span class="linenos">530</span></a>        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;shuffle&#39;</span><span class="p">:</span>
</span><span id="LaggedAnalyser-531"><a href="#LaggedAnalyser-531"><span class="linenos">531</span></a>            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">bootnum</span><span class="p">):</span>
</span><span id="LaggedAnalyser-532"><a href="#LaggedAnalyser-532"><span class="linenos">532</span></a>                <span class="n">ixv</span><span class="o">=</span><span class="n">index</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
</span><span id="LaggedAnalyser-533"><a href="#LaggedAnalyser-533"><span class="linenos">533</span></a>                <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">ixv</span><span class="p">)</span>
</span><span id="LaggedAnalyser-534"><a href="#LaggedAnalyser-534"><span class="linenos">534</span></a>                
</span><span id="LaggedAnalyser-535"><a href="#LaggedAnalyser-535"><span class="linenos">535</span></a>                <span class="n">ixs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ixv</span><span class="p">)</span>
</span><span id="LaggedAnalyser-536"><a href="#LaggedAnalyser-536"><span class="linenos">536</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-537"><a href="#LaggedAnalyser-537"><span class="linenos">537</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;synth_mode=</span><span class="si">{</span><span class="n">synth_mode</span><span class="si">}</span><span class="s1"> is not valid.&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser-538"><a href="#LaggedAnalyser-538"><span class="linenos">538</span></a>            
</span><span id="LaggedAnalyser-539"><a href="#LaggedAnalyser-539"><span class="linenos">539</span></a>        <span class="k">return</span> <span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">ix</span><span class="p">)</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">ixs</span><span class="p">]</span>
</span><span id="LaggedAnalyser-540"><a href="#LaggedAnalyser-540"><span class="linenos">540</span></a>        
</span><span id="LaggedAnalyser-541"><a href="#LaggedAnalyser-541"><span class="linenos">541</span></a>    <span class="c1">### apply significance test ###</span>
</span><span id="LaggedAnalyser-542"><a href="#LaggedAnalyser-542"><span class="linenos">542</span></a>    
</span><span id="LaggedAnalyser-543"><a href="#LaggedAnalyser-543"><span class="linenos">543</span></a>    <span class="k">def</span> <span class="nf">get_significance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootstraps</span><span class="p">,</span><span class="n">comp</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">hb_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser-544"><a href="#LaggedAnalyser-544"><span class="linenos">544</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser-545"><a href="#LaggedAnalyser-545"><span class="linenos">545</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes whether a composite is significant with respect to a given distribution of bootstrapped composites. </span>
</span><span id="LaggedAnalyser-546"><a href="#LaggedAnalyser-546"><span class="linenos">546</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-547"><a href="#LaggedAnalyser-547"><span class="linenos">547</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser-548"><a href="#LaggedAnalyser-548"><span class="linenos">548</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-549"><a href="#LaggedAnalyser-549"><span class="linenos">549</span></a><span class="sd">        *bootstraps*</span>
</span><span id="LaggedAnalyser-550"><a href="#LaggedAnalyser-550"><span class="linenos">550</span></a>
</span><span id="LaggedAnalyser-551"><a href="#LaggedAnalyser-551"><span class="linenos">551</span></a><span class="sd">        An xarray.Dataset with a coordinate &#39;bootnum&#39;, such as produced by *LaggedAnalyser.compute_bootstraps*</span>
</span><span id="LaggedAnalyser-552"><a href="#LaggedAnalyser-552"><span class="linenos">552</span></a>
</span><span id="LaggedAnalyser-553"><a href="#LaggedAnalyser-553"><span class="linenos">553</span></a><span class="sd">        *comp*</span>
</span><span id="LaggedAnalyser-554"><a href="#LaggedAnalyser-554"><span class="linenos">554</span></a>
</span><span id="LaggedAnalyser-555"><a href="#LaggedAnalyser-555"><span class="linenos">555</span></a><span class="sd">        An xarray Dataset of the same shape as *bootstraps* but without a &#39;bootnum&#39; coordinate. Missing or additional variables are allowed, and are simply ignored.</span>
</span><span id="LaggedAnalyser-556"><a href="#LaggedAnalyser-556"><span class="linenos">556</span></a><span class="sd">        *p*</span>
</span><span id="LaggedAnalyser-557"><a href="#LaggedAnalyser-557"><span class="linenos">557</span></a>
</span><span id="LaggedAnalyser-558"><a href="#LaggedAnalyser-558"><span class="linenos">558</span></a><span class="sd">        A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </span>
</span><span id="LaggedAnalyser-559"><a href="#LaggedAnalyser-559"><span class="linenos">559</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-560"><a href="#LaggedAnalyser-560"><span class="linenos">560</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser-561"><a href="#LaggedAnalyser-561"><span class="linenos">561</span></a>
</span><span id="LaggedAnalyser-562"><a href="#LaggedAnalyser-562"><span class="linenos">562</span></a><span class="sd">        *data_vars*</span>
</span><span id="LaggedAnalyser-563"><a href="#LaggedAnalyser-563"><span class="linenos">563</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-564"><a href="#LaggedAnalyser-564"><span class="linenos">564</span></a><span class="sd">        An iterable of strings, specifying for which variables significance should be computed.</span>
</span><span id="LaggedAnalyser-565"><a href="#LaggedAnalyser-565"><span class="linenos">565</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser-566"><a href="#LaggedAnalyser-566"><span class="linenos">566</span></a><span class="sd">        *hb_correction*</span>
</span><span id="LaggedAnalyser-567"><a href="#LaggedAnalyser-567"><span class="linenos">567</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-568"><a href="#LaggedAnalyser-568"><span class="linenos">568</span></a><span class="sd">        A Boolean, specifying whether a Holm-Bonferroni correction should be applied to *p*, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in *comp* independently, and so will have no impact on scalar variables.</span>
</span><span id="LaggedAnalyser-569"><a href="#LaggedAnalyser-569"><span class="linenos">569</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-570"><a href="#LaggedAnalyser-570"><span class="linenos">570</span></a><span class="sd">        **returns**</span>
</span><span id="LaggedAnalyser-571"><a href="#LaggedAnalyser-571"><span class="linenos">571</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-572"><a href="#LaggedAnalyser-572"><span class="linenos">572</span></a><span class="sd">        An xarray.Dataset like *comp* but with boolean data, specifying whether each feature of each variable passed the significance test.</span>
</span><span id="LaggedAnalyser-573"><a href="#LaggedAnalyser-573"><span class="linenos">573</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-574"><a href="#LaggedAnalyser-574"><span class="linenos">574</span></a>        <span class="k">if</span> <span class="n">data_vars</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-575"><a href="#LaggedAnalyser-575"><span class="linenos">575</span></a>            <span class="n">data_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">bootstraps</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
</span><span id="LaggedAnalyser-576"><a href="#LaggedAnalyser-576"><span class="linenos">576</span></a>
</span><span id="LaggedAnalyser-577"><a href="#LaggedAnalyser-577"><span class="linenos">577</span></a>        <span class="n">bootnum</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bootstraps</span><span class="o">.</span><span class="n">boot_num</span><span class="p">)</span>
</span><span id="LaggedAnalyser-578"><a href="#LaggedAnalyser-578"><span class="linenos">578</span></a>        <span class="n">comp</span><span class="o">=</span><span class="n">comp</span><span class="p">[</span><span class="n">data_vars</span><span class="p">]</span>
</span><span id="LaggedAnalyser-579"><a href="#LaggedAnalyser-579"><span class="linenos">579</span></a>        <span class="n">bootstraps</span><span class="o">=</span><span class="n">bootstraps</span><span class="p">[</span><span class="n">data_vars</span><span class="p">]</span>
</span><span id="LaggedAnalyser-580"><a href="#LaggedAnalyser-580"><span class="linenos">580</span></a>        <span class="n">frac</span><span class="o">=</span><span class="p">(</span><span class="n">comp</span><span class="o">&lt;</span><span class="n">bootstraps</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="s1">&#39;boot_num&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">bootnum</span>
</span><span id="LaggedAnalyser-581"><a href="#LaggedAnalyser-581"><span class="linenos">581</span></a>        <span class="n">pval_ds</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
</span><span id="LaggedAnalyser-582"><a href="#LaggedAnalyser-582"><span class="linenos">582</span></a>        <span class="k">if</span> <span class="n">hb_correction</span><span class="p">:</span>
</span><span id="LaggedAnalyser-583"><a href="#LaggedAnalyser-583"><span class="linenos">583</span></a>            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">pval_ds</span><span class="p">:</span>
</span><span id="LaggedAnalyser-584"><a href="#LaggedAnalyser-584"><span class="linenos">584</span></a>                <span class="n">corrected_pval</span><span class="o">=</span><span class="n">holm_bonferroni_correction</span><span class="p">(</span><span class="n">pval_ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">p</span><span class="p">)</span>\
</span><span id="LaggedAnalyser-585"><a href="#LaggedAnalyser-585"><span class="linenos">585</span></a>                            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pval_ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span><span id="LaggedAnalyser-586"><a href="#LaggedAnalyser-586"><span class="linenos">586</span></a>                <span class="n">pval_ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">corrected_pval</span>
</span><span id="LaggedAnalyser-587"><a href="#LaggedAnalyser-587"><span class="linenos">587</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-588"><a href="#LaggedAnalyser-588"><span class="linenos">588</span></a>            <span class="n">pval_ds</span><span class="o">=</span><span class="n">pval_ds</span><span class="o">&lt;</span><span class="n">p</span>
</span><span id="LaggedAnalyser-589"><a href="#LaggedAnalyser-589"><span class="linenos">589</span></a>            
</span><span id="LaggedAnalyser-590"><a href="#LaggedAnalyser-590"><span class="linenos">590</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span><span class="o">=</span><span class="n">pval_ds</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">lag</span><span class="o">=</span><span class="n">comp</span><span class="o">.</span><span class="n">lag</span><span class="p">)</span>
</span><span id="LaggedAnalyser-591"><a href="#LaggedAnalyser-591"><span class="linenos">591</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span>
</span><span id="LaggedAnalyser-592"><a href="#LaggedAnalyser-592"><span class="linenos">592</span></a>    
</span><span id="LaggedAnalyser-593"><a href="#LaggedAnalyser-593"><span class="linenos">593</span></a>    <span class="k">def</span> <span class="nf">bootstrap_significance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">synth_mode</span><span class="o">=</span><span class="s1">&#39;markov&#39;</span><span class="p">,</span><span class="n">reuse_lag0_boots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">hb_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser-594"><a href="#LaggedAnalyser-594"><span class="linenos">594</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser-595"><a href="#LaggedAnalyser-595"><span class="linenos">595</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;A wrapper around *compute_bootstraps* and *get_significance*, that calculates bootstraps and applies a significance test to a number of time lagged composites simulataneously.</span>
</span><span id="LaggedAnalyser-596"><a href="#LaggedAnalyser-596"><span class="linenos">596</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-597"><a href="#LaggedAnalyser-597"><span class="linenos">597</span></a><span class="sd">    **Arguments**</span>
</span><span id="LaggedAnalyser-598"><a href="#LaggedAnalyser-598"><span class="linenos">598</span></a>
</span><span id="LaggedAnalyser-599"><a href="#LaggedAnalyser-599"><span class="linenos">599</span></a><span class="sd">    *bootnum*</span>
</span><span id="LaggedAnalyser-600"><a href="#LaggedAnalyser-600"><span class="linenos">600</span></a>
</span><span id="LaggedAnalyser-601"><a href="#LaggedAnalyser-601"><span class="linenos">601</span></a><span class="sd">    An integer, the number of bootstrapped composites to compute</span>
</span><span id="LaggedAnalyser-602"><a href="#LaggedAnalyser-602"><span class="linenos">602</span></a>
</span><span id="LaggedAnalyser-603"><a href="#LaggedAnalyser-603"><span class="linenos">603</span></a><span class="sd">    *p*</span>
</span><span id="LaggedAnalyser-604"><a href="#LaggedAnalyser-604"><span class="linenos">604</span></a>
</span><span id="LaggedAnalyser-605"><a href="#LaggedAnalyser-605"><span class="linenos">605</span></a><span class="sd">    A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </span>
</span><span id="LaggedAnalyser-606"><a href="#LaggedAnalyser-606"><span class="linenos">606</span></a>
</span><span id="LaggedAnalyser-607"><a href="#LaggedAnalyser-607"><span class="linenos">607</span></a><span class="sd">    **Optional arguments**</span>
</span><span id="LaggedAnalyser-608"><a href="#LaggedAnalyser-608"><span class="linenos">608</span></a>
</span><span id="LaggedAnalyser-609"><a href="#LaggedAnalyser-609"><span class="linenos">609</span></a><span class="sd">    *dim*</span>
</span><span id="LaggedAnalyser-610"><a href="#LaggedAnalyser-610"><span class="linenos">610</span></a>
</span><span id="LaggedAnalyser-611"><a href="#LaggedAnalyser-611"><span class="linenos">611</span></a><span class="sd">    A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*.</span>
</span><span id="LaggedAnalyser-612"><a href="#LaggedAnalyser-612"><span class="linenos">612</span></a>
</span><span id="LaggedAnalyser-613"><a href="#LaggedAnalyser-613"><span class="linenos">613</span></a><span class="sd">    *synth_mode*</span>
</span><span id="LaggedAnalyser-614"><a href="#LaggedAnalyser-614"><span class="linenos">614</span></a>
</span><span id="LaggedAnalyser-615"><a href="#LaggedAnalyser-615"><span class="linenos">615</span></a><span class="sd">    A string, specifying how synthetic event indices are to be computed. Valid options are:</span>
</span><span id="LaggedAnalyser-616"><a href="#LaggedAnalyser-616"><span class="linenos">616</span></a><span class="sd">    &quot;random&quot;: categorical values are randomly chosen with the same probability of occurrence as those found in *LaggedAnalyser.event*, but with no autocorrelation.</span>
</span><span id="LaggedAnalyser-617"><a href="#LaggedAnalyser-617"><span class="linenos">617</span></a><span class="sd">    &#39;markov&#39;: A first order Markov chain is fitted to *LaggedAnalyser.event*, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than &quot;random&quot; and so should normally be used.</span>
</span><span id="LaggedAnalyser-618"><a href="#LaggedAnalyser-618"><span class="linenos">618</span></a>
</span><span id="LaggedAnalyser-619"><a href="#LaggedAnalyser-619"><span class="linenos">619</span></a><span class="sd">    *reuse_lag0_boots*</span>
</span><span id="LaggedAnalyser-620"><a href="#LaggedAnalyser-620"><span class="linenos">620</span></a><span class="sd">        A Boolean. If True, bootstraps are only computed for lag=0, and then used as a null distribution to assess all lagged composites. For variables which are approximately stationary across the lag timescale, then this is a good approximation and can increase performance. However if used incorrectly, it may lead to &#39;significant composites&#39; which simply reflect the seasonal cycle. if False, separate bootstraps are computed for all time lags.</span>
</span><span id="LaggedAnalyser-621"><a href="#LaggedAnalyser-621"><span class="linenos">621</span></a>
</span><span id="LaggedAnalyser-622"><a href="#LaggedAnalyser-622"><span class="linenos">622</span></a><span class="sd">    *data_vars*</span>
</span><span id="LaggedAnalyser-623"><a href="#LaggedAnalyser-623"><span class="linenos">623</span></a><span class="sd">        An iterable of strings, specifying for which variables significance should be computed.</span>
</span><span id="LaggedAnalyser-624"><a href="#LaggedAnalyser-624"><span class="linenos">624</span></a>
</span><span id="LaggedAnalyser-625"><a href="#LaggedAnalyser-625"><span class="linenos">625</span></a><span class="sd">    *hb_correction*</span>
</span><span id="LaggedAnalyser-626"><a href="#LaggedAnalyser-626"><span class="linenos">626</span></a><span class="sd">        A Boolean, specifying whether a Holm-Bonferroni correction should be applied to *p*, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in *comp* independently, and so will have no impact on scalar variables.</span>
</span><span id="LaggedAnalyser-627"><a href="#LaggedAnalyser-627"><span class="linenos">627</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-628"><a href="#LaggedAnalyser-628"><span class="linenos">628</span></a><span class="sd">    **returns**</span>
</span><span id="LaggedAnalyser-629"><a href="#LaggedAnalyser-629"><span class="linenos">629</span></a>
</span><span id="LaggedAnalyser-630"><a href="#LaggedAnalyser-630"><span class="linenos">630</span></a><span class="sd">    An xarray.Dataset like *LaggedAnalyser.variables* but with the *dim* dimension summarised according to *con_func* and *cat_func*, an additional *lag* coordinate, and with boolean data specifying whether each feature of each variable passed the significance test.</span>
</span><span id="LaggedAnalyser-631"><a href="#LaggedAnalyser-631"><span class="linenos">631</span></a>
</span><span id="LaggedAnalyser-632"><a href="#LaggedAnalyser-632"><span class="linenos">632</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-633"><a href="#LaggedAnalyser-633"><span class="linenos">633</span></a>        <span class="n">lag_vals</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)</span>
</span><span id="LaggedAnalyser-634"><a href="#LaggedAnalyser-634"><span class="linenos">634</span></a>        
</span><span id="LaggedAnalyser-635"><a href="#LaggedAnalyser-635"><span class="linenos">635</span></a>        <span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">composite_func</span>
</span><span id="LaggedAnalyser-636"><a href="#LaggedAnalyser-636"><span class="linenos">636</span></a>        
</span><span id="LaggedAnalyser-637"><a href="#LaggedAnalyser-637"><span class="linenos">637</span></a>        <span class="n">boots</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_bootstraps</span><span class="p">(</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">)</span>
</span><span id="LaggedAnalyser-638"><a href="#LaggedAnalyser-638"><span class="linenos">638</span></a>        
</span><span id="LaggedAnalyser-639"><a href="#LaggedAnalyser-639"><span class="linenos">639</span></a>        <span class="c1">#reuse_lag0_boots=True can substantially reduce run time!</span>
</span><span id="LaggedAnalyser-640"><a href="#LaggedAnalyser-640"><span class="linenos">640</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="n">reuse_lag0_boots</span><span class="p">:</span>
</span><span id="LaggedAnalyser-641"><a href="#LaggedAnalyser-641"><span class="linenos">641</span></a>                    <span class="n">boots</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">boots</span><span class="p">,</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_bootstraps</span><span class="p">(</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">)</span>\
</span><span id="LaggedAnalyser-642"><a href="#LaggedAnalyser-642"><span class="linenos">642</span></a>                        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lag_vals</span><span class="p">]],</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span>
</span><span id="LaggedAnalyser-643"><a href="#LaggedAnalyser-643"><span class="linenos">643</span></a>                
</span><span id="LaggedAnalyser-644"><a href="#LaggedAnalyser-644"><span class="linenos">644</span></a>        <span class="n">sig_composite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_significance</span><span class="p">(</span><span class="n">boots</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">data_vars</span><span class="p">,</span><span class="n">hb_correction</span><span class="o">=</span><span class="n">hb_correction</span><span class="p">)</span>
</span><span id="LaggedAnalyser-645"><a href="#LaggedAnalyser-645"><span class="linenos">645</span></a>        
</span><span id="LaggedAnalyser-646"><a href="#LaggedAnalyser-646"><span class="linenos">646</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span><span class="o">=</span><span class="n">sig_composite</span>
</span><span id="LaggedAnalyser-647"><a href="#LaggedAnalyser-647"><span class="linenos">647</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span>
</span><span id="LaggedAnalyser-648"><a href="#LaggedAnalyser-648"><span class="linenos">648</span></a>    
</span><span id="LaggedAnalyser-649"><a href="#LaggedAnalyser-649"><span class="linenos">649</span></a>    
</span><span id="LaggedAnalyser-650"><a href="#LaggedAnalyser-650"><span class="linenos">650</span></a>    <span class="k">def</span> <span class="nf">deseasonalise_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">variable_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">agg</span><span class="o">=</span><span class="s1">&#39;dayofyear&#39;</span><span class="p">,</span><span class="n">smooth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">coeffs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="LaggedAnalyser-651"><a href="#LaggedAnalyser-651"><span class="linenos">651</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes a seasonal cycle for each variable in *LaggedAnalyser.variables* and subtracts it inplace, turning *LaggedAnalyser.variables* into deseasonalised anomalies. The seasonal cycle is computed via temporal aggregation of each variable over a given period - by default the calendar day of the year. This cycle can then be smoothed with an n-point rolling average.</span>
</span><span id="LaggedAnalyser-652"><a href="#LaggedAnalyser-652"><span class="linenos">652</span></a>
</span><span id="LaggedAnalyser-653"><a href="#LaggedAnalyser-653"><span class="linenos">653</span></a><span class="sd">                **Optional arguments**</span>
</span><span id="LaggedAnalyser-654"><a href="#LaggedAnalyser-654"><span class="linenos">654</span></a>
</span><span id="LaggedAnalyser-655"><a href="#LaggedAnalyser-655"><span class="linenos">655</span></a><span class="sd">                *variable_list*</span>
</span><span id="LaggedAnalyser-656"><a href="#LaggedAnalyser-656"><span class="linenos">656</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser-657"><a href="#LaggedAnalyser-657"><span class="linenos">657</span></a><span class="sd">                A list of variables to deseasonalise. Defaults to all variables in the *LaggedAnalyser.variables*</span>
</span><span id="LaggedAnalyser-658"><a href="#LaggedAnalyser-658"><span class="linenos">658</span></a>
</span><span id="LaggedAnalyser-659"><a href="#LaggedAnalyser-659"><span class="linenos">659</span></a><span class="sd">                *dim*</span>
</span><span id="LaggedAnalyser-660"><a href="#LaggedAnalyser-660"><span class="linenos">660</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser-661"><a href="#LaggedAnalyser-661"><span class="linenos">661</span></a><span class="sd">                A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*, along which the seasonal cycle is computed. Currently, only timelike coordinates are supported.</span>
</span><span id="LaggedAnalyser-662"><a href="#LaggedAnalyser-662"><span class="linenos">662</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser-663"><a href="#LaggedAnalyser-663"><span class="linenos">663</span></a><span class="sd">                *agg*</span>
</span><span id="LaggedAnalyser-664"><a href="#LaggedAnalyser-664"><span class="linenos">664</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser-665"><a href="#LaggedAnalyser-665"><span class="linenos">665</span></a><span class="sd">                A string specifying the datetime-like field to aggregate over. Useful and supported values are &#39;season&#39;, &#39;month&#39;, &#39;weekofyear&#39;, and &#39;dayofyear&#39;</span>
</span><span id="LaggedAnalyser-666"><a href="#LaggedAnalyser-666"><span class="linenos">666</span></a><span class="sd">                    </span>
</span><span id="LaggedAnalyser-667"><a href="#LaggedAnalyser-667"><span class="linenos">667</span></a><span class="sd">                *smooth*</span>
</span><span id="LaggedAnalyser-668"><a href="#LaggedAnalyser-668"><span class="linenos">668</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser-669"><a href="#LaggedAnalyser-669"><span class="linenos">669</span></a><span class="sd">                An integer, specifying the size of the n-timestep centred rolling mean applied to the aggregated seasonal cycle. By default *smooth*=1 results in no smoothing.</span>
</span><span id="LaggedAnalyser-670"><a href="#LaggedAnalyser-670"><span class="linenos">670</span></a>
</span><span id="LaggedAnalyser-671"><a href="#LaggedAnalyser-671"><span class="linenos">671</span></a><span class="sd">                *coeffs*</span>
</span><span id="LaggedAnalyser-672"><a href="#LaggedAnalyser-672"><span class="linenos">672</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser-673"><a href="#LaggedAnalyser-673"><span class="linenos">673</span></a><span class="sd">                A Dataset containing a precomputed seasonal cycle, which, if *LaggedAnalyser.variables* has coordinates (*dim*,[X,Y,...,Z]), has coords (*agg*,[X,Y,...,Z]), and has the same data variables as *LaggedAnalyser.variables*. If *coeffs* is provided, no seasonal cycle is fitted to *LaggedAnalyser.variables*, *coeffs* is used instead.</span>
</span><span id="LaggedAnalyser-674"><a href="#LaggedAnalyser-674"><span class="linenos">674</span></a>
</span><span id="LaggedAnalyser-675"><a href="#LaggedAnalyser-675"><span class="linenos">675</span></a><span class="sd">        &quot;&quot;&quot;</span>        
</span><span id="LaggedAnalyser-676"><a href="#LaggedAnalyser-676"><span class="linenos">676</span></a>
</span><span id="LaggedAnalyser-677"><a href="#LaggedAnalyser-677"><span class="linenos">677</span></a>        <span class="k">if</span> <span class="n">variable_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-678"><a href="#LaggedAnalyser-678"><span class="linenos">678</span></a>            <span class="n">variable_list</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
</span><span id="LaggedAnalyser-679"><a href="#LaggedAnalyser-679"><span class="linenos">679</span></a>        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">:</span>
</span><span id="LaggedAnalyser-680"><a href="#LaggedAnalyser-680"><span class="linenos">680</span></a>            <span class="n">da</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="LaggedAnalyser-681"><a href="#LaggedAnalyser-681"><span class="linenos">681</span></a>            <span class="n">dsnlsr</span><span class="o">=</span><span class="n">Agg_Deseasonaliser</span><span class="p">()</span>
</span><span id="LaggedAnalyser-682"><a href="#LaggedAnalyser-682"><span class="linenos">682</span></a>            <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser-683"><a href="#LaggedAnalyser-683"><span class="linenos">683</span></a>                <span class="n">dsnlsr</span><span class="o">.</span><span class="n">fit_cycle</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span><span class="n">agg</span><span class="o">=</span><span class="n">agg</span><span class="p">)</span>
</span><span id="LaggedAnalyser-684"><a href="#LaggedAnalyser-684"><span class="linenos">684</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser-685"><a href="#LaggedAnalyser-685"><span class="linenos">685</span></a>                <span class="n">dsnslr</span><span class="o">.</span><span class="n">cycle_coeffs</span><span class="o">=</span><span class="n">coeffs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="LaggedAnalyser-686"><a href="#LaggedAnalyser-686"><span class="linenos">686</span></a>
</span><span id="LaggedAnalyser-687"><a href="#LaggedAnalyser-687"><span class="linenos">687</span></a>            <span class="n">cycle</span><span class="o">=</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">evaluate_cycle</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">da</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
</span><span id="LaggedAnalyser-688"><a href="#LaggedAnalyser-688"><span class="linenos">688</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">data</span><span class="o">-</span><span class="n">cycle</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</span><span id="LaggedAnalyser-689"><a href="#LaggedAnalyser-689"><span class="linenos">689</span></a>            <span class="n">dsnlsr</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span> <span class="c1">#Prevents excess memory storage</span>
</span><span id="LaggedAnalyser-690"><a href="#LaggedAnalyser-690"><span class="linenos">690</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">dsnlsr</span>
</span><span id="LaggedAnalyser-691"><a href="#LaggedAnalyser-691"><span class="linenos">691</span></a>        <span class="k">return</span>   
</span><span id="LaggedAnalyser-692"><a href="#LaggedAnalyser-692"><span class="linenos">692</span></a>    
</span><span id="LaggedAnalyser-693"><a href="#LaggedAnalyser-693"><span class="linenos">693</span></a>    <span class="k">def</span> <span class="nf">get_seasonal_cycle_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="LaggedAnalyser-694"><a href="#LaggedAnalyser-694"><span class="linenos">694</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Retrieve seasonal cycle coeffs computed with *LaggedAnalyser.deseasonalise_variables*, suitable for passing into *coeffs* in other *LaggedAnalyser.deseasonalise_variables* function calls as a precomputed cycle.</span>
</span><span id="LaggedAnalyser-695"><a href="#LaggedAnalyser-695"><span class="linenos">695</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser-696"><a href="#LaggedAnalyser-696"><span class="linenos">696</span></a><span class="sd">        **Returns**</span>
</span><span id="LaggedAnalyser-697"><a href="#LaggedAnalyser-697"><span class="linenos">697</span></a><span class="sd">        An xarray.Dataset, as specified in  the *LaggedAnalyser.deseasonalise_variables* *coeff* optional keyword.</span>
</span><span id="LaggedAnalyser-698"><a href="#LaggedAnalyser-698"><span class="linenos">698</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-699"><a href="#LaggedAnalyser-699"><span class="linenos">699</span></a>        <span class="n">coeffs</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">({</span><span class="n">v</span><span class="p">:</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">cycle_coeffs</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">dsnlsr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
</span><span id="LaggedAnalyser-700"><a href="#LaggedAnalyser-700"><span class="linenos">700</span></a>        <span class="k">return</span> <span class="n">coeffs</span>
</span><span id="LaggedAnalyser-701"><a href="#LaggedAnalyser-701"><span class="linenos">701</span></a>
</span><span id="LaggedAnalyser-702"><a href="#LaggedAnalyser-702"><span class="linenos">702</span></a>    <span class="c1">#If deseasonalise_variables has been called, then this func can be used to compute the</span>
</span><span id="LaggedAnalyser-703"><a href="#LaggedAnalyser-703"><span class="linenos">703</span></a>    <span class="c1">#seasonal mean state corresponding to a given composite. This mean state+ the composite</span>
</span><span id="LaggedAnalyser-704"><a href="#LaggedAnalyser-704"><span class="linenos">704</span></a>    <span class="c1"># produced by self.compute_composites gives the full field composite pattern.</span>
</span><span id="LaggedAnalyser-705"><a href="#LaggedAnalyser-705"><span class="linenos">705</span></a>    <span class="k">def</span> <span class="nf">get_composite_seasonal_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="LaggedAnalyser-706"><a href="#LaggedAnalyser-706"><span class="linenos">706</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-707"><a href="#LaggedAnalyser-707"><span class="linenos">707</span></a><span class="sd">        If *LaggedAnalyser.deseasonalise_variables* has been called, then this function returns the seasonal mean state corresponding to a given composite, given by a sum of the seasonal cycle weighted by the time-varying occurrence of each categorical value in *LaggedAnalyser.events*. This mean state + the deseasonalised anomaly composite</span>
</span><span id="LaggedAnalyser-708"><a href="#LaggedAnalyser-708"><span class="linenos">708</span></a><span class="sd">    produced by *LaggedAnalyser.compute_composites* then retrieves the full composite pattern.</span>
</span><span id="LaggedAnalyser-709"><a href="#LaggedAnalyser-709"><span class="linenos">709</span></a><span class="sd">    </span>
</span><span id="LaggedAnalyser-710"><a href="#LaggedAnalyser-710"><span class="linenos">710</span></a><span class="sd">    **Returns**</span>
</span><span id="LaggedAnalyser-711"><a href="#LaggedAnalyser-711"><span class="linenos">711</span></a><span class="sd">        An xarray.Dataset containing the composite seasonal mean values.</span>
</span><span id="LaggedAnalyser-712"><a href="#LaggedAnalyser-712"><span class="linenos">712</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser-713"><a href="#LaggedAnalyser-713"><span class="linenos">713</span></a>        <span class="n">variable_list</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="p">)</span>
</span><span id="LaggedAnalyser-714"><a href="#LaggedAnalyser-714"><span class="linenos">714</span></a>        <span class="n">ts</span><span class="o">=</span><span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">==</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">)}</span>
</span><span id="LaggedAnalyser-715"><a href="#LaggedAnalyser-715"><span class="linenos">715</span></a>        <span class="n">lags</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)])</span>
</span><span id="LaggedAnalyser-716"><a href="#LaggedAnalyser-716"><span class="linenos">716</span></a>        
</span><span id="LaggedAnalyser-717"><a href="#LaggedAnalyser-717"><span class="linenos">717</span></a>        <span class="n">mean_states</span><span class="o">=</span><span class="p">{}</span>
</span><span id="LaggedAnalyser-718"><a href="#LaggedAnalyser-718"><span class="linenos">718</span></a>        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">:</span>
</span><span id="LaggedAnalyser-719"><a href="#LaggedAnalyser-719"><span class="linenos">719</span></a>            <span class="n">dsnlsr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="LaggedAnalyser-720"><a href="#LaggedAnalyser-720"><span class="linenos">720</span></a>            <span class="n">agg</span><span class="o">=</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">agg</span>
</span><span id="LaggedAnalyser-721"><a href="#LaggedAnalyser-721"><span class="linenos">721</span></a>            <span class="n">mean_states</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>\
</span><span id="LaggedAnalyser-722"><a href="#LaggedAnalyser-722"><span class="linenos">722</span></a>                                 <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>\
</span><span id="LaggedAnalyser-723"><a href="#LaggedAnalyser-723"><span class="linenos">723</span></a>                                    <span class="bp">self</span><span class="o">.</span><span class="n">_lag_average_cycle</span><span class="p">(</span><span class="n">dsnlsr</span><span class="p">,</span><span class="n">agg</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>\
</span><span id="LaggedAnalyser-724"><a href="#LaggedAnalyser-724"><span class="linenos">724</span></a>                                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">],</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span>\
</span><span id="LaggedAnalyser-725"><a href="#LaggedAnalyser-725"><span class="linenos">725</span></a>                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span><span class="s1">&#39;index_val&#39;</span><span class="p">)</span>
</span><span id="LaggedAnalyser-726"><a href="#LaggedAnalyser-726"><span class="linenos">726</span></a>            
</span><span id="LaggedAnalyser-727"><a href="#LaggedAnalyser-727"><span class="linenos">727</span></a>        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">mean_states</span><span class="p">)</span>
</span><span id="LaggedAnalyser-728"><a href="#LaggedAnalyser-728"><span class="linenos">728</span></a>        
</span><span id="LaggedAnalyser-729"><a href="#LaggedAnalyser-729"><span class="linenos">729</span></a>    <span class="k">def</span> <span class="nf">_lag_average_cycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dsnlsr</span><span class="p">,</span><span class="n">agg</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
</span><span id="LaggedAnalyser-730"><a href="#LaggedAnalyser-730"><span class="linenos">730</span></a>        
</span><span id="LaggedAnalyser-731"><a href="#LaggedAnalyser-731"><span class="linenos">731</span></a>        <span class="n">dt</span><span class="o">=</span><span class="n">durel</span><span class="o">.</span><span class="n">relativedelta</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">offset_unit</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">l</span><span class="p">)})</span>
</span><span id="LaggedAnalyser-732"><a href="#LaggedAnalyser-732"><span class="linenos">732</span></a>        <span class="n">tvals</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span><span class="o">+</span><span class="n">dt</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
</span><span id="LaggedAnalyser-733"><a href="#LaggedAnalyser-733"><span class="linenos">733</span></a>        <span class="n">cycle_eval</span><span class="o">=</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">cycle_coeffs</span><span class="o">.</span><span class="n">sel</span><span class="p">({</span><span class="n">agg</span><span class="p">:</span><span class="nb">getattr</span><span class="p">(</span><span class="n">tvals</span><span class="p">,</span><span class="n">agg</span><span class="p">)})</span>
</span><span id="LaggedAnalyser-734"><a href="#LaggedAnalyser-734"><span class="linenos">734</span></a>        <span class="n">cycle_mean</span><span class="o">=</span><span class="n">cycle_eval</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;lag&#39;</span><span class="p">:</span><span class="n">l</span><span class="p">,</span><span class="s1">&#39;index_val&#39;</span><span class="p">:</span><span class="n">i</span><span class="p">})</span>
</span><span id="LaggedAnalyser-735"><a href="#LaggedAnalyser-735"><span class="linenos">735</span></a>        <span class="k">return</span> <span class="n">cycle_mean</span>
</span></pre></div>


            <div class="docstring"><p>Computes lagged composites of variables with respect to a categorical categorical event series, with support for bootstrap resampling to provide a non-parametric assessment of composite significance, and for deseasonalisation of variables.</p>

<p><strong>Arguments:</strong></p>

<p><em>event</em></p>

<p>An xarray.DataArray with one dimension taking on categorical values, each defining a class of event (or non-event).</p>

<p><strong>Optional arguments</strong></p>

<p><em>variables, name, is_categorical</em></p>

<p>Arguments for adding variables to the LaggedAnalyser. Identical behaviour to calling <em>LaggedAnalyser.add_variables</em> directly.</p>
</div>


                            <div id="LaggedAnalyser.__init__" class="classattr">
                                        <input id="LaggedAnalyser.__init__-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="name">LaggedAnalyser</span><span class="signature pdoc-code condensed">(<span class="param"><span class="n">event</span>, </span><span class="param"><span class="n">variables</span><span class="o">=</span><span class="kc">None</span>, </span><span class="param"><span class="n">name</span><span class="o">=</span><span class="kc">None</span>, </span><span class="param"><span class="n">is_categorical</span><span class="o">=</span><span class="kc">None</span></span>)</span>

                <label class="view-source-button" for="LaggedAnalyser.__init__-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.__init__"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.__init__-32"><a href="#LaggedAnalyser.__init__-32"><span class="linenos">32</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">event</span><span class="p">,</span><span class="n">variables</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">is_categorical</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="LaggedAnalyser.__init__-33"><a href="#LaggedAnalyser.__init__-33"><span class="linenos">33</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise a new LaggedAnalyser object.&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.__init__-34"><a href="#LaggedAnalyser.__init__-34"><span class="linenos">34</span></a>        
</span><span id="LaggedAnalyser.__init__-35"><a href="#LaggedAnalyser.__init__-35"><span class="linenos">35</span></a>        <span class="c1">#: event is a dataarray</span>
</span><span id="LaggedAnalyser.__init__-36"><a href="#LaggedAnalyser.__init__-36"><span class="linenos">36</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">event</span><span class="p">)</span><span class="c1">#: This is a docstring?</span>
</span><span id="LaggedAnalyser.__init__-37"><a href="#LaggedAnalyser.__init__-37"><span class="linenos">37</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.__init__-38"><a href="#LaggedAnalyser.__init__-38"><span class="linenos">38</span></a>        
</span><span id="LaggedAnalyser.__init__-39"><a href="#LaggedAnalyser.__init__-39"><span class="linenos">39</span></a>        <span class="c1">#variables are stored in a dataset, and can be added later,</span>
</span><span id="LaggedAnalyser.__init__-40"><a href="#LaggedAnalyser.__init__-40"><span class="linenos">40</span></a>        <span class="c1">#or passed as a DataArray, a Dataset or as a dict of DataArrays</span>
</span><span id="LaggedAnalyser.__init__-41"><a href="#LaggedAnalyser.__init__-41"><span class="linenos">41</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">event</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
</span><span id="LaggedAnalyser.__init__-42"><a href="#LaggedAnalyser.__init__-42"><span class="linenos">42</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.__init__-43"><a href="#LaggedAnalyser.__init__-43"><span class="linenos">43</span></a>
</span><span id="LaggedAnalyser.__init__-44"><a href="#LaggedAnalyser.__init__-44"><span class="linenos">44</span></a>        <span class="k">if</span> <span class="n">variables</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser.__init__-45"><a href="#LaggedAnalyser.__init__-45"><span class="linenos">45</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="kc">False</span><span class="p">)</span>
</span><span id="LaggedAnalyser.__init__-46"><a href="#LaggedAnalyser.__init__-46"><span class="linenos">46</span></a>            
</span><span id="LaggedAnalyser.__init__-47"><a href="#LaggedAnalyser.__init__-47"><span class="linenos">47</span></a>        <span class="c1">#Time lagged versions of the dataset self.variables will be stored here, with a key</span>
</span><span id="LaggedAnalyser.__init__-48"><a href="#LaggedAnalyser.__init__-48"><span class="linenos">48</span></a>        <span class="c1">#equal to the lag applied. Designed to be accessed by the self.lagged_variables function</span>
</span><span id="LaggedAnalyser.__init__-49"><a href="#LaggedAnalyser.__init__-49"><span class="linenos">49</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="o">=</span><span class="p">{}</span>
</span><span id="LaggedAnalyser.__init__-50"><a href="#LaggedAnalyser.__init__-50"><span class="linenos">50</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="o">=</span><span class="kc">None</span>
</span><span id="LaggedAnalyser.__init__-51"><a href="#LaggedAnalyser.__init__-51"><span class="linenos">51</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.__init__-52"><a href="#LaggedAnalyser.__init__-52"><span class="linenos">52</span></a>
</span><span id="LaggedAnalyser.__init__-53"><a href="#LaggedAnalyser.__init__-53"><span class="linenos">53</span></a>        <span class="c1">#variables that are a linear combination of other variables are more efficiently</span>
</span><span id="LaggedAnalyser.__init__-54"><a href="#LaggedAnalyser.__init__-54"><span class="linenos">54</span></a>        <span class="c1">#computed after compositing using the self.add_derived_composite method</span>
</span><span id="LaggedAnalyser.__init__-55"><a href="#LaggedAnalyser.__init__-55"><span class="linenos">55</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="o">=</span><span class="p">{}</span>
</span><span id="LaggedAnalyser.__init__-56"><a href="#LaggedAnalyser.__init__-56"><span class="linenos">56</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="o">=</span><span class="p">{}</span>
</span><span id="LaggedAnalyser.__init__-57"><a href="#LaggedAnalyser.__init__-57"><span class="linenos">57</span></a>        
</span><span id="LaggedAnalyser.__init__-58"><a href="#LaggedAnalyser.__init__-58"><span class="linenos">58</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composite_mask</span><span class="o">=</span><span class="kc">None</span>
</span><span id="LaggedAnalyser.__init__-59"><a href="#LaggedAnalyser.__init__-59"><span class="linenos">59</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.__init__-60"><a href="#LaggedAnalyser.__init__-60"><span class="linenos">60</span></a>
</span><span id="LaggedAnalyser.__init__-61"><a href="#LaggedAnalyser.__init__-61"><span class="linenos">61</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">boot_indices</span><span class="o">=</span><span class="kc">None</span>
</span><span id="LaggedAnalyser.__init__-62"><a href="#LaggedAnalyser.__init__-62"><span class="linenos">62</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.__init__-63"><a href="#LaggedAnalyser.__init__-63"><span class="linenos">63</span></a>
</span><span id="LaggedAnalyser.__init__-64"><a href="#LaggedAnalyser.__init__-64"><span class="linenos">64</span></a>        <span class="k">return</span>
</span></pre></div>


            <div class="docstring"><p>Initialise a new LaggedAnalyser object.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.add_variable" class="classattr">
                                        <input id="LaggedAnalyser.add_variable-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">add_variable</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">variables</span>,</span><span class="param">	<span class="n">name</span><span class="o">=</span><span class="kc">None</span>,</span><span class="param">	<span class="n">is_categorical</span><span class="o">=</span><span class="kc">None</span>,</span><span class="param">	<span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span>,</span><span class="param">	<span class="n">join_type</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.add_variable-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.add_variable"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.add_variable-83"><a href="#LaggedAnalyser.add_variable-83"><span class="linenos"> 83</span></a>    <span class="k">def</span> <span class="nf">add_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">variables</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">is_categorical</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">join_type</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">):</span>
</span><span id="LaggedAnalyser.add_variable-84"><a href="#LaggedAnalyser.add_variable-84"><span class="linenos"> 84</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Adds an additional variable to LaggedAnalyser.variables.</span>
</span><span id="LaggedAnalyser.add_variable-85"><a href="#LaggedAnalyser.add_variable-85"><span class="linenos"> 85</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-86"><a href="#LaggedAnalyser.add_variable-86"><span class="linenos"> 86</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser.add_variable-87"><a href="#LaggedAnalyser.add_variable-87"><span class="linenos"> 87</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-88"><a href="#LaggedAnalyser.add_variable-88"><span class="linenos"> 88</span></a><span class="sd">        *variables* </span>
</span><span id="LaggedAnalyser.add_variable-89"><a href="#LaggedAnalyser.add_variable-89"><span class="linenos"> 89</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-90"><a href="#LaggedAnalyser.add_variable-90"><span class="linenos"> 90</span></a><span class="sd">        An xarray.DataArray, xarray.Dataset or dictionary of xarray.DataArrays, containing data to be composited with respect to *event*. One of the coordinates of *variables* should have the same name as the coordinate of *events*. Stored internally as an xarray.Dataset. If a dictionary is passed, the DataArrays are joined according to the method *join_type* which defaults to &#39;outer&#39;.</span>
</span><span id="LaggedAnalyser.add_variable-91"><a href="#LaggedAnalyser.add_variable-91"><span class="linenos"> 91</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.add_variable-92"><a href="#LaggedAnalyser.add_variable-92"><span class="linenos"> 92</span></a><span class="sd">        **Optional Arguments**</span>
</span><span id="LaggedAnalyser.add_variable-93"><a href="#LaggedAnalyser.add_variable-93"><span class="linenos"> 93</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-94"><a href="#LaggedAnalyser.add_variable-94"><span class="linenos"> 94</span></a><span class="sd">        *name* </span>
</span><span id="LaggedAnalyser.add_variable-95"><a href="#LaggedAnalyser.add_variable-95"><span class="linenos"> 95</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-96"><a href="#LaggedAnalyser.add_variable-96"><span class="linenos"> 96</span></a><span class="sd">        A string. If *variables* is a single xarray.DataArray then *name* will be used as the name of the array in the LaggedAnalyser.variables DataArray. Otherwise ignored.</span>
</span><span id="LaggedAnalyser.add_variable-97"><a href="#LaggedAnalyser.add_variable-97"><span class="linenos"> 97</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-98"><a href="#LaggedAnalyser.add_variable-98"><span class="linenos"> 98</span></a><span class="sd">        *is_categorical* </span>
</span><span id="LaggedAnalyser.add_variable-99"><a href="#LaggedAnalyser.add_variable-99"><span class="linenos"> 99</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-100"><a href="#LaggedAnalyser.add_variable-100"><span class="linenos">100</span></a><span class="sd">        An integer, if *variables* is an xarray.DataArray, or else a dictionary of integers with keys corresponding to DataArrays in the xarray.Dataset/dictionary. 0 indicates that the variable is continuous, and 1 indicates that it is categorical. Note that continuous and categorical variables are by default composited differently (see LaggedAnalyser.compute_composites). Default assumption is all DataArrays are continuous, unless a DataAarray contains an &#39;is_categorical&#39; key in its DataArray.attrs, in which case this value is used.</span>
</span><span id="LaggedAnalyser.add_variable-101"><a href="#LaggedAnalyser.add_variable-101"><span class="linenos">101</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.add_variable-102"><a href="#LaggedAnalyser.add_variable-102"><span class="linenos">102</span></a><span class="sd">        *overwrite*</span>
</span><span id="LaggedAnalyser.add_variable-103"><a href="#LaggedAnalyser.add_variable-103"><span class="linenos">103</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-104"><a href="#LaggedAnalyser.add_variable-104"><span class="linenos">104</span></a><span class="sd">        A boolean. If False then attempts to assign a variable who&#39;s name is already in *LaggedAnalyser.variables* will raise a ValueError</span>
</span><span id="LaggedAnalyser.add_variable-105"><a href="#LaggedAnalyser.add_variable-105"><span class="linenos">105</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-106"><a href="#LaggedAnalyser.add_variable-106"><span class="linenos">106</span></a><span class="sd">        *join_type*</span>
</span><span id="LaggedAnalyser.add_variable-107"><a href="#LaggedAnalyser.add_variable-107"><span class="linenos">107</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_variable-108"><a href="#LaggedAnalyser.add_variable-108"><span class="linenos">108</span></a><span class="sd">        A string setting the rules for how differences in the coordinate indices of different variables are handled:</span>
</span><span id="LaggedAnalyser.add_variable-109"><a href="#LaggedAnalyser.add_variable-109"><span class="linenos">109</span></a><span class="sd">        outer: use the union of object indexes</span>
</span><span id="LaggedAnalyser.add_variable-110"><a href="#LaggedAnalyser.add_variable-110"><span class="linenos">110</span></a><span class="sd">        inner: use the intersection of object indexes</span>
</span><span id="LaggedAnalyser.add_variable-111"><a href="#LaggedAnalyser.add_variable-111"><span class="linenos">111</span></a>
</span><span id="LaggedAnalyser.add_variable-112"><a href="#LaggedAnalyser.add_variable-112"><span class="linenos">112</span></a><span class="sd">        left: use indexes from the pre-existing *LaggedAnalyser.variables* with each dimension</span>
</span><span id="LaggedAnalyser.add_variable-113"><a href="#LaggedAnalyser.add_variable-113"><span class="linenos">113</span></a>
</span><span id="LaggedAnalyser.add_variable-114"><a href="#LaggedAnalyser.add_variable-114"><span class="linenos">114</span></a><span class="sd">        right: use indexes from the new *variables* with each dimension</span>
</span><span id="LaggedAnalyser.add_variable-115"><a href="#LaggedAnalyser.add_variable-115"><span class="linenos">115</span></a>
</span><span id="LaggedAnalyser.add_variable-116"><a href="#LaggedAnalyser.add_variable-116"><span class="linenos">116</span></a><span class="sd">        exact: instead of aligning, raise ValueError when indexes to be aligned are not equal</span>
</span><span id="LaggedAnalyser.add_variable-117"><a href="#LaggedAnalyser.add_variable-117"><span class="linenos">117</span></a>
</span><span id="LaggedAnalyser.add_variable-118"><a href="#LaggedAnalyser.add_variable-118"><span class="linenos">118</span></a><span class="sd">        override: if indexes are of same size, rewrite indexes to be those of the pre-existing *LaggedAnalyser.variables*. Indexes for the same dimension must have the same size in all objects.</span>
</span><span id="LaggedAnalyser.add_variable-119"><a href="#LaggedAnalyser.add_variable-119"><span class="linenos">119</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.add_variable-120"><a href="#LaggedAnalyser.add_variable-120"><span class="linenos">120</span></a>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
</span><span id="LaggedAnalyser.add_variable-121"><a href="#LaggedAnalyser.add_variable-121"><span class="linenos">121</span></a>            
</span><span id="LaggedAnalyser.add_variable-122"><a href="#LaggedAnalyser.add_variable-122"><span class="linenos">122</span></a>            <span class="k">if</span> <span class="n">is_categorical</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser.add_variable-123"><a href="#LaggedAnalyser.add_variable-123"><span class="linenos">123</span></a>                <span class="n">is_categorical</span><span class="o">=</span><span class="p">{</span><span class="n">v</span><span class="p">:</span><span class="kc">None</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">}</span>
</span><span id="LaggedAnalyser.add_variable-124"><a href="#LaggedAnalyser.add_variable-124"><span class="linenos">124</span></a>                
</span><span id="LaggedAnalyser.add_variable-125"><a href="#LaggedAnalyser.add_variable-125"><span class="linenos">125</span></a>            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_variable</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">[</span><span class="n">v</span><span class="p">],</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">da</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
</span><span id="LaggedAnalyser.add_variable-126"><a href="#LaggedAnalyser.add_variable-126"><span class="linenos">126</span></a>            
</span><span id="LaggedAnalyser.add_variable-127"><a href="#LaggedAnalyser.add_variable-127"><span class="linenos">127</span></a>        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
</span><span id="LaggedAnalyser.add_variable-128"><a href="#LaggedAnalyser.add_variable-128"><span class="linenos">128</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">add_variable</span><span class="p">({</span><span class="n">v</span><span class="p">:</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">data_vars</span><span class="p">},</span><span class="kc">None</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">)</span>
</span><span id="LaggedAnalyser.add_variable-129"><a href="#LaggedAnalyser.add_variable-129"><span class="linenos">129</span></a>            
</span><span id="LaggedAnalyser.add_variable-130"><a href="#LaggedAnalyser.add_variable-130"><span class="linenos">130</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser.add_variable-131"><a href="#LaggedAnalyser.add_variable-131"><span class="linenos">131</span></a>            
</span><span id="LaggedAnalyser.add_variable-132"><a href="#LaggedAnalyser.add_variable-132"><span class="linenos">132</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">_add_variable</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">is_categorical</span><span class="p">,</span><span class="n">overwrite</span><span class="p">,</span><span class="n">join_type</span><span class="p">)</span>            
</span><span id="LaggedAnalyser.add_variable-133"><a href="#LaggedAnalyser.add_variable-133"><span class="linenos">133</span></a>        <span class="k">return</span>
</span></pre></div>


            <div class="docstring"><p>Adds an additional variable to LaggedAnalyser.variables.</p>

<p><strong>Arguments</strong></p>

<p><em>variables</em> </p>

<p>An xarray.DataArray, xarray.Dataset or dictionary of xarray.DataArrays, containing data to be composited with respect to <em>event</em>. One of the coordinates of <em>variables</em> should have the same name as the coordinate of <em>events</em>. Stored internally as an xarray.Dataset. If a dictionary is passed, the DataArrays are joined according to the method <em>join_type</em> which defaults to 'outer'.</p>

<p><strong>Optional Arguments</strong></p>

<p><em>name</em> </p>

<p>A string. If <em>variables</em> is a single xarray.DataArray then <em>name</em> will be used as the name of the array in the LaggedAnalyser.variables DataArray. Otherwise ignored.</p>

<p><em>is_categorical</em> </p>

<p>An integer, if <em>variables</em> is an xarray.DataArray, or else a dictionary of integers with keys corresponding to DataArrays in the xarray.Dataset/dictionary. 0 indicates that the variable is continuous, and 1 indicates that it is categorical. Note that continuous and categorical variables are by default composited differently (see <a href="#LaggedAnalyser.compute_composites">LaggedAnalyser.compute_composites</a>). Default assumption is all DataArrays are continuous, unless a DataAarray contains an 'is_categorical' key in its DataArray.attrs, in which case this value is used.</p>

<p><em>overwrite</em></p>

<p>A boolean. If False then attempts to assign a variable who's name is already in <em>LaggedAnalyser.variables</em> will raise a ValueError</p>

<p><em>join_type</em></p>

<p>A string setting the rules for how differences in the coordinate indices of different variables are handled:
outer: use the union of object indexes
inner: use the intersection of object indexes</p>

<p>left: use indexes from the pre-existing <em>LaggedAnalyser.variables</em> with each dimension</p>

<p>right: use indexes from the new <em>variables</em> with each dimension</p>

<p>exact: instead of aligning, raise ValueError when indexes to be aligned are not equal</p>

<p>override: if indexes are of same size, rewrite indexes to be those of the pre-existing <em>LaggedAnalyser.variables</em>. Indexes for the same dimension must have the same size in all objects.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.lagged_variables" class="classattr">
                                        <input id="LaggedAnalyser.lagged_variables-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">lagged_variables</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">t</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.lagged_variables-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.lagged_variables"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.lagged_variables-157"><a href="#LaggedAnalyser.lagged_variables-157"><span class="linenos">157</span></a>    <span class="k">def</span> <span class="nf">lagged_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
</span><span id="LaggedAnalyser.lagged_variables-158"><a href="#LaggedAnalyser.lagged_variables-158"><span class="linenos">158</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;A convenience function that retrieves variables at lag *t* from the *LaggedAnalyser*&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.lagged_variables-159"><a href="#LaggedAnalyser.lagged_variables-159"><span class="linenos">159</span></a>        <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">:</span>
</span><span id="LaggedAnalyser.lagged_variables-160"><a href="#LaggedAnalyser.lagged_variables-160"><span class="linenos">160</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
</span><span id="LaggedAnalyser.lagged_variables-161"><a href="#LaggedAnalyser.lagged_variables-161"><span class="linenos">161</span></a>        <span class="k">elif</span> <span class="n">t</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
</span><span id="LaggedAnalyser.lagged_variables-162"><a href="#LaggedAnalyser.lagged_variables-162"><span class="linenos">162</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>
</span><span id="LaggedAnalyser.lagged_variables-163"><a href="#LaggedAnalyser.lagged_variables-163"><span class="linenos">163</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser.lagged_variables-164"><a href="#LaggedAnalyser.lagged_variables-164"><span class="linenos">164</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Lag </span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s1"> is not in self._lagged_variables.&#39;</span><span class="p">))</span>
</span></pre></div>


            <div class="docstring"><p>A convenience function that retrieves variables at lag <em>t</em> from the <em>LaggedAnalyser</em></p>
</div>


                            </div>
                            <div id="LaggedAnalyser.lag_variables" class="classattr">
                                        <input id="LaggedAnalyser.lag_variables-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">lag_variables</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">offsets</span>,</span><span class="param">	<span class="n">offset_unit</span><span class="o">=</span><span class="s1">&#39;days&#39;</span>,</span><span class="param">	<span class="n">offset_dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span>,</span><span class="param">	<span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span>,</span><span class="param">	<span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.lag_variables-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.lag_variables"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.lag_variables-185"><a href="#LaggedAnalyser.lag_variables-185"><span class="linenos">185</span></a>    <span class="k">def</span> <span class="nf">lag_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">offsets</span><span class="p">,</span><span class="n">offset_unit</span><span class="o">=</span><span class="s1">&#39;days&#39;</span><span class="p">,</span><span class="n">offset_dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser.lag_variables-186"><a href="#LaggedAnalyser.lag_variables-186"><span class="linenos">186</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Produces time lags of *LaggedAnalyser.variables*, which can be used to produce lagged composites.</span>
</span><span id="LaggedAnalyser.lag_variables-187"><a href="#LaggedAnalyser.lag_variables-187"><span class="linenos">187</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.lag_variables-188"><a href="#LaggedAnalyser.lag_variables-188"><span class="linenos">188</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser.lag_variables-189"><a href="#LaggedAnalyser.lag_variables-189"><span class="linenos">189</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.lag_variables-190"><a href="#LaggedAnalyser.lag_variables-190"><span class="linenos">190</span></a><span class="sd">        *offsets*</span>
</span><span id="LaggedAnalyser.lag_variables-191"><a href="#LaggedAnalyser.lag_variables-191"><span class="linenos">191</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.lag_variables-192"><a href="#LaggedAnalyser.lag_variables-192"><span class="linenos">192</span></a><span class="sd">        An iterable of integers which represent time lags at which to lag *LaggedAnalyser.variables* in the units specified by *offset_unit*. Positive offsets denote variables *preceding* the event.</span>
</span><span id="LaggedAnalyser.lag_variables-193"><a href="#LaggedAnalyser.lag_variables-193"><span class="linenos">193</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.lag_variables-194"><a href="#LaggedAnalyser.lag_variables-194"><span class="linenos">194</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser.lag_variables-195"><a href="#LaggedAnalyser.lag_variables-195"><span class="linenos">195</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.lag_variables-196"><a href="#LaggedAnalyser.lag_variables-196"><span class="linenos">196</span></a><span class="sd">        *offset_unit*</span>
</span><span id="LaggedAnalyser.lag_variables-197"><a href="#LaggedAnalyser.lag_variables-197"><span class="linenos">197</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.lag_variables-198"><a href="#LaggedAnalyser.lag_variables-198"><span class="linenos">198</span></a><span class="sd">        A string, defining the units of *offsets*. Valid options are weeks, days, hours, minutes, seconds, milliseconds, and microseconds.</span>
</span><span id="LaggedAnalyser.lag_variables-199"><a href="#LaggedAnalyser.lag_variables-199"><span class="linenos">199</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.lag_variables-200"><a href="#LaggedAnalyser.lag_variables-200"><span class="linenos">200</span></a><span class="sd">        *offset_dim*</span>
</span><span id="LaggedAnalyser.lag_variables-201"><a href="#LaggedAnalyser.lag_variables-201"><span class="linenos">201</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.lag_variables-202"><a href="#LaggedAnalyser.lag_variables-202"><span class="linenos">202</span></a><span class="sd">        A string, defining the coordinate of *LaggedAnalyser.variables* along which offsets are to be calculated.</span>
</span><span id="LaggedAnalyser.lag_variables-203"><a href="#LaggedAnalyser.lag_variables-203"><span class="linenos">203</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.lag_variables-204"><a href="#LaggedAnalyser.lag_variables-204"><span class="linenos">204</span></a><span class="sd">        *mode*</span>
</span><span id="LaggedAnalyser.lag_variables-205"><a href="#LaggedAnalyser.lag_variables-205"><span class="linenos">205</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.lag_variables-206"><a href="#LaggedAnalyser.lag_variables-206"><span class="linenos">206</span></a><span class="sd">        One of &#39;any&#39;, &#39;past&#39;, or &#39;future&#39;. If &#39;past&#39; or &#39;future&#39; is used then only positive or negative lags are valid, respectively.</span>
</span><span id="LaggedAnalyser.lag_variables-207"><a href="#LaggedAnalyser.lag_variables-207"><span class="linenos">207</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.lag_variables-208"><a href="#LaggedAnalyser.lag_variables-208"><span class="linenos">208</span></a><span class="sd">        *overwrite*</span>
</span><span id="LaggedAnalyser.lag_variables-209"><a href="#LaggedAnalyser.lag_variables-209"><span class="linenos">209</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.lag_variables-210"><a href="#LaggedAnalyser.lag_variables-210"><span class="linenos">210</span></a><span class="sd">        A boolean. If False, then attempts to produce a lag which already exist will raise a ValueError.</span>
</span><span id="LaggedAnalyser.lag_variables-211"><a href="#LaggedAnalyser.lag_variables-211"><span class="linenos">211</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.lag_variables-212"><a href="#LaggedAnalyser.lag_variables-212"><span class="linenos">212</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.lag_variables-213"><a href="#LaggedAnalyser.lag_variables-213"><span class="linenos">213</span></a>        <span class="n">time_type</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">is_time_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">offset_dim</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
</span><span id="LaggedAnalyser.lag_variables-214"><a href="#LaggedAnalyser.lag_variables-214"><span class="linenos">214</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">offset_unit</span><span class="o">=</span><span class="n">offset_unit</span>
</span><span id="LaggedAnalyser.lag_variables-215"><a href="#LaggedAnalyser.lag_variables-215"><span class="linenos">215</span></a>        <span class="n">lag_funcs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_ilag_variables</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">_lag_variables</span><span class="p">]</span>
</span><span id="LaggedAnalyser.lag_variables-216"><a href="#LaggedAnalyser.lag_variables-216"><span class="linenos">216</span></a>        <span class="n">offsets</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span>
</span><span id="LaggedAnalyser.lag_variables-217"><a href="#LaggedAnalyser.lag_variables-217"><span class="linenos">217</span></a>        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">:</span>
</span><span id="LaggedAnalyser.lag_variables-218"><a href="#LaggedAnalyser.lag_variables-218"><span class="linenos">218</span></a>            <span class="n">lag_funcs</span><span class="p">[</span><span class="n">time_type</span><span class="p">](</span><span class="nb">int</span><span class="p">(</span><span class="n">o</span><span class="p">),</span><span class="n">offset_unit</span><span class="p">,</span><span class="n">offset_dim</span><span class="p">,</span><span class="n">mode</span><span class="p">,</span><span class="n">overwrite</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Produces time lags of <em>LaggedAnalyser.variables</em>, which can be used to produce lagged composites.</p>

<p><strong>Arguments</strong></p>

<p><em>offsets</em></p>

<p>An iterable of integers which represent time lags at which to lag <em>LaggedAnalyser.variables</em> in the units specified by <em>offset_unit</em>. Positive offsets denote variables <em>preceding</em> the event.</p>

<p><strong>Optional arguments</strong></p>

<p><em>offset_unit</em></p>

<p>A string, defining the units of <em>offsets</em>. Valid options are weeks, days, hours, minutes, seconds, milliseconds, and microseconds.</p>

<p><em>offset_dim</em></p>

<p>A string, defining the coordinate of <em>LaggedAnalyser.variables</em> along which offsets are to be calculated.</p>

<p><em>mode</em></p>

<p>One of 'any', 'past', or 'future'. If 'past' or 'future' is used then only positive or negative lags are valid, respectively.</p>

<p><em>overwrite</em></p>

<p>A boolean. If False, then attempts to produce a lag which already exist will raise a ValueError.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.compute_composites" class="classattr">
                                        <input id="LaggedAnalyser.compute_composites-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">compute_composites</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span>,</span><span class="param">	<span class="n">lag_vals</span><span class="o">=</span><span class="s1">&#39;all&#39;</span>,</span><span class="param">	<span class="n">as_anomaly</span><span class="o">=</span><span class="kc">False</span>,</span><span class="param">	<span class="n">con_func</span><span class="o">=&lt;</span><span class="n">function</span> <span class="n">mean_ds</span><span class="o">&gt;</span>,</span><span class="param">	<span class="n">cat_func</span><span class="o">=&lt;</span><span class="n">function</span> <span class="n">cat_occ_ds</span><span class="o">&gt;</span>,</span><span class="param">	<span class="n">inplace</span><span class="o">=</span><span class="kc">True</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.compute_composites-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.compute_composites"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.compute_composites-295"><a href="#LaggedAnalyser.compute_composites-295"><span class="linenos">295</span></a>    <span class="k">def</span> <span class="nf">compute_composites</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">lag_vals</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">as_anomaly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">con_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">mean_ds</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">cat_occ_ds</span><span class="p">,</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
</span><span id="LaggedAnalyser.compute_composites-296"><a href="#LaggedAnalyser.compute_composites-296"><span class="linenos">296</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser.compute_composites-297"><a href="#LaggedAnalyser.compute_composites-297"><span class="linenos">297</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.compute_composites-298"><a href="#LaggedAnalyser.compute_composites-298"><span class="linenos">298</span></a><span class="sd">        Partitions *LaggedAnalyser.variables*, and any time-lagged equivalents, into subsets depending on the value of *LaggedAnalyser.event*, and then computes a bulk summary metric for each.</span>
</span><span id="LaggedAnalyser.compute_composites-299"><a href="#LaggedAnalyser.compute_composites-299"><span class="linenos">299</span></a>
</span><span id="LaggedAnalyser.compute_composites-300"><a href="#LaggedAnalyser.compute_composites-300"><span class="linenos">300</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser.compute_composites-301"><a href="#LaggedAnalyser.compute_composites-301"><span class="linenos">301</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_composites-302"><a href="#LaggedAnalyser.compute_composites-302"><span class="linenos">302</span></a><span class="sd">        *dim*</span>
</span><span id="LaggedAnalyser.compute_composites-303"><a href="#LaggedAnalyser.compute_composites-303"><span class="linenos">303</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_composites-304"><a href="#LaggedAnalyser.compute_composites-304"><span class="linenos">304</span></a><span class="sd">        A string, the coordinate along which to compute composites.</span>
</span><span id="LaggedAnalyser.compute_composites-305"><a href="#LaggedAnalyser.compute_composites-305"><span class="linenos">305</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_composites-306"><a href="#LaggedAnalyser.compute_composites-306"><span class="linenos">306</span></a><span class="sd">        *lag_vals*</span>
</span><span id="LaggedAnalyser.compute_composites-307"><a href="#LaggedAnalyser.compute_composites-307"><span class="linenos">307</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_composites-308"><a href="#LaggedAnalyser.compute_composites-308"><span class="linenos">308</span></a><span class="sd">        Either &#39;All&#39;, or a list of integers, denoting the time lags for which composites should be computed.</span>
</span><span id="LaggedAnalyser.compute_composites-309"><a href="#LaggedAnalyser.compute_composites-309"><span class="linenos">309</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_composites-310"><a href="#LaggedAnalyser.compute_composites-310"><span class="linenos">310</span></a><span class="sd">        *as_anomaly*</span>
</span><span id="LaggedAnalyser.compute_composites-311"><a href="#LaggedAnalyser.compute_composites-311"><span class="linenos">311</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_composites-312"><a href="#LaggedAnalyser.compute_composites-312"><span class="linenos">312</span></a><span class="sd">        A Boolean, defining whether composites should be given as absolute values or differences from the unpartitioned value.</span>
</span><span id="LaggedAnalyser.compute_composites-313"><a href="#LaggedAnalyser.compute_composites-313"><span class="linenos">313</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_composites-314"><a href="#LaggedAnalyser.compute_composites-314"><span class="linenos">314</span></a><span class="sd">        *con_func*</span>
</span><span id="LaggedAnalyser.compute_composites-315"><a href="#LaggedAnalyser.compute_composites-315"><span class="linenos">315</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_composites-316"><a href="#LaggedAnalyser.compute_composites-316"><span class="linenos">316</span></a><span class="sd">        The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser.compute_composites-317"><a href="#LaggedAnalyser.compute_composites-317"><span class="linenos">317</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_composites-318"><a href="#LaggedAnalyser.compute_composites-318"><span class="linenos">318</span></a><span class="sd">        *cat_func*</span>
</span><span id="LaggedAnalyser.compute_composites-319"><a href="#LaggedAnalyser.compute_composites-319"><span class="linenos">319</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_composites-320"><a href="#LaggedAnalyser.compute_composites-320"><span class="linenos">320</span></a><span class="sd">        The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then categorical variables will be ignored</span>
</span><span id="LaggedAnalyser.compute_composites-321"><a href="#LaggedAnalyser.compute_composites-321"><span class="linenos">321</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_composites-322"><a href="#LaggedAnalyser.compute_composites-322"><span class="linenos">322</span></a><span class="sd">        *inplace*</span>
</span><span id="LaggedAnalyser.compute_composites-323"><a href="#LaggedAnalyser.compute_composites-323"><span class="linenos">323</span></a><span class="sd">    </span>
</span><span id="LaggedAnalyser.compute_composites-324"><a href="#LaggedAnalyser.compute_composites-324"><span class="linenos">324</span></a><span class="sd">        A boolean, defining whether the composite should be stored in *LaggedAnalyser.composites*</span>
</span><span id="LaggedAnalyser.compute_composites-325"><a href="#LaggedAnalyser.compute_composites-325"><span class="linenos">325</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_composites-326"><a href="#LaggedAnalyser.compute_composites-326"><span class="linenos">326</span></a><span class="sd">        **returns**</span>
</span><span id="LaggedAnalyser.compute_composites-327"><a href="#LaggedAnalyser.compute_composites-327"><span class="linenos">327</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_composites-328"><a href="#LaggedAnalyser.compute_composites-328"><span class="linenos">328</span></a><span class="sd">        An xarray.Dataset like  *LaggedAnalyser.variables* but summarised according to *con_func* and *cat_func*, and with an additional coordinate *index_val*, which indexes over the values taken by *LaggedAnalyser.event*.</span>
</span><span id="LaggedAnalyser.compute_composites-329"><a href="#LaggedAnalyser.compute_composites-329"><span class="linenos">329</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_composites-330"><a href="#LaggedAnalyser.compute_composites-330"><span class="linenos">330</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.compute_composites-331"><a href="#LaggedAnalyser.compute_composites-331"><span class="linenos">331</span></a>        <span class="n">composite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_aggregate_over_lags</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="LaggedAnalyser.compute_composites-332"><a href="#LaggedAnalyser.compute_composites-332"><span class="linenos">332</span></a>        <span class="n">lagged_means</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">aggregate_variables</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="LaggedAnalyser.compute_composites-333"><a href="#LaggedAnalyser.compute_composites-333"><span class="linenos">333</span></a>
</span><span id="LaggedAnalyser.compute_composites-334"><a href="#LaggedAnalyser.compute_composites-334"><span class="linenos">334</span></a>        <span class="k">if</span> <span class="n">as_anomaly</span><span class="p">:</span>
</span><span id="LaggedAnalyser.compute_composites-335"><a href="#LaggedAnalyser.compute_composites-335"><span class="linenos">335</span></a>            <span class="n">composite</span><span class="o">=</span><span class="n">composite</span><span class="o">-</span><span class="n">lagged_means</span>
</span><span id="LaggedAnalyser.compute_composites-336"><a href="#LaggedAnalyser.compute_composites-336"><span class="linenos">336</span></a>            
</span><span id="LaggedAnalyser.compute_composites-337"><a href="#LaggedAnalyser.compute_composites-337"><span class="linenos">337</span></a>        <span class="n">composite</span><span class="o">=</span><span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">composite</span><span class="p">)</span>
</span><span id="LaggedAnalyser.compute_composites-338"><a href="#LaggedAnalyser.compute_composites-338"><span class="linenos">338</span></a>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">composite</span><span class="o">.</span><span class="n">data_vars</span><span class="p">):</span>
</span><span id="LaggedAnalyser.compute_composites-339"><a href="#LaggedAnalyser.compute_composites-339"><span class="linenos">339</span></a>            <span class="n">composite</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span>
</span><span id="LaggedAnalyser.compute_composites-340"><a href="#LaggedAnalyser.compute_composites-340"><span class="linenos">340</span></a>        <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
</span><span id="LaggedAnalyser.compute_composites-341"><a href="#LaggedAnalyser.compute_composites-341"><span class="linenos">341</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="o">=</span><span class="n">composite</span>
</span><span id="LaggedAnalyser.compute_composites-342"><a href="#LaggedAnalyser.compute_composites-342"><span class="linenos">342</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">composite_func</span><span class="o">=</span><span class="p">(</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span>
</span><span id="LaggedAnalyser.compute_composites-343"><a href="#LaggedAnalyser.compute_composites-343"><span class="linenos">343</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">composites_are_anomaly</span><span class="o">=</span><span class="n">as_anomaly</span>
</span><span id="LaggedAnalyser.compute_composites-344"><a href="#LaggedAnalyser.compute_composites-344"><span class="linenos">344</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="o">=</span><span class="n">lagged_means</span>
</span><span id="LaggedAnalyser.compute_composites-345"><a href="#LaggedAnalyser.compute_composites-345"><span class="linenos">345</span></a>        <span class="k">return</span> <span class="n">composite</span>
</span></pre></div>


            <div class="docstring"><p>Partitions <em>LaggedAnalyser.variables</em>, and any time-lagged equivalents, into subsets depending on the value of <em>LaggedAnalyser.event</em>, and then computes a bulk summary metric for each.</p>

<p><strong>Optional arguments</strong></p>

<p><em>dim</em></p>

<p>A string, the coordinate along which to compute composites.</p>

<p><em>lag_vals</em></p>

<p>Either 'All', or a list of integers, denoting the time lags for which composites should be computed.</p>

<p><em>as_anomaly</em></p>

<p>A Boolean, defining whether composites should be given as absolute values or differences from the unpartitioned value.</p>

<p><em>con_func</em></p>

<p>The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</p>

<p><em>cat_func</em></p>

<p>The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then categorical variables will be ignored</p>

<p><em>inplace</em></p>

<p>A boolean, defining whether the composite should be stored in <em>LaggedAnalyser.composites</em></p>

<p><strong>returns</strong></p>

<p>An xarray.Dataset like  <em>LaggedAnalyser.variables</em> but summarised according to <em>con_func</em> and <em>cat_func</em>, and with an additional coordinate <em>index_val</em>, which indexes over the values taken by <em>LaggedAnalyser.event</em>.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.aggregate_variables" class="classattr">
                                        <input id="LaggedAnalyser.aggregate_variables-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">aggregate_variables</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span>,</span><span class="param">	<span class="n">lag_vals</span><span class="o">=</span><span class="s1">&#39;all&#39;</span>,</span><span class="param">	<span class="n">con_func</span><span class="o">=&lt;</span><span class="n">function</span> <span class="n">mean_ds</span><span class="o">&gt;</span>,</span><span class="param">	<span class="n">cat_func</span><span class="o">=&lt;</span><span class="n">function</span> <span class="n">cat_occ_ds</span><span class="o">&gt;</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.aggregate_variables-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.aggregate_variables"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.aggregate_variables-348"><a href="#LaggedAnalyser.aggregate_variables-348"><span class="linenos">348</span></a>    <span class="k">def</span> <span class="nf">aggregate_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">lag_vals</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span><span class="n">con_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">mean_ds</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">cat_occ_ds</span><span class="p">):</span>
</span><span id="LaggedAnalyser.aggregate_variables-349"><a href="#LaggedAnalyser.aggregate_variables-349"><span class="linenos">349</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-350"><a href="#LaggedAnalyser.aggregate_variables-350"><span class="linenos">350</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates a summary metric from *LaggedAnalyser.variables* at all points where *LaggedAnalyser.event* is defined, regardless of its value.</span>
</span><span id="LaggedAnalyser.aggregate_variables-351"><a href="#LaggedAnalyser.aggregate_variables-351"><span class="linenos">351</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-352"><a href="#LaggedAnalyser.aggregate_variables-352"><span class="linenos">352</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser.aggregate_variables-353"><a href="#LaggedAnalyser.aggregate_variables-353"><span class="linenos">353</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-354"><a href="#LaggedAnalyser.aggregate_variables-354"><span class="linenos">354</span></a><span class="sd">        *dim*</span>
</span><span id="LaggedAnalyser.aggregate_variables-355"><a href="#LaggedAnalyser.aggregate_variables-355"><span class="linenos">355</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-356"><a href="#LaggedAnalyser.aggregate_variables-356"><span class="linenos">356</span></a><span class="sd">        A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*.</span>
</span><span id="LaggedAnalyser.aggregate_variables-357"><a href="#LaggedAnalyser.aggregate_variables-357"><span class="linenos">357</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-358"><a href="#LaggedAnalyser.aggregate_variables-358"><span class="linenos">358</span></a><span class="sd">        *lag_vals*</span>
</span><span id="LaggedAnalyser.aggregate_variables-359"><a href="#LaggedAnalyser.aggregate_variables-359"><span class="linenos">359</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-360"><a href="#LaggedAnalyser.aggregate_variables-360"><span class="linenos">360</span></a><span class="sd">        &#39;all&#39; or a iterable of integers, specifying for which lag values to compute the summary metric.</span>
</span><span id="LaggedAnalyser.aggregate_variables-361"><a href="#LaggedAnalyser.aggregate_variables-361"><span class="linenos">361</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-362"><a href="#LaggedAnalyser.aggregate_variables-362"><span class="linenos">362</span></a><span class="sd">        *con_func*</span>
</span><span id="LaggedAnalyser.aggregate_variables-363"><a href="#LaggedAnalyser.aggregate_variables-363"><span class="linenos">363</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-364"><a href="#LaggedAnalyser.aggregate_variables-364"><span class="linenos">364</span></a><span class="sd">        The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser.aggregate_variables-365"><a href="#LaggedAnalyser.aggregate_variables-365"><span class="linenos">365</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.aggregate_variables-366"><a href="#LaggedAnalyser.aggregate_variables-366"><span class="linenos">366</span></a><span class="sd">        *cat_func*</span>
</span><span id="LaggedAnalyser.aggregate_variables-367"><a href="#LaggedAnalyser.aggregate_variables-367"><span class="linenos">367</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-368"><a href="#LaggedAnalyser.aggregate_variables-368"><span class="linenos">368</span></a><span class="sd">        The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser.aggregate_variables-369"><a href="#LaggedAnalyser.aggregate_variables-369"><span class="linenos">369</span></a>
</span><span id="LaggedAnalyser.aggregate_variables-370"><a href="#LaggedAnalyser.aggregate_variables-370"><span class="linenos">370</span></a><span class="sd">        **returns**</span>
</span><span id="LaggedAnalyser.aggregate_variables-371"><a href="#LaggedAnalyser.aggregate_variables-371"><span class="linenos">371</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.aggregate_variables-372"><a href="#LaggedAnalyser.aggregate_variables-372"><span class="linenos">372</span></a><span class="sd">        An xarray.Dataset like  *LaggedAnalyser.variables* but summarised according to *con_func* and *cat_func*.</span>
</span><span id="LaggedAnalyser.aggregate_variables-373"><a href="#LaggedAnalyser.aggregate_variables-373"><span class="linenos">373</span></a>
</span><span id="LaggedAnalyser.aggregate_variables-374"><a href="#LaggedAnalyser.aggregate_variables-374"><span class="linenos">374</span></a><span class="sd">&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.aggregate_variables-375"><a href="#LaggedAnalyser.aggregate_variables-375"><span class="linenos">375</span></a>        <span class="n">fake_event</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">))</span>
</span><span id="LaggedAnalyser.aggregate_variables-376"><a href="#LaggedAnalyser.aggregate_variables-376"><span class="linenos">376</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_aggregate_over_lags</span><span class="p">(</span><span class="n">fake_event</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">lag_vals</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">)</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">index_val</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Calculates a summary metric from <em>LaggedAnalyser.variables</em> at all points where <em>LaggedAnalyser.event</em> is defined, regardless of its value.</p>

<p><strong>Optional arguments</strong></p>

<p><em>dim</em></p>

<p>A string, the name of the shared coordinate between <em>LaggedAnalyser.variables</em> and <em>LaggedAnalyser.event</em>.</p>

<p><em>lag_vals</em></p>

<p>'all' or a iterable of integers, specifying for which lag values to compute the summary metric.</p>

<p><em>con_func</em></p>

<p>The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</p>

<p><em>cat_func</em></p>

<p>The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</p>

<p><strong>returns</strong></p>

<p>An xarray.Dataset like  <em>LaggedAnalyser.variables</em> but summarised according to <em>con_func</em> and <em>cat_func</em>.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.add_derived_composite" class="classattr">
                                        <input id="LaggedAnalyser.add_derived_composite-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">add_derived_composite</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">name</span>, </span><span class="param"><span class="n">func</span>, </span><span class="param"><span class="n">composite_vars</span>, </span><span class="param"><span class="n">as_anomaly</span><span class="o">=</span><span class="kc">False</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.add_derived_composite-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.add_derived_composite"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.add_derived_composite-378"><a href="#LaggedAnalyser.add_derived_composite-378"><span class="linenos">378</span></a>    <span class="k">def</span> <span class="nf">add_derived_composite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser.add_derived_composite-379"><a href="#LaggedAnalyser.add_derived_composite-379"><span class="linenos">379</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies *func* to one or multiple composites to calculate composites of derived quantities, and additionally, stores *func* to allow derived bootstrap composites to be calculated. For linear quantities, where Ex[f(x)]==f(Ex[x]), then this can minimise redundant memory use.</span>
</span><span id="LaggedAnalyser.add_derived_composite-380"><a href="#LaggedAnalyser.add_derived_composite-380"><span class="linenos">380</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_derived_composite-381"><a href="#LaggedAnalyser.add_derived_composite-381"><span class="linenos">381</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser.add_derived_composite-382"><a href="#LaggedAnalyser.add_derived_composite-382"><span class="linenos">382</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_derived_composite-383"><a href="#LaggedAnalyser.add_derived_composite-383"><span class="linenos">383</span></a><span class="sd">        *name*</span>
</span><span id="LaggedAnalyser.add_derived_composite-384"><a href="#LaggedAnalyser.add_derived_composite-384"><span class="linenos">384</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_derived_composite-385"><a href="#LaggedAnalyser.add_derived_composite-385"><span class="linenos">385</span></a><span class="sd">        A string, providing the name of the new variable to add.</span>
</span><span id="LaggedAnalyser.add_derived_composite-386"><a href="#LaggedAnalyser.add_derived_composite-386"><span class="linenos">386</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.add_derived_composite-387"><a href="#LaggedAnalyser.add_derived_composite-387"><span class="linenos">387</span></a><span class="sd">        *func*</span>
</span><span id="LaggedAnalyser.add_derived_composite-388"><a href="#LaggedAnalyser.add_derived_composite-388"><span class="linenos">388</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_derived_composite-389"><a href="#LaggedAnalyser.add_derived_composite-389"><span class="linenos">389</span></a><span class="sd">         A callable which must take 1 or more xarray.DataArrays as inputs</span>
</span><span id="LaggedAnalyser.add_derived_composite-390"><a href="#LaggedAnalyser.add_derived_composite-390"><span class="linenos">390</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.add_derived_composite-391"><a href="#LaggedAnalyser.add_derived_composite-391"><span class="linenos">391</span></a><span class="sd">        *composite_vars*</span>
</span><span id="LaggedAnalyser.add_derived_composite-392"><a href="#LaggedAnalyser.add_derived_composite-392"><span class="linenos">392</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_derived_composite-393"><a href="#LaggedAnalyser.add_derived_composite-393"><span class="linenos">393</span></a><span class="sd">        An iterable of strings, of the same length as the number of arguments taken by *func*. Each string must be the name of a variable in *LaggedAnalyser.variables* which will be passed into *func* in order.</span>
</span><span id="LaggedAnalyser.add_derived_composite-394"><a href="#LaggedAnalyser.add_derived_composite-394"><span class="linenos">394</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_derived_composite-395"><a href="#LaggedAnalyser.add_derived_composite-395"><span class="linenos">395</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser.add_derived_composite-396"><a href="#LaggedAnalyser.add_derived_composite-396"><span class="linenos">396</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_derived_composite-397"><a href="#LaggedAnalyser.add_derived_composite-397"><span class="linenos">397</span></a><span class="sd">        *as_anomaly*</span>
</span><span id="LaggedAnalyser.add_derived_composite-398"><a href="#LaggedAnalyser.add_derived_composite-398"><span class="linenos">398</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.add_derived_composite-399"><a href="#LaggedAnalyser.add_derived_composite-399"><span class="linenos">399</span></a><span class="sd">        A boolean. Whether anomaly composites or full composites should be passed in to func.</span>
</span><span id="LaggedAnalyser.add_derived_composite-400"><a href="#LaggedAnalyser.add_derived_composite-400"><span class="linenos">400</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.add_derived_composite-401"><a href="#LaggedAnalyser.add_derived_composite-401"><span class="linenos">401</span></a>        
</span><span id="LaggedAnalyser.add_derived_composite-402"><a href="#LaggedAnalyser.add_derived_composite-402"><span class="linenos">402</span></a>        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">as_anomaly</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
</span><span id="LaggedAnalyser.add_derived_composite-403"><a href="#LaggedAnalyser.add_derived_composite-403"><span class="linenos">403</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;variable-specific anomalies not yet implemented&#39;</span><span class="p">))</span>
</span><span id="LaggedAnalyser.add_derived_composite-404"><a href="#LaggedAnalyser.add_derived_composite-404"><span class="linenos">404</span></a>
</span><span id="LaggedAnalyser.add_derived_composite-405"><a href="#LaggedAnalyser.add_derived_composite-405"><span class="linenos">405</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_derived_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="LaggedAnalyser.add_derived_composite-406"><a href="#LaggedAnalyser.add_derived_composite-406"><span class="linenos">406</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_derived_da</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="LaggedAnalyser.add_derived_composite-407"><a href="#LaggedAnalyser.add_derived_composite-407"><span class="linenos">407</span></a>        
</span><span id="LaggedAnalyser.add_derived_composite-408"><a href="#LaggedAnalyser.add_derived_composite-408"><span class="linenos">408</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser.add_derived_composite-409"><a href="#LaggedAnalyser.add_derived_composite-409"><span class="linenos">409</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_derived_da</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="p">,</span><span class="n">func</span><span class="p">,</span><span class="n">composite_vars</span><span class="p">,</span><span class="n">as_anomaly</span><span class="p">)</span>
</span><span id="LaggedAnalyser.add_derived_composite-410"><a href="#LaggedAnalyser.add_derived_composite-410"><span class="linenos">410</span></a>            
</span><span id="LaggedAnalyser.add_derived_composite-411"><a href="#LaggedAnalyser.add_derived_composite-411"><span class="linenos">411</span></a>        <span class="k">return</span>
</span></pre></div>


            <div class="docstring"><p>Applies <em>func</em> to one or multiple composites to calculate composites of derived quantities, and additionally, stores <em>func</em> to allow derived bootstrap composites to be calculated. For linear quantities, where Ex[f(x)]==f(Ex[x]), then this can minimise redundant memory use.</p>

<p><strong>Arguments</strong></p>

<p><em>name</em></p>

<p>A string, providing the name of the new variable to add.</p>

<p><em>func</em></p>

<p>A callable which must take 1 or more xarray.DataArrays as inputs</p>

<p><em>composite_vars</em></p>

<p>An iterable of strings, of the same length as the number of arguments taken by <em>func</em>. Each string must be the name of a variable in <em>LaggedAnalyser.variables</em> which will be passed into <em>func</em> in order.</p>

<p><strong>Optional arguments</strong></p>

<p><em>as_anomaly</em></p>

<p>A boolean. Whether anomaly composites or full composites should be passed in to func.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.compute_bootstraps" class="classattr">
                                        <input id="LaggedAnalyser.compute_bootstraps-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">compute_bootstraps</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">bootnum</span>,</span><span class="param">	<span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span>,</span><span class="param">	<span class="n">con_func</span><span class="o">=&lt;</span><span class="n">function</span> <span class="n">mean_ds</span><span class="o">&gt;</span>,</span><span class="param">	<span class="n">cat_func</span><span class="o">=&lt;</span><span class="n">function</span> <span class="n">cat_occ_ds</span><span class="o">&gt;</span>,</span><span class="param">	<span class="n">lag</span><span class="o">=</span><span class="mi">0</span>,</span><span class="param">	<span class="n">synth_mode</span><span class="o">=</span><span class="s1">&#39;markov&#39;</span>,</span><span class="param">	<span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span>,</span><span class="param">	<span class="n">reuse_ixs</span><span class="o">=</span><span class="kc">False</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.compute_bootstraps-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.compute_bootstraps"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.compute_bootstraps-416"><a href="#LaggedAnalyser.compute_bootstraps-416"><span class="linenos">416</span></a>    <span class="k">def</span> <span class="nf">compute_bootstraps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">con_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">mean_ds</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="n">agg</span><span class="o">.</span><span class="n">cat_occ_ds</span><span class="p">,</span><span class="n">lag</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">synth_mode</span><span class="o">=</span><span class="s1">&#39;markov&#39;</span><span class="p">,</span><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">reuse_ixs</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser.compute_bootstraps-417"><a href="#LaggedAnalyser.compute_bootstraps-417"><span class="linenos">417</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-418"><a href="#LaggedAnalyser.compute_bootstraps-418"><span class="linenos">418</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes composites from synthetic event indices, which can be used to assess whether composites are insignificant.</span>
</span><span id="LaggedAnalyser.compute_bootstraps-419"><a href="#LaggedAnalyser.compute_bootstraps-419"><span class="linenos">419</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-420"><a href="#LaggedAnalyser.compute_bootstraps-420"><span class="linenos">420</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser.compute_bootstraps-421"><a href="#LaggedAnalyser.compute_bootstraps-421"><span class="linenos">421</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-422"><a href="#LaggedAnalyser.compute_bootstraps-422"><span class="linenos">422</span></a><span class="sd">        *bootnum*</span>
</span><span id="LaggedAnalyser.compute_bootstraps-423"><a href="#LaggedAnalyser.compute_bootstraps-423"><span class="linenos">423</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-424"><a href="#LaggedAnalyser.compute_bootstraps-424"><span class="linenos">424</span></a><span class="sd">        An integer, the number of bootstrapped composites to compute</span>
</span><span id="LaggedAnalyser.compute_bootstraps-425"><a href="#LaggedAnalyser.compute_bootstraps-425"><span class="linenos">425</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_bootstraps-426"><a href="#LaggedAnalyser.compute_bootstraps-426"><span class="linenos">426</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser.compute_bootstraps-427"><a href="#LaggedAnalyser.compute_bootstraps-427"><span class="linenos">427</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-428"><a href="#LaggedAnalyser.compute_bootstraps-428"><span class="linenos">428</span></a><span class="sd">        *dim*</span>
</span><span id="LaggedAnalyser.compute_bootstraps-429"><a href="#LaggedAnalyser.compute_bootstraps-429"><span class="linenos">429</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-430"><a href="#LaggedAnalyser.compute_bootstraps-430"><span class="linenos">430</span></a><span class="sd">        A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*.</span>
</span><span id="LaggedAnalyser.compute_bootstraps-431"><a href="#LaggedAnalyser.compute_bootstraps-431"><span class="linenos">431</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_bootstraps-432"><a href="#LaggedAnalyser.compute_bootstraps-432"><span class="linenos">432</span></a><span class="sd">        *con_func*</span>
</span><span id="LaggedAnalyser.compute_bootstraps-433"><a href="#LaggedAnalyser.compute_bootstraps-433"><span class="linenos">433</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-434"><a href="#LaggedAnalyser.compute_bootstraps-434"><span class="linenos">434</span></a><span class="sd">        The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser.compute_bootstraps-435"><a href="#LaggedAnalyser.compute_bootstraps-435"><span class="linenos">435</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_bootstraps-436"><a href="#LaggedAnalyser.compute_bootstraps-436"><span class="linenos">436</span></a><span class="sd">        *cat_func*</span>
</span><span id="LaggedAnalyser.compute_bootstraps-437"><a href="#LaggedAnalyser.compute_bootstraps-437"><span class="linenos">437</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-438"><a href="#LaggedAnalyser.compute_bootstraps-438"><span class="linenos">438</span></a><span class="sd">        The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</span>
</span><span id="LaggedAnalyser.compute_bootstraps-439"><a href="#LaggedAnalyser.compute_bootstraps-439"><span class="linenos">439</span></a>
</span><span id="LaggedAnalyser.compute_bootstraps-440"><a href="#LaggedAnalyser.compute_bootstraps-440"><span class="linenos">440</span></a><span class="sd">        *lag*</span>
</span><span id="LaggedAnalyser.compute_bootstraps-441"><a href="#LaggedAnalyser.compute_bootstraps-441"><span class="linenos">441</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-442"><a href="#LaggedAnalyser.compute_bootstraps-442"><span class="linenos">442</span></a><span class="sd">        An integer, specifying which lagged variables to use for the bootstraps. i.e. bootstraps for lag=90 will be from a completely different season than those for lag=0.</span>
</span><span id="LaggedAnalyser.compute_bootstraps-443"><a href="#LaggedAnalyser.compute_bootstraps-443"><span class="linenos">443</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_bootstraps-444"><a href="#LaggedAnalyser.compute_bootstraps-444"><span class="linenos">444</span></a><span class="sd">        *synth_mode*</span>
</span><span id="LaggedAnalyser.compute_bootstraps-445"><a href="#LaggedAnalyser.compute_bootstraps-445"><span class="linenos">445</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-446"><a href="#LaggedAnalyser.compute_bootstraps-446"><span class="linenos">446</span></a><span class="sd">        A string, specifying how synthetic event indices are to be computed. Valid options are:</span>
</span><span id="LaggedAnalyser.compute_bootstraps-447"><a href="#LaggedAnalyser.compute_bootstraps-447"><span class="linenos">447</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_bootstraps-448"><a href="#LaggedAnalyser.compute_bootstraps-448"><span class="linenos">448</span></a><span class="sd">        &quot;random&quot;: </span>
</span><span id="LaggedAnalyser.compute_bootstraps-449"><a href="#LaggedAnalyser.compute_bootstraps-449"><span class="linenos">449</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-450"><a href="#LaggedAnalyser.compute_bootstraps-450"><span class="linenos">450</span></a><span class="sd">        categorical values are randomly chosen with the same probability of occurrence as those found in *LaggedAnalyser.event*, but with no autocorrelation.</span>
</span><span id="LaggedAnalyser.compute_bootstraps-451"><a href="#LaggedAnalyser.compute_bootstraps-451"><span class="linenos">451</span></a>
</span><span id="LaggedAnalyser.compute_bootstraps-452"><a href="#LaggedAnalyser.compute_bootstraps-452"><span class="linenos">452</span></a><span class="sd">        &quot;markov&quot;: </span>
</span><span id="LaggedAnalyser.compute_bootstraps-453"><a href="#LaggedAnalyser.compute_bootstraps-453"><span class="linenos">453</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-454"><a href="#LaggedAnalyser.compute_bootstraps-454"><span class="linenos">454</span></a><span class="sd">        A first order Markov chain is fitted to *LaggedAnalyser.event*, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than &quot;random&quot; and so should normally be used.</span>
</span><span id="LaggedAnalyser.compute_bootstraps-455"><a href="#LaggedAnalyser.compute_bootstraps-455"><span class="linenos">455</span></a>
</span><span id="LaggedAnalyser.compute_bootstraps-456"><a href="#LaggedAnalyser.compute_bootstraps-456"><span class="linenos">456</span></a><span class="sd">        &quot;shuffle&quot;: </span>
</span><span id="LaggedAnalyser.compute_bootstraps-457"><a href="#LaggedAnalyser.compute_bootstraps-457"><span class="linenos">457</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-458"><a href="#LaggedAnalyser.compute_bootstraps-458"><span class="linenos">458</span></a><span class="sd">        The values are randomly reordered. This means that each value will occur exactly the same amount of times as in the original index, and so is ideal for particularly rare events or short series.</span>
</span><span id="LaggedAnalyser.compute_bootstraps-459"><a href="#LaggedAnalyser.compute_bootstraps-459"><span class="linenos">459</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.compute_bootstraps-460"><a href="#LaggedAnalyser.compute_bootstraps-460"><span class="linenos">460</span></a><span class="sd">        *data_vars*</span>
</span><span id="LaggedAnalyser.compute_bootstraps-461"><a href="#LaggedAnalyser.compute_bootstraps-461"><span class="linenos">461</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-462"><a href="#LaggedAnalyser.compute_bootstraps-462"><span class="linenos">462</span></a><span class="sd">        An iterable of strings, specifying for which variables bootstraps should be computed.</span>
</span><span id="LaggedAnalyser.compute_bootstraps-463"><a href="#LaggedAnalyser.compute_bootstraps-463"><span class="linenos">463</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser.compute_bootstraps-464"><a href="#LaggedAnalyser.compute_bootstraps-464"><span class="linenos">464</span></a><span class="sd">        **returns**</span>
</span><span id="LaggedAnalyser.compute_bootstraps-465"><a href="#LaggedAnalyser.compute_bootstraps-465"><span class="linenos">465</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.compute_bootstraps-466"><a href="#LaggedAnalyser.compute_bootstraps-466"><span class="linenos">466</span></a><span class="sd">        An xarray.Dataset like *LaggedAnalyser.variables* but summarised according to *con_func* and *cat_func*, and with a new coordinate &#39;bootnum&#39; of length *bootnum*.</span>
</span><span id="LaggedAnalyser.compute_bootstraps-467"><a href="#LaggedAnalyser.compute_bootstraps-467"><span class="linenos">467</span></a>
</span><span id="LaggedAnalyser.compute_bootstraps-468"><a href="#LaggedAnalyser.compute_bootstraps-468"><span class="linenos">468</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.compute_bootstraps-469"><a href="#LaggedAnalyser.compute_bootstraps-469"><span class="linenos">469</span></a>        <span class="k">if</span> <span class="n">data_vars</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser.compute_bootstraps-470"><a href="#LaggedAnalyser.compute_bootstraps-470"><span class="linenos">470</span></a>            <span class="n">data_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
</span><span id="LaggedAnalyser.compute_bootstraps-471"><a href="#LaggedAnalyser.compute_bootstraps-471"><span class="linenos">471</span></a>
</span><span id="LaggedAnalyser.compute_bootstraps-472"><a href="#LaggedAnalyser.compute_bootstraps-472"><span class="linenos">472</span></a>        <span class="n">boots</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_derived_boots</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_bootstraps</span><span class="p">(</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">lag</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">,</span><span class="n">reuse_ixs</span><span class="p">))</span>
</span><span id="LaggedAnalyser.compute_bootstraps-473"><a href="#LaggedAnalyser.compute_bootstraps-473"><span class="linenos">473</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">composites_are_anomaly</span><span class="p">:</span>
</span><span id="LaggedAnalyser.compute_bootstraps-474"><a href="#LaggedAnalyser.compute_bootstraps-474"><span class="linenos">474</span></a>            <span class="n">boots</span><span class="o">=</span><span class="n">boots</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">lagged_means</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">lag</span><span class="o">=</span><span class="n">lag</span><span class="p">)</span>
</span><span id="LaggedAnalyser.compute_bootstraps-475"><a href="#LaggedAnalyser.compute_bootstraps-475"><span class="linenos">475</span></a>        <span class="k">return</span> <span class="n">make_all_dims_coords</span><span class="p">(</span><span class="n">boots</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Computes composites from synthetic event indices, which can be used to assess whether composites are insignificant.</p>

<p><strong>Arguments</strong></p>

<p><em>bootnum</em></p>

<p>An integer, the number of bootstrapped composites to compute</p>

<p><strong>Optional arguments</strong></p>

<p><em>dim</em></p>

<p>A string, the name of the shared coordinate between <em>LaggedAnalyser.variables</em> and <em>LaggedAnalyser.event</em>.</p>

<p><em>con_func</em></p>

<p>The summary metric to use for continuous variables. Defaults to a standard mean average. If None, then continuous variables will be ignored</p>

<p><em>cat_func</em></p>

<p>The summary metric to use for categorical variables. Defaults to the occurrence probability of each categorical value. If None, then continuous variables will be ignored</p>

<p><em>lag</em></p>

<p>An integer, specifying which lagged variables to use for the bootstraps. i.e. bootstraps for lag=90 will be from a completely different season than those for lag=0.</p>

<p><em>synth_mode</em></p>

<p>A string, specifying how synthetic event indices are to be computed. Valid options are:</p>

<p>"random": </p>

<p>categorical values are randomly chosen with the same probability of occurrence as those found in <em>LaggedAnalyser.event</em>, but with no autocorrelation.</p>

<p>"markov": </p>

<p>A first order Markov chain is fitted to <em>LaggedAnalyser.event</em>, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than "random" and so should normally be used.</p>

<p>"shuffle": </p>

<p>The values are randomly reordered. This means that each value will occur exactly the same amount of times as in the original index, and so is ideal for particularly rare events or short series.</p>

<p><em>data_vars</em></p>

<p>An iterable of strings, specifying for which variables bootstraps should be computed.</p>

<p><strong>returns</strong></p>

<p>An xarray.Dataset like <em>LaggedAnalyser.variables</em> but summarised according to <em>con_func</em> and <em>cat_func</em>, and with a new coordinate 'bootnum' of length <em>bootnum</em>.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.get_significance" class="classattr">
                                        <input id="LaggedAnalyser.get_significance-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_significance</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">bootstraps</span>, </span><span class="param"><span class="n">comp</span>, </span><span class="param"><span class="n">p</span>, </span><span class="param"><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span>, </span><span class="param"><span class="n">hb_correction</span><span class="o">=</span><span class="kc">False</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.get_significance-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.get_significance"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.get_significance-543"><a href="#LaggedAnalyser.get_significance-543"><span class="linenos">543</span></a>    <span class="k">def</span> <span class="nf">get_significance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootstraps</span><span class="p">,</span><span class="n">comp</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">hb_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser.get_significance-544"><a href="#LaggedAnalyser.get_significance-544"><span class="linenos">544</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser.get_significance-545"><a href="#LaggedAnalyser.get_significance-545"><span class="linenos">545</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes whether a composite is significant with respect to a given distribution of bootstrapped composites. </span>
</span><span id="LaggedAnalyser.get_significance-546"><a href="#LaggedAnalyser.get_significance-546"><span class="linenos">546</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.get_significance-547"><a href="#LaggedAnalyser.get_significance-547"><span class="linenos">547</span></a><span class="sd">        **Arguments**</span>
</span><span id="LaggedAnalyser.get_significance-548"><a href="#LaggedAnalyser.get_significance-548"><span class="linenos">548</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.get_significance-549"><a href="#LaggedAnalyser.get_significance-549"><span class="linenos">549</span></a><span class="sd">        *bootstraps*</span>
</span><span id="LaggedAnalyser.get_significance-550"><a href="#LaggedAnalyser.get_significance-550"><span class="linenos">550</span></a>
</span><span id="LaggedAnalyser.get_significance-551"><a href="#LaggedAnalyser.get_significance-551"><span class="linenos">551</span></a><span class="sd">        An xarray.Dataset with a coordinate &#39;bootnum&#39;, such as produced by *LaggedAnalyser.compute_bootstraps*</span>
</span><span id="LaggedAnalyser.get_significance-552"><a href="#LaggedAnalyser.get_significance-552"><span class="linenos">552</span></a>
</span><span id="LaggedAnalyser.get_significance-553"><a href="#LaggedAnalyser.get_significance-553"><span class="linenos">553</span></a><span class="sd">        *comp*</span>
</span><span id="LaggedAnalyser.get_significance-554"><a href="#LaggedAnalyser.get_significance-554"><span class="linenos">554</span></a>
</span><span id="LaggedAnalyser.get_significance-555"><a href="#LaggedAnalyser.get_significance-555"><span class="linenos">555</span></a><span class="sd">        An xarray Dataset of the same shape as *bootstraps* but without a &#39;bootnum&#39; coordinate. Missing or additional variables are allowed, and are simply ignored.</span>
</span><span id="LaggedAnalyser.get_significance-556"><a href="#LaggedAnalyser.get_significance-556"><span class="linenos">556</span></a><span class="sd">        *p*</span>
</span><span id="LaggedAnalyser.get_significance-557"><a href="#LaggedAnalyser.get_significance-557"><span class="linenos">557</span></a>
</span><span id="LaggedAnalyser.get_significance-558"><a href="#LaggedAnalyser.get_significance-558"><span class="linenos">558</span></a><span class="sd">        A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </span>
</span><span id="LaggedAnalyser.get_significance-559"><a href="#LaggedAnalyser.get_significance-559"><span class="linenos">559</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.get_significance-560"><a href="#LaggedAnalyser.get_significance-560"><span class="linenos">560</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="LaggedAnalyser.get_significance-561"><a href="#LaggedAnalyser.get_significance-561"><span class="linenos">561</span></a>
</span><span id="LaggedAnalyser.get_significance-562"><a href="#LaggedAnalyser.get_significance-562"><span class="linenos">562</span></a><span class="sd">        *data_vars*</span>
</span><span id="LaggedAnalyser.get_significance-563"><a href="#LaggedAnalyser.get_significance-563"><span class="linenos">563</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.get_significance-564"><a href="#LaggedAnalyser.get_significance-564"><span class="linenos">564</span></a><span class="sd">        An iterable of strings, specifying for which variables significance should be computed.</span>
</span><span id="LaggedAnalyser.get_significance-565"><a href="#LaggedAnalyser.get_significance-565"><span class="linenos">565</span></a><span class="sd">            </span>
</span><span id="LaggedAnalyser.get_significance-566"><a href="#LaggedAnalyser.get_significance-566"><span class="linenos">566</span></a><span class="sd">        *hb_correction*</span>
</span><span id="LaggedAnalyser.get_significance-567"><a href="#LaggedAnalyser.get_significance-567"><span class="linenos">567</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.get_significance-568"><a href="#LaggedAnalyser.get_significance-568"><span class="linenos">568</span></a><span class="sd">        A Boolean, specifying whether a Holm-Bonferroni correction should be applied to *p*, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in *comp* independently, and so will have no impact on scalar variables.</span>
</span><span id="LaggedAnalyser.get_significance-569"><a href="#LaggedAnalyser.get_significance-569"><span class="linenos">569</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.get_significance-570"><a href="#LaggedAnalyser.get_significance-570"><span class="linenos">570</span></a><span class="sd">        **returns**</span>
</span><span id="LaggedAnalyser.get_significance-571"><a href="#LaggedAnalyser.get_significance-571"><span class="linenos">571</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.get_significance-572"><a href="#LaggedAnalyser.get_significance-572"><span class="linenos">572</span></a><span class="sd">        An xarray.Dataset like *comp* but with boolean data, specifying whether each feature of each variable passed the significance test.</span>
</span><span id="LaggedAnalyser.get_significance-573"><a href="#LaggedAnalyser.get_significance-573"><span class="linenos">573</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.get_significance-574"><a href="#LaggedAnalyser.get_significance-574"><span class="linenos">574</span></a>        <span class="k">if</span> <span class="n">data_vars</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser.get_significance-575"><a href="#LaggedAnalyser.get_significance-575"><span class="linenos">575</span></a>            <span class="n">data_vars</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">bootstraps</span><span class="o">.</span><span class="n">data_vars</span><span class="p">)</span>
</span><span id="LaggedAnalyser.get_significance-576"><a href="#LaggedAnalyser.get_significance-576"><span class="linenos">576</span></a>
</span><span id="LaggedAnalyser.get_significance-577"><a href="#LaggedAnalyser.get_significance-577"><span class="linenos">577</span></a>        <span class="n">bootnum</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bootstraps</span><span class="o">.</span><span class="n">boot_num</span><span class="p">)</span>
</span><span id="LaggedAnalyser.get_significance-578"><a href="#LaggedAnalyser.get_significance-578"><span class="linenos">578</span></a>        <span class="n">comp</span><span class="o">=</span><span class="n">comp</span><span class="p">[</span><span class="n">data_vars</span><span class="p">]</span>
</span><span id="LaggedAnalyser.get_significance-579"><a href="#LaggedAnalyser.get_significance-579"><span class="linenos">579</span></a>        <span class="n">bootstraps</span><span class="o">=</span><span class="n">bootstraps</span><span class="p">[</span><span class="n">data_vars</span><span class="p">]</span>
</span><span id="LaggedAnalyser.get_significance-580"><a href="#LaggedAnalyser.get_significance-580"><span class="linenos">580</span></a>        <span class="n">frac</span><span class="o">=</span><span class="p">(</span><span class="n">comp</span><span class="o">&lt;</span><span class="n">bootstraps</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="s1">&#39;boot_num&#39;</span><span class="p">)</span><span class="o">/</span><span class="n">bootnum</span>
</span><span id="LaggedAnalyser.get_significance-581"><a href="#LaggedAnalyser.get_significance-581"><span class="linenos">581</span></a>        <span class="n">pval_ds</span><span class="o">=</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">frac</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
</span><span id="LaggedAnalyser.get_significance-582"><a href="#LaggedAnalyser.get_significance-582"><span class="linenos">582</span></a>        <span class="k">if</span> <span class="n">hb_correction</span><span class="p">:</span>
</span><span id="LaggedAnalyser.get_significance-583"><a href="#LaggedAnalyser.get_significance-583"><span class="linenos">583</span></a>            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">pval_ds</span><span class="p">:</span>
</span><span id="LaggedAnalyser.get_significance-584"><a href="#LaggedAnalyser.get_significance-584"><span class="linenos">584</span></a>                <span class="n">corrected_pval</span><span class="o">=</span><span class="n">holm_bonferroni_correction</span><span class="p">(</span><span class="n">pval_ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span><span class="n">p</span><span class="p">)</span>\
</span><span id="LaggedAnalyser.get_significance-585"><a href="#LaggedAnalyser.get_significance-585"><span class="linenos">585</span></a>                            <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pval_ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</span><span id="LaggedAnalyser.get_significance-586"><a href="#LaggedAnalyser.get_significance-586"><span class="linenos">586</span></a>                <span class="n">pval_ds</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="n">corrected_pval</span>
</span><span id="LaggedAnalyser.get_significance-587"><a href="#LaggedAnalyser.get_significance-587"><span class="linenos">587</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser.get_significance-588"><a href="#LaggedAnalyser.get_significance-588"><span class="linenos">588</span></a>            <span class="n">pval_ds</span><span class="o">=</span><span class="n">pval_ds</span><span class="o">&lt;</span><span class="n">p</span>
</span><span id="LaggedAnalyser.get_significance-589"><a href="#LaggedAnalyser.get_significance-589"><span class="linenos">589</span></a>            
</span><span id="LaggedAnalyser.get_significance-590"><a href="#LaggedAnalyser.get_significance-590"><span class="linenos">590</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span><span class="o">=</span><span class="n">pval_ds</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">(</span><span class="n">lag</span><span class="o">=</span><span class="n">comp</span><span class="o">.</span><span class="n">lag</span><span class="p">)</span>
</span><span id="LaggedAnalyser.get_significance-591"><a href="#LaggedAnalyser.get_significance-591"><span class="linenos">591</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span>
</span></pre></div>


            <div class="docstring"><p>Computes whether a composite is significant with respect to a given distribution of bootstrapped composites. </p>

<p><strong>Arguments</strong></p>

<p><em>bootstraps</em></p>

<p>An xarray.Dataset with a coordinate 'bootnum', such as produced by <em><a href="#LaggedAnalyser.compute_bootstraps">LaggedAnalyser.compute_bootstraps</a></em></p>

<p><em>comp</em></p>

<p>An xarray Dataset of the same shape as <em>bootstraps</em> but without a 'bootnum' coordinate. Missing or additional variables are allowed, and are simply ignored.
<em>p</em></p>

<p>A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </p>

<p><strong>Optional arguments</strong></p>

<p><em>data_vars</em></p>

<p>An iterable of strings, specifying for which variables significance should be computed.</p>

<p><em>hb_correction</em></p>

<p>A Boolean, specifying whether a Holm-Bonferroni correction should be applied to <em>p</em>, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in <em>comp</em> independently, and so will have no impact on scalar variables.</p>

<p><strong>returns</strong></p>

<p>An xarray.Dataset like <em>comp</em> but with boolean data, specifying whether each feature of each variable passed the significance test.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.bootstrap_significance" class="classattr">
                                        <input id="LaggedAnalyser.bootstrap_significance-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">bootstrap_significance</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">bootnum</span>,</span><span class="param">	<span class="n">p</span>,</span><span class="param">	<span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span>,</span><span class="param">	<span class="n">synth_mode</span><span class="o">=</span><span class="s1">&#39;markov&#39;</span>,</span><span class="param">	<span class="n">reuse_lag0_boots</span><span class="o">=</span><span class="kc">False</span>,</span><span class="param">	<span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span>,</span><span class="param">	<span class="n">hb_correction</span><span class="o">=</span><span class="kc">False</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.bootstrap_significance-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.bootstrap_significance"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.bootstrap_significance-593"><a href="#LaggedAnalyser.bootstrap_significance-593"><span class="linenos">593</span></a>    <span class="k">def</span> <span class="nf">bootstrap_significance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">bootnum</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">synth_mode</span><span class="o">=</span><span class="s1">&#39;markov&#39;</span><span class="p">,</span><span class="n">reuse_lag0_boots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">data_vars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">hb_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="LaggedAnalyser.bootstrap_significance-594"><a href="#LaggedAnalyser.bootstrap_significance-594"><span class="linenos">594</span></a><span class="w">        </span>
</span><span id="LaggedAnalyser.bootstrap_significance-595"><a href="#LaggedAnalyser.bootstrap_significance-595"><span class="linenos">595</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;A wrapper around *compute_bootstraps* and *get_significance*, that calculates bootstraps and applies a significance test to a number of time lagged composites simulataneously.</span>
</span><span id="LaggedAnalyser.bootstrap_significance-596"><a href="#LaggedAnalyser.bootstrap_significance-596"><span class="linenos">596</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.bootstrap_significance-597"><a href="#LaggedAnalyser.bootstrap_significance-597"><span class="linenos">597</span></a><span class="sd">    **Arguments**</span>
</span><span id="LaggedAnalyser.bootstrap_significance-598"><a href="#LaggedAnalyser.bootstrap_significance-598"><span class="linenos">598</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-599"><a href="#LaggedAnalyser.bootstrap_significance-599"><span class="linenos">599</span></a><span class="sd">    *bootnum*</span>
</span><span id="LaggedAnalyser.bootstrap_significance-600"><a href="#LaggedAnalyser.bootstrap_significance-600"><span class="linenos">600</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-601"><a href="#LaggedAnalyser.bootstrap_significance-601"><span class="linenos">601</span></a><span class="sd">    An integer, the number of bootstrapped composites to compute</span>
</span><span id="LaggedAnalyser.bootstrap_significance-602"><a href="#LaggedAnalyser.bootstrap_significance-602"><span class="linenos">602</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-603"><a href="#LaggedAnalyser.bootstrap_significance-603"><span class="linenos">603</span></a><span class="sd">    *p*</span>
</span><span id="LaggedAnalyser.bootstrap_significance-604"><a href="#LaggedAnalyser.bootstrap_significance-604"><span class="linenos">604</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-605"><a href="#LaggedAnalyser.bootstrap_significance-605"><span class="linenos">605</span></a><span class="sd">    A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </span>
</span><span id="LaggedAnalyser.bootstrap_significance-606"><a href="#LaggedAnalyser.bootstrap_significance-606"><span class="linenos">606</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-607"><a href="#LaggedAnalyser.bootstrap_significance-607"><span class="linenos">607</span></a><span class="sd">    **Optional arguments**</span>
</span><span id="LaggedAnalyser.bootstrap_significance-608"><a href="#LaggedAnalyser.bootstrap_significance-608"><span class="linenos">608</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-609"><a href="#LaggedAnalyser.bootstrap_significance-609"><span class="linenos">609</span></a><span class="sd">    *dim*</span>
</span><span id="LaggedAnalyser.bootstrap_significance-610"><a href="#LaggedAnalyser.bootstrap_significance-610"><span class="linenos">610</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-611"><a href="#LaggedAnalyser.bootstrap_significance-611"><span class="linenos">611</span></a><span class="sd">    A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*.</span>
</span><span id="LaggedAnalyser.bootstrap_significance-612"><a href="#LaggedAnalyser.bootstrap_significance-612"><span class="linenos">612</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-613"><a href="#LaggedAnalyser.bootstrap_significance-613"><span class="linenos">613</span></a><span class="sd">    *synth_mode*</span>
</span><span id="LaggedAnalyser.bootstrap_significance-614"><a href="#LaggedAnalyser.bootstrap_significance-614"><span class="linenos">614</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-615"><a href="#LaggedAnalyser.bootstrap_significance-615"><span class="linenos">615</span></a><span class="sd">    A string, specifying how synthetic event indices are to be computed. Valid options are:</span>
</span><span id="LaggedAnalyser.bootstrap_significance-616"><a href="#LaggedAnalyser.bootstrap_significance-616"><span class="linenos">616</span></a><span class="sd">    &quot;random&quot;: categorical values are randomly chosen with the same probability of occurrence as those found in *LaggedAnalyser.event*, but with no autocorrelation.</span>
</span><span id="LaggedAnalyser.bootstrap_significance-617"><a href="#LaggedAnalyser.bootstrap_significance-617"><span class="linenos">617</span></a><span class="sd">    &#39;markov&#39;: A first order Markov chain is fitted to *LaggedAnalyser.event*, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than &quot;random&quot; and so should normally be used.</span>
</span><span id="LaggedAnalyser.bootstrap_significance-618"><a href="#LaggedAnalyser.bootstrap_significance-618"><span class="linenos">618</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-619"><a href="#LaggedAnalyser.bootstrap_significance-619"><span class="linenos">619</span></a><span class="sd">    *reuse_lag0_boots*</span>
</span><span id="LaggedAnalyser.bootstrap_significance-620"><a href="#LaggedAnalyser.bootstrap_significance-620"><span class="linenos">620</span></a><span class="sd">        A Boolean. If True, bootstraps are only computed for lag=0, and then used as a null distribution to assess all lagged composites. For variables which are approximately stationary across the lag timescale, then this is a good approximation and can increase performance. However if used incorrectly, it may lead to &#39;significant composites&#39; which simply reflect the seasonal cycle. if False, separate bootstraps are computed for all time lags.</span>
</span><span id="LaggedAnalyser.bootstrap_significance-621"><a href="#LaggedAnalyser.bootstrap_significance-621"><span class="linenos">621</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-622"><a href="#LaggedAnalyser.bootstrap_significance-622"><span class="linenos">622</span></a><span class="sd">    *data_vars*</span>
</span><span id="LaggedAnalyser.bootstrap_significance-623"><a href="#LaggedAnalyser.bootstrap_significance-623"><span class="linenos">623</span></a><span class="sd">        An iterable of strings, specifying for which variables significance should be computed.</span>
</span><span id="LaggedAnalyser.bootstrap_significance-624"><a href="#LaggedAnalyser.bootstrap_significance-624"><span class="linenos">624</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-625"><a href="#LaggedAnalyser.bootstrap_significance-625"><span class="linenos">625</span></a><span class="sd">    *hb_correction*</span>
</span><span id="LaggedAnalyser.bootstrap_significance-626"><a href="#LaggedAnalyser.bootstrap_significance-626"><span class="linenos">626</span></a><span class="sd">        A Boolean, specifying whether a Holm-Bonferroni correction should be applied to *p*, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in *comp* independently, and so will have no impact on scalar variables.</span>
</span><span id="LaggedAnalyser.bootstrap_significance-627"><a href="#LaggedAnalyser.bootstrap_significance-627"><span class="linenos">627</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.bootstrap_significance-628"><a href="#LaggedAnalyser.bootstrap_significance-628"><span class="linenos">628</span></a><span class="sd">    **returns**</span>
</span><span id="LaggedAnalyser.bootstrap_significance-629"><a href="#LaggedAnalyser.bootstrap_significance-629"><span class="linenos">629</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-630"><a href="#LaggedAnalyser.bootstrap_significance-630"><span class="linenos">630</span></a><span class="sd">    An xarray.Dataset like *LaggedAnalyser.variables* but with the *dim* dimension summarised according to *con_func* and *cat_func*, an additional *lag* coordinate, and with boolean data specifying whether each feature of each variable passed the significance test.</span>
</span><span id="LaggedAnalyser.bootstrap_significance-631"><a href="#LaggedAnalyser.bootstrap_significance-631"><span class="linenos">631</span></a>
</span><span id="LaggedAnalyser.bootstrap_significance-632"><a href="#LaggedAnalyser.bootstrap_significance-632"><span class="linenos">632</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.bootstrap_significance-633"><a href="#LaggedAnalyser.bootstrap_significance-633"><span class="linenos">633</span></a>        <span class="n">lag_vals</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)</span>
</span><span id="LaggedAnalyser.bootstrap_significance-634"><a href="#LaggedAnalyser.bootstrap_significance-634"><span class="linenos">634</span></a>        
</span><span id="LaggedAnalyser.bootstrap_significance-635"><a href="#LaggedAnalyser.bootstrap_significance-635"><span class="linenos">635</span></a>        <span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">composite_func</span>
</span><span id="LaggedAnalyser.bootstrap_significance-636"><a href="#LaggedAnalyser.bootstrap_significance-636"><span class="linenos">636</span></a>        
</span><span id="LaggedAnalyser.bootstrap_significance-637"><a href="#LaggedAnalyser.bootstrap_significance-637"><span class="linenos">637</span></a>        <span class="n">boots</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_bootstraps</span><span class="p">(</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">)</span>
</span><span id="LaggedAnalyser.bootstrap_significance-638"><a href="#LaggedAnalyser.bootstrap_significance-638"><span class="linenos">638</span></a>        
</span><span id="LaggedAnalyser.bootstrap_significance-639"><a href="#LaggedAnalyser.bootstrap_significance-639"><span class="linenos">639</span></a>        <span class="c1">#reuse_lag0_boots=True can substantially reduce run time!</span>
</span><span id="LaggedAnalyser.bootstrap_significance-640"><a href="#LaggedAnalyser.bootstrap_significance-640"><span class="linenos">640</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="n">reuse_lag0_boots</span><span class="p">:</span>
</span><span id="LaggedAnalyser.bootstrap_significance-641"><a href="#LaggedAnalyser.bootstrap_significance-641"><span class="linenos">641</span></a>                    <span class="n">boots</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">boots</span><span class="p">,</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_bootstraps</span><span class="p">(</span><span class="n">bootnum</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">con_func</span><span class="p">,</span><span class="n">cat_func</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">synth_mode</span><span class="p">,</span><span class="n">data_vars</span><span class="p">)</span>\
</span><span id="LaggedAnalyser.bootstrap_significance-642"><a href="#LaggedAnalyser.bootstrap_significance-642"><span class="linenos">642</span></a>                        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">lag_vals</span><span class="p">]],</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sortby</span><span class="p">(</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span>
</span><span id="LaggedAnalyser.bootstrap_significance-643"><a href="#LaggedAnalyser.bootstrap_significance-643"><span class="linenos">643</span></a>                
</span><span id="LaggedAnalyser.bootstrap_significance-644"><a href="#LaggedAnalyser.bootstrap_significance-644"><span class="linenos">644</span></a>        <span class="n">sig_composite</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_significance</span><span class="p">(</span><span class="n">boots</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">composites</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">data_vars</span><span class="p">,</span><span class="n">hb_correction</span><span class="o">=</span><span class="n">hb_correction</span><span class="p">)</span>
</span><span id="LaggedAnalyser.bootstrap_significance-645"><a href="#LaggedAnalyser.bootstrap_significance-645"><span class="linenos">645</span></a>        
</span><span id="LaggedAnalyser.bootstrap_significance-646"><a href="#LaggedAnalyser.bootstrap_significance-646"><span class="linenos">646</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span><span class="o">=</span><span class="n">sig_composite</span>
</span><span id="LaggedAnalyser.bootstrap_significance-647"><a href="#LaggedAnalyser.bootstrap_significance-647"><span class="linenos">647</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">composite_sigs</span>
</span></pre></div>


            <div class="docstring"><p>A wrapper around <em>compute_bootstraps</em> and <em>get_significance</em>, that calculates bootstraps and applies a significance test to a number of time lagged composites simulataneously.</p>

<p><strong>Arguments</strong></p>

<p><em>bootnum</em></p>

<p>An integer, the number of bootstrapped composites to compute</p>

<p><em>p</em></p>

<p>A float, specifying the p-value of the 2-sided significance test (values in the range 0 to 1). </p>

<p><strong>Optional arguments</strong></p>

<p><em>dim</em></p>

<p>A string, the name of the shared coordinate between <em>LaggedAnalyser.variables</em> and <em>LaggedAnalyser.event</em>.</p>

<p><em>synth_mode</em></p>

<p>A string, specifying how synthetic event indices are to be computed. Valid options are:
"random": categorical values are randomly chosen with the same probability of occurrence as those found in <em>LaggedAnalyser.event</em>, but with no autocorrelation.
'markov': A first order Markov chain is fitted to <em>LaggedAnalyser.event</em>, producing some autocorrelation and state dependence in the synthetic series. Generally a better approximation than "random" and so should normally be used.</p>

<p><em>reuse_lag0_boots</em>
    A Boolean. If True, bootstraps are only computed for lag=0, and then used as a null distribution to assess all lagged composites. For variables which are approximately stationary across the lag timescale, then this is a good approximation and can increase performance. However if used incorrectly, it may lead to 'significant composites' which simply reflect the seasonal cycle. if False, separate bootstraps are computed for all time lags.</p>

<p><em>data_vars</em>
    An iterable of strings, specifying for which variables significance should be computed.</p>

<p><em>hb_correction</em>
    A Boolean, specifying whether a Holm-Bonferroni correction should be applied to <em>p</em>, in order to reduce the family-wide error rate. Note that this correction is currently only applied to each variable in <em>comp</em> independently, and so will have no impact on scalar variables.</p>

<p><strong>returns</strong></p>

<p>An xarray.Dataset like <em>LaggedAnalyser.variables</em> but with the <em>dim</em> dimension summarised according to <em>con_func</em> and <em>cat_func</em>, an additional <em>lag</em> coordinate, and with boolean data specifying whether each feature of each variable passed the significance test.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.deseasonalise_variables" class="classattr">
                                        <input id="LaggedAnalyser.deseasonalise_variables-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">deseasonalise_variables</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">variable_list</span><span class="o">=</span><span class="kc">None</span>,</span><span class="param">	<span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span>,</span><span class="param">	<span class="n">agg</span><span class="o">=</span><span class="s1">&#39;dayofyear&#39;</span>,</span><span class="param">	<span class="n">smooth</span><span class="o">=</span><span class="mi">1</span>,</span><span class="param">	<span class="n">coeffs</span><span class="o">=</span><span class="kc">None</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.deseasonalise_variables-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.deseasonalise_variables"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.deseasonalise_variables-650"><a href="#LaggedAnalyser.deseasonalise_variables-650"><span class="linenos">650</span></a>    <span class="k">def</span> <span class="nf">deseasonalise_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">variable_list</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">agg</span><span class="o">=</span><span class="s1">&#39;dayofyear&#39;</span><span class="p">,</span><span class="n">smooth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">coeffs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-651"><a href="#LaggedAnalyser.deseasonalise_variables-651"><span class="linenos">651</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes a seasonal cycle for each variable in *LaggedAnalyser.variables* and subtracts it inplace, turning *LaggedAnalyser.variables* into deseasonalised anomalies. The seasonal cycle is computed via temporal aggregation of each variable over a given period - by default the calendar day of the year. This cycle can then be smoothed with an n-point rolling average.</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-652"><a href="#LaggedAnalyser.deseasonalise_variables-652"><span class="linenos">652</span></a>
</span><span id="LaggedAnalyser.deseasonalise_variables-653"><a href="#LaggedAnalyser.deseasonalise_variables-653"><span class="linenos">653</span></a><span class="sd">                **Optional arguments**</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-654"><a href="#LaggedAnalyser.deseasonalise_variables-654"><span class="linenos">654</span></a>
</span><span id="LaggedAnalyser.deseasonalise_variables-655"><a href="#LaggedAnalyser.deseasonalise_variables-655"><span class="linenos">655</span></a><span class="sd">                *variable_list*</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-656"><a href="#LaggedAnalyser.deseasonalise_variables-656"><span class="linenos">656</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser.deseasonalise_variables-657"><a href="#LaggedAnalyser.deseasonalise_variables-657"><span class="linenos">657</span></a><span class="sd">                A list of variables to deseasonalise. Defaults to all variables in the *LaggedAnalyser.variables*</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-658"><a href="#LaggedAnalyser.deseasonalise_variables-658"><span class="linenos">658</span></a>
</span><span id="LaggedAnalyser.deseasonalise_variables-659"><a href="#LaggedAnalyser.deseasonalise_variables-659"><span class="linenos">659</span></a><span class="sd">                *dim*</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-660"><a href="#LaggedAnalyser.deseasonalise_variables-660"><span class="linenos">660</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser.deseasonalise_variables-661"><a href="#LaggedAnalyser.deseasonalise_variables-661"><span class="linenos">661</span></a><span class="sd">                A string, the name of the shared coordinate between *LaggedAnalyser.variables* and *LaggedAnalyser.event*, along which the seasonal cycle is computed. Currently, only timelike coordinates are supported.</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-662"><a href="#LaggedAnalyser.deseasonalise_variables-662"><span class="linenos">662</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser.deseasonalise_variables-663"><a href="#LaggedAnalyser.deseasonalise_variables-663"><span class="linenos">663</span></a><span class="sd">                *agg*</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-664"><a href="#LaggedAnalyser.deseasonalise_variables-664"><span class="linenos">664</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser.deseasonalise_variables-665"><a href="#LaggedAnalyser.deseasonalise_variables-665"><span class="linenos">665</span></a><span class="sd">                A string specifying the datetime-like field to aggregate over. Useful and supported values are &#39;season&#39;, &#39;month&#39;, &#39;weekofyear&#39;, and &#39;dayofyear&#39;</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-666"><a href="#LaggedAnalyser.deseasonalise_variables-666"><span class="linenos">666</span></a><span class="sd">                    </span>
</span><span id="LaggedAnalyser.deseasonalise_variables-667"><a href="#LaggedAnalyser.deseasonalise_variables-667"><span class="linenos">667</span></a><span class="sd">                *smooth*</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-668"><a href="#LaggedAnalyser.deseasonalise_variables-668"><span class="linenos">668</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser.deseasonalise_variables-669"><a href="#LaggedAnalyser.deseasonalise_variables-669"><span class="linenos">669</span></a><span class="sd">                An integer, specifying the size of the n-timestep centred rolling mean applied to the aggregated seasonal cycle. By default *smooth*=1 results in no smoothing.</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-670"><a href="#LaggedAnalyser.deseasonalise_variables-670"><span class="linenos">670</span></a>
</span><span id="LaggedAnalyser.deseasonalise_variables-671"><a href="#LaggedAnalyser.deseasonalise_variables-671"><span class="linenos">671</span></a><span class="sd">                *coeffs*</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-672"><a href="#LaggedAnalyser.deseasonalise_variables-672"><span class="linenos">672</span></a><span class="sd">                </span>
</span><span id="LaggedAnalyser.deseasonalise_variables-673"><a href="#LaggedAnalyser.deseasonalise_variables-673"><span class="linenos">673</span></a><span class="sd">                A Dataset containing a precomputed seasonal cycle, which, if *LaggedAnalyser.variables* has coordinates (*dim*,[X,Y,...,Z]), has coords (*agg*,[X,Y,...,Z]), and has the same data variables as *LaggedAnalyser.variables*. If *coeffs* is provided, no seasonal cycle is fitted to *LaggedAnalyser.variables*, *coeffs* is used instead.</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-674"><a href="#LaggedAnalyser.deseasonalise_variables-674"><span class="linenos">674</span></a>
</span><span id="LaggedAnalyser.deseasonalise_variables-675"><a href="#LaggedAnalyser.deseasonalise_variables-675"><span class="linenos">675</span></a><span class="sd">        &quot;&quot;&quot;</span>        
</span><span id="LaggedAnalyser.deseasonalise_variables-676"><a href="#LaggedAnalyser.deseasonalise_variables-676"><span class="linenos">676</span></a>
</span><span id="LaggedAnalyser.deseasonalise_variables-677"><a href="#LaggedAnalyser.deseasonalise_variables-677"><span class="linenos">677</span></a>        <span class="k">if</span> <span class="n">variable_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-678"><a href="#LaggedAnalyser.deseasonalise_variables-678"><span class="linenos">678</span></a>            <span class="n">variable_list</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-679"><a href="#LaggedAnalyser.deseasonalise_variables-679"><span class="linenos">679</span></a>        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">:</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-680"><a href="#LaggedAnalyser.deseasonalise_variables-680"><span class="linenos">680</span></a>            <span class="n">da</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-681"><a href="#LaggedAnalyser.deseasonalise_variables-681"><span class="linenos">681</span></a>            <span class="n">dsnlsr</span><span class="o">=</span><span class="n">Agg_Deseasonaliser</span><span class="p">()</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-682"><a href="#LaggedAnalyser.deseasonalise_variables-682"><span class="linenos">682</span></a>            <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-683"><a href="#LaggedAnalyser.deseasonalise_variables-683"><span class="linenos">683</span></a>                <span class="n">dsnlsr</span><span class="o">.</span><span class="n">fit_cycle</span><span class="p">(</span><span class="n">da</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span><span class="n">agg</span><span class="o">=</span><span class="n">agg</span><span class="p">)</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-684"><a href="#LaggedAnalyser.deseasonalise_variables-684"><span class="linenos">684</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-685"><a href="#LaggedAnalyser.deseasonalise_variables-685"><span class="linenos">685</span></a>                <span class="n">dsnslr</span><span class="o">.</span><span class="n">cycle_coeffs</span><span class="o">=</span><span class="n">coeffs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-686"><a href="#LaggedAnalyser.deseasonalise_variables-686"><span class="linenos">686</span></a>
</span><span id="LaggedAnalyser.deseasonalise_variables-687"><a href="#LaggedAnalyser.deseasonalise_variables-687"><span class="linenos">687</span></a>            <span class="n">cycle</span><span class="o">=</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">evaluate_cycle</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">da</span><span class="p">[</span><span class="n">dim</span><span class="p">],</span><span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">)</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-688"><a href="#LaggedAnalyser.deseasonalise_variables-688"><span class="linenos">688</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">da</span><span class="o">.</span><span class="n">data</span><span class="o">-</span><span class="n">cycle</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-689"><a href="#LaggedAnalyser.deseasonalise_variables-689"><span class="linenos">689</span></a>            <span class="n">dsnlsr</span><span class="o">.</span><span class="n">data</span><span class="o">=</span><span class="kc">None</span> <span class="c1">#Prevents excess memory storage</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-690"><a href="#LaggedAnalyser.deseasonalise_variables-690"><span class="linenos">690</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">dsnlsr</span>
</span><span id="LaggedAnalyser.deseasonalise_variables-691"><a href="#LaggedAnalyser.deseasonalise_variables-691"><span class="linenos">691</span></a>        <span class="k">return</span>   
</span></pre></div>


            <div class="docstring"><p>Computes a seasonal cycle for each variable in <em>LaggedAnalyser.variables</em> and subtracts it inplace, turning <em>LaggedAnalyser.variables</em> into deseasonalised anomalies. The seasonal cycle is computed via temporal aggregation of each variable over a given period - by default the calendar day of the year. This cycle can then be smoothed with an n-point rolling average.</p>

<p><strong>Optional arguments</strong></p>

<p><em>variable_list</em></p>

<p>A list of variables to deseasonalise. Defaults to all variables in the <em>LaggedAnalyser.variables</em></p>

<p><em>dim</em></p>

<p>A string, the name of the shared coordinate between <em>LaggedAnalyser.variables</em> and <em>LaggedAnalyser.event</em>, along which the seasonal cycle is computed. Currently, only timelike coordinates are supported.</p>

<p><em>agg</em></p>

<p>A string specifying the datetime-like field to aggregate over. Useful and supported values are 'season', 'month', 'weekofyear', and 'dayofyear'</p>

<p><em>smooth</em></p>

<p>An integer, specifying the size of the n-timestep centred rolling mean applied to the aggregated seasonal cycle. By default <em>smooth</em>=1 results in no smoothing.</p>

<p><em>coeffs</em></p>

<p>A Dataset containing a precomputed seasonal cycle, which, if <em>LaggedAnalyser.variables</em> has coordinates (<em>dim</em>,[X,Y,...,Z]), has coords (<em>agg</em>,[X,Y,...,Z]), and has the same data variables as <em>LaggedAnalyser.variables</em>. If <em>coeffs</em> is provided, no seasonal cycle is fitted to <em>LaggedAnalyser.variables</em>, <em>coeffs</em> is used instead.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.get_seasonal_cycle_coeffs" class="classattr">
                                        <input id="LaggedAnalyser.get_seasonal_cycle_coeffs-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_seasonal_cycle_coeffs</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.get_seasonal_cycle_coeffs-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.get_seasonal_cycle_coeffs"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.get_seasonal_cycle_coeffs-693"><a href="#LaggedAnalyser.get_seasonal_cycle_coeffs-693"><span class="linenos">693</span></a>    <span class="k">def</span> <span class="nf">get_seasonal_cycle_coeffs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="LaggedAnalyser.get_seasonal_cycle_coeffs-694"><a href="#LaggedAnalyser.get_seasonal_cycle_coeffs-694"><span class="linenos">694</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Retrieve seasonal cycle coeffs computed with *LaggedAnalyser.deseasonalise_variables*, suitable for passing into *coeffs* in other *LaggedAnalyser.deseasonalise_variables* function calls as a precomputed cycle.</span>
</span><span id="LaggedAnalyser.get_seasonal_cycle_coeffs-695"><a href="#LaggedAnalyser.get_seasonal_cycle_coeffs-695"><span class="linenos">695</span></a><span class="sd">        </span>
</span><span id="LaggedAnalyser.get_seasonal_cycle_coeffs-696"><a href="#LaggedAnalyser.get_seasonal_cycle_coeffs-696"><span class="linenos">696</span></a><span class="sd">        **Returns**</span>
</span><span id="LaggedAnalyser.get_seasonal_cycle_coeffs-697"><a href="#LaggedAnalyser.get_seasonal_cycle_coeffs-697"><span class="linenos">697</span></a><span class="sd">        An xarray.Dataset, as specified in  the *LaggedAnalyser.deseasonalise_variables* *coeff* optional keyword.</span>
</span><span id="LaggedAnalyser.get_seasonal_cycle_coeffs-698"><a href="#LaggedAnalyser.get_seasonal_cycle_coeffs-698"><span class="linenos">698</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.get_seasonal_cycle_coeffs-699"><a href="#LaggedAnalyser.get_seasonal_cycle_coeffs-699"><span class="linenos">699</span></a>        <span class="n">coeffs</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">({</span><span class="n">v</span><span class="p">:</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">cycle_coeffs</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">dsnlsr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
</span><span id="LaggedAnalyser.get_seasonal_cycle_coeffs-700"><a href="#LaggedAnalyser.get_seasonal_cycle_coeffs-700"><span class="linenos">700</span></a>        <span class="k">return</span> <span class="n">coeffs</span>
</span></pre></div>


            <div class="docstring"><p>Retrieve seasonal cycle coeffs computed with <em><a href="#LaggedAnalyser.deseasonalise_variables">LaggedAnalyser.deseasonalise_variables</a></em>, suitable for passing into <em>coeffs</em> in other <em><a href="#LaggedAnalyser.deseasonalise_variables">LaggedAnalyser.deseasonalise_variables</a></em> function calls as a precomputed cycle.</p>

<p><strong>Returns</strong>
An xarray.Dataset, as specified in  the <em><a href="#LaggedAnalyser.deseasonalise_variables">LaggedAnalyser.deseasonalise_variables</a></em> <em>coeff</em> optional keyword.</p>
</div>


                            </div>
                            <div id="LaggedAnalyser.get_composite_seasonal_mean" class="classattr">
                                        <input id="LaggedAnalyser.get_composite_seasonal_mean-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_composite_seasonal_mean</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="LaggedAnalyser.get_composite_seasonal_mean-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#LaggedAnalyser.get_composite_seasonal_mean"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="LaggedAnalyser.get_composite_seasonal_mean-705"><a href="#LaggedAnalyser.get_composite_seasonal_mean-705"><span class="linenos">705</span></a>    <span class="k">def</span> <span class="nf">get_composite_seasonal_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-706"><a href="#LaggedAnalyser.get_composite_seasonal_mean-706"><span class="linenos">706</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-707"><a href="#LaggedAnalyser.get_composite_seasonal_mean-707"><span class="linenos">707</span></a><span class="sd">        If *LaggedAnalyser.deseasonalise_variables* has been called, then this function returns the seasonal mean state corresponding to a given composite, given by a sum of the seasonal cycle weighted by the time-varying occurrence of each categorical value in *LaggedAnalyser.events*. This mean state + the deseasonalised anomaly composite</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-708"><a href="#LaggedAnalyser.get_composite_seasonal_mean-708"><span class="linenos">708</span></a><span class="sd">    produced by *LaggedAnalyser.compute_composites* then retrieves the full composite pattern.</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-709"><a href="#LaggedAnalyser.get_composite_seasonal_mean-709"><span class="linenos">709</span></a><span class="sd">    </span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-710"><a href="#LaggedAnalyser.get_composite_seasonal_mean-710"><span class="linenos">710</span></a><span class="sd">    **Returns**</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-711"><a href="#LaggedAnalyser.get_composite_seasonal_mean-711"><span class="linenos">711</span></a><span class="sd">        An xarray.Dataset containing the composite seasonal mean values.</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-712"><a href="#LaggedAnalyser.get_composite_seasonal_mean-712"><span class="linenos">712</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-713"><a href="#LaggedAnalyser.get_composite_seasonal_mean-713"><span class="linenos">713</span></a>        <span class="n">variable_list</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="p">)</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-714"><a href="#LaggedAnalyser.get_composite_seasonal_mean-714"><span class="linenos">714</span></a>        <span class="n">ts</span><span class="o">=</span><span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="o">==</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">time</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event</span><span class="p">)}</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-715"><a href="#LaggedAnalyser.get_composite_seasonal_mean-715"><span class="linenos">715</span></a>        <span class="n">lags</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_lagged_variables</span><span class="p">)])</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-716"><a href="#LaggedAnalyser.get_composite_seasonal_mean-716"><span class="linenos">716</span></a>        
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-717"><a href="#LaggedAnalyser.get_composite_seasonal_mean-717"><span class="linenos">717</span></a>        <span class="n">mean_states</span><span class="o">=</span><span class="p">{}</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-718"><a href="#LaggedAnalyser.get_composite_seasonal_mean-718"><span class="linenos">718</span></a>        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_list</span><span class="p">:</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-719"><a href="#LaggedAnalyser.get_composite_seasonal_mean-719"><span class="linenos">719</span></a>            <span class="n">dsnlsr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_deseasonalisers</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-720"><a href="#LaggedAnalyser.get_composite_seasonal_mean-720"><span class="linenos">720</span></a>            <span class="n">agg</span><span class="o">=</span><span class="n">dsnlsr</span><span class="o">.</span><span class="n">agg</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-721"><a href="#LaggedAnalyser.get_composite_seasonal_mean-721"><span class="linenos">721</span></a>            <span class="n">mean_states</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>\
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-722"><a href="#LaggedAnalyser.get_composite_seasonal_mean-722"><span class="linenos">722</span></a>                                 <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span>\
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-723"><a href="#LaggedAnalyser.get_composite_seasonal_mean-723"><span class="linenos">723</span></a>                                    <span class="bp">self</span><span class="o">.</span><span class="n">_lag_average_cycle</span><span class="p">(</span><span class="n">dsnlsr</span><span class="p">,</span><span class="n">agg</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>\
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-724"><a href="#LaggedAnalyser.get_composite_seasonal_mean-724"><span class="linenos">724</span></a>                                <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">lags</span><span class="p">],</span><span class="s1">&#39;lag&#39;</span><span class="p">)</span>\
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-725"><a href="#LaggedAnalyser.get_composite_seasonal_mean-725"><span class="linenos">725</span></a>                            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span><span class="s1">&#39;index_val&#39;</span><span class="p">)</span>
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-726"><a href="#LaggedAnalyser.get_composite_seasonal_mean-726"><span class="linenos">726</span></a>            
</span><span id="LaggedAnalyser.get_composite_seasonal_mean-727"><a href="#LaggedAnalyser.get_composite_seasonal_mean-727"><span class="linenos">727</span></a>        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">mean_states</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>If <em><a href="#LaggedAnalyser.deseasonalise_variables">LaggedAnalyser.deseasonalise_variables</a></em> has been called, then this function returns the seasonal mean state corresponding to a given composite, given by a sum of the seasonal cycle weighted by the time-varying occurrence of each categorical value in <em>LaggedAnalyser.events</em>. This mean state + the deseasonalised anomaly composite
produced by <em><a href="#LaggedAnalyser.compute_composites">LaggedAnalyser.compute_composites</a></em> then retrieves the full composite pattern.</p>

<p><strong>Returns</strong>
    An xarray.Dataset containing the composite seasonal mean values.</p>
</div>


                            </div>
                </section>
                <section id="PatternFilter">
                            <input id="PatternFilter-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr class">
            
    <span class="def">class</span>
    <span class="name">PatternFilter</span>:

                <label class="view-source-button" for="PatternFilter-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#PatternFilter"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="PatternFilter-737"><a href="#PatternFilter-737"><span class="linenos">737</span></a><span class="k">class</span> <span class="nc">PatternFilter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span id="PatternFilter-738"><a href="#PatternFilter-738"><span class="linenos">738</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot;Provides filtering methods to refine n-dimensional boolean masks, and apply them to an underlying dataset.</span>
</span><span id="PatternFilter-739"><a href="#PatternFilter-739"><span class="linenos">739</span></a><span class="sd">    </span>
</span><span id="PatternFilter-740"><a href="#PatternFilter-740"><span class="linenos">740</span></a><span class="sd">        **Optional arguments:**</span>
</span><span id="PatternFilter-741"><a href="#PatternFilter-741"><span class="linenos">741</span></a><span class="sd">        </span>
</span><span id="PatternFilter-742"><a href="#PatternFilter-742"><span class="linenos">742</span></a><span class="sd">        *mask_ds*</span>
</span><span id="PatternFilter-743"><a href="#PatternFilter-743"><span class="linenos">743</span></a><span class="sd">        </span>
</span><span id="PatternFilter-744"><a href="#PatternFilter-744"><span class="linenos">744</span></a><span class="sd">        An xarray boolean Dataset of arbitrary dimensions which provides the initial mask dataset. If *mask_ds*=None  and *analyser*=None, then *mask_ds* will be initialised as a Dataset of the same dimensions and data_vars as *val_ds*, with all values = 1 (i.e. initially unmasked). </span>
</span><span id="PatternFilter-745"><a href="#PatternFilter-745"><span class="linenos">745</span></a><span class="sd">        </span>
</span><span id="PatternFilter-746"><a href="#PatternFilter-746"><span class="linenos">746</span></a><span class="sd">        *val_ds*</span>
</span><span id="PatternFilter-747"><a href="#PatternFilter-747"><span class="linenos">747</span></a><span class="sd">        </span>
</span><span id="PatternFilter-748"><a href="#PatternFilter-748"><span class="linenos">748</span></a><span class="sd">        An xarray Dataset with the same dimensions as *mask_ds* if provided, otherwise arbitrary, consisting of an underlying dataset to which the mask is applied. If *val_ds*=None and *analyser*=None, then *PatternFilter.apply_value_mask* will raise an Error</span>
</span><span id="PatternFilter-749"><a href="#PatternFilter-749"><span class="linenos">749</span></a><span class="sd">            </span>
</span><span id="PatternFilter-750"><a href="#PatternFilter-750"><span class="linenos">750</span></a><span class="sd">        *analyser*</span>
</span><span id="PatternFilter-751"><a href="#PatternFilter-751"><span class="linenos">751</span></a><span class="sd">        </span>
</span><span id="PatternFilter-752"><a href="#PatternFilter-752"><span class="linenos">752</span></a><span class="sd">        An instance of a  core.LaggedAnalyser class for which both composites and significance masks have been computed, used to infer the *val_ds* and *mask_ds* arguments respectively. This overrides any values passed explicitly to  *mask_ds* and *val_ds*.</span>
</span><span id="PatternFilter-753"><a href="#PatternFilter-753"><span class="linenos">753</span></a><span class="sd">            </span>
</span><span id="PatternFilter-754"><a href="#PatternFilter-754"><span class="linenos">754</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="PatternFilter-755"><a href="#PatternFilter-755"><span class="linenos">755</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mask_ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">val_ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">analyser</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="PatternFilter-756"><a href="#PatternFilter-756"><span class="linenos">756</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise a new PatternFilter object&quot;&quot;&quot;</span>
</span><span id="PatternFilter-757"><a href="#PatternFilter-757"><span class="linenos">757</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">mask_ds</span>
</span><span id="PatternFilter-758"><a href="#PatternFilter-758"><span class="linenos">758</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="PatternFilter-759"><a href="#PatternFilter-759"><span class="linenos">759</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="o">=</span><span class="n">val_ds</span>
</span><span id="PatternFilter-760"><a href="#PatternFilter-760"><span class="linenos">760</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="PatternFilter-761"><a href="#PatternFilter-761"><span class="linenos">761</span></a>
</span><span id="PatternFilter-762"><a href="#PatternFilter-762"><span class="linenos">762</span></a>        <span class="k">if</span> <span class="n">analyser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="PatternFilter-763"><a href="#PatternFilter-763"><span class="linenos">763</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_analyser</span><span class="p">(</span><span class="n">analyser</span><span class="p">)</span>
</span><span id="PatternFilter-764"><a href="#PatternFilter-764"><span class="linenos">764</span></a>            
</span><span id="PatternFilter-765"><a href="#PatternFilter-765"><span class="linenos">765</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="PatternFilter-766"><a href="#PatternFilter-766"><span class="linenos">766</span></a>            <span class="k">if</span> <span class="n">mask_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="PatternFilter-767"><a href="#PatternFilter-767"><span class="linenos">767</span></a>                <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask_ds_like_val_ds</span><span class="p">()</span>
</span><span id="PatternFilter-768"><a href="#PatternFilter-768"><span class="linenos">768</span></a>                
</span><span id="PatternFilter-769"><a href="#PatternFilter-769"><span class="linenos">769</span></a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="PatternFilter-770"><a href="#PatternFilter-770"><span class="linenos">770</span></a>        <span class="k">return</span> <span class="s1">&#39;A PatternFilter object&#39;</span>
</span><span id="PatternFilter-771"><a href="#PatternFilter-771"><span class="linenos">771</span></a>        
</span><span id="PatternFilter-772"><a href="#PatternFilter-772"><span class="linenos">772</span></a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="PatternFilter-773"><a href="#PatternFilter-773"><span class="linenos">773</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span>
</span><span id="PatternFilter-774"><a href="#PatternFilter-774"><span class="linenos">774</span></a>        
</span><span id="PatternFilter-775"><a href="#PatternFilter-775"><span class="linenos">775</span></a>    <span class="k">def</span> <span class="nf">_parse_analyser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">analyser</span><span class="p">):</span>
</span><span id="PatternFilter-776"><a href="#PatternFilter-776"><span class="linenos">776</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">analyser</span><span class="o">.</span><span class="n">composite_sigs</span>
</span><span id="PatternFilter-777"><a href="#PatternFilter-777"><span class="linenos">777</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="o">=</span><span class="n">analyser</span><span class="o">.</span><span class="n">composites</span>
</span><span id="PatternFilter-778"><a href="#PatternFilter-778"><span class="linenos">778</span></a>        
</span><span id="PatternFilter-779"><a href="#PatternFilter-779"><span class="linenos">779</span></a>    <span class="k">def</span> <span class="nf">_mask_ds_like_val_ds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="PatternFilter-780"><a href="#PatternFilter-780"><span class="linenos">780</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="PatternFilter-781"><a href="#PatternFilter-781"><span class="linenos">781</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one of &quot;mask_ds&quot;, &quot;val_ds&quot; and &quot;analyser&quot; must be provided.&#39;</span><span class="p">))</span>
</span><span id="PatternFilter-782"><a href="#PatternFilter-782"><span class="linenos">782</span></a>        
</span><span id="PatternFilter-783"><a href="#PatternFilter-783"><span class="linenos">783</span></a>        <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span>
</span><span id="PatternFilter-784"><a href="#PatternFilter-784"><span class="linenos">784</span></a>        <span class="n">y</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">x</span><span class="o">!=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#replace nans and 0s with 1</span>
</span><span id="PatternFilter-785"><a href="#PatternFilter-785"><span class="linenos">785</span></a>        <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1">#make everything 1 via division and assert integer type.</span>
</span><span id="PatternFilter-786"><a href="#PatternFilter-786"><span class="linenos">786</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">y</span>
</span><span id="PatternFilter-787"><a href="#PatternFilter-787"><span class="linenos">787</span></a>        <span class="k">return</span>
</span><span id="PatternFilter-788"><a href="#PatternFilter-788"><span class="linenos">788</span></a>    
</span><span id="PatternFilter-789"><a href="#PatternFilter-789"><span class="linenos">789</span></a>    <span class="k">def</span> <span class="nf">update_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_mask</span><span class="p">,</span><span class="n">mode</span><span class="p">):</span>
</span><span id="PatternFilter-790"><a href="#PatternFilter-790"><span class="linenos">790</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Update *PatternFilter.mask_ds* with a new mask, either taking their union or intersection, or replacing the current mask with new_mask.</span>
</span><span id="PatternFilter-791"><a href="#PatternFilter-791"><span class="linenos">791</span></a><span class="sd">        </span>
</span><span id="PatternFilter-792"><a href="#PatternFilter-792"><span class="linenos">792</span></a><span class="sd">        **Arguments**</span>
</span><span id="PatternFilter-793"><a href="#PatternFilter-793"><span class="linenos">793</span></a><span class="sd">        </span>
</span><span id="PatternFilter-794"><a href="#PatternFilter-794"><span class="linenos">794</span></a><span class="sd">        *new_mask*</span>
</span><span id="PatternFilter-795"><a href="#PatternFilter-795"><span class="linenos">795</span></a>
</span><span id="PatternFilter-796"><a href="#PatternFilter-796"><span class="linenos">796</span></a><span class="sd">        An xarray.Dataset with the same coords and variables as *PatternFilter.mask_ds*.</span>
</span><span id="PatternFilter-797"><a href="#PatternFilter-797"><span class="linenos">797</span></a>
</span><span id="PatternFilter-798"><a href="#PatternFilter-798"><span class="linenos">798</span></a><span class="sd">        *mode*</span>
</span><span id="PatternFilter-799"><a href="#PatternFilter-799"><span class="linenos">799</span></a>
</span><span id="PatternFilter-800"><a href="#PatternFilter-800"><span class="linenos">800</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how *new_mask* should be used to update the mask.</span>
</span><span id="PatternFilter-801"><a href="#PatternFilter-801"><span class="linenos">801</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="PatternFilter-802"><a href="#PatternFilter-802"><span class="linenos">802</span></a>        <span class="n">new_mask</span><span class="o">=</span><span class="n">new_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</span><span id="PatternFilter-803"><a href="#PatternFilter-803"><span class="linenos">803</span></a>        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;replace&#39;</span><span class="p">:</span>
</span><span id="PatternFilter-804"><a href="#PatternFilter-804"><span class="linenos">804</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">new_mask</span>
</span><span id="PatternFilter-805"><a href="#PatternFilter-805"><span class="linenos">805</span></a>        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;intersection&#39;</span><span class="p">:</span>
</span><span id="PatternFilter-806"><a href="#PatternFilter-806"><span class="linenos">806</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">*</span><span class="n">new_mask</span>
</span><span id="PatternFilter-807"><a href="#PatternFilter-807"><span class="linenos">807</span></a>        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;union&#39;</span><span class="p">:</span>
</span><span id="PatternFilter-808"><a href="#PatternFilter-808"><span class="linenos">808</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">|</span><span class="n">new_mask</span>
</span><span id="PatternFilter-809"><a href="#PatternFilter-809"><span class="linenos">809</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="PatternFilter-810"><a href="#PatternFilter-810"><span class="linenos">810</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid mode, </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span>
</span><span id="PatternFilter-811"><a href="#PatternFilter-811"><span class="linenos">811</span></a>        <span class="k">return</span>
</span><span id="PatternFilter-812"><a href="#PatternFilter-812"><span class="linenos">812</span></a>                  
</span><span id="PatternFilter-813"><a href="#PatternFilter-813"><span class="linenos">813</span></a>    <span class="k">def</span> <span class="nf">apply_value_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">truth_function</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">):</span>
</span><span id="PatternFilter-814"><a href="#PatternFilter-814"><span class="linenos">814</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply a filter to *PatternFilter.mask_ds* based on a user-specified truth function which is applied to *PatternFilter.val_ds. </span>
</span><span id="PatternFilter-815"><a href="#PatternFilter-815"><span class="linenos">815</span></a><span class="sd">        </span>
</span><span id="PatternFilter-816"><a href="#PatternFilter-816"><span class="linenos">816</span></a><span class="sd">        **Examples**</span>
</span><span id="PatternFilter-817"><a href="#PatternFilter-817"><span class="linenos">817</span></a><span class="sd">        </span>
</span><span id="PatternFilter-818"><a href="#PatternFilter-818"><span class="linenos">818</span></a><span class="sd">            #Mask values beneath a threshold:</span>
</span><span id="PatternFilter-819"><a href="#PatternFilter-819"><span class="linenos">819</span></a><span class="sd">            def larger_than_thresh(ds,thresh):</span>
</span><span id="PatternFilter-820"><a href="#PatternFilter-820"><span class="linenos">820</span></a><span class="sd">                return ds&gt;thresh</span>
</span><span id="PatternFilter-821"><a href="#PatternFilter-821"><span class="linenos">821</span></a><span class="sd">            patternfilter.apply_value_mask(is_positive,thresh)</span>
</span><span id="PatternFilter-822"><a href="#PatternFilter-822"><span class="linenos">822</span></a>
</span><span id="PatternFilter-823"><a href="#PatternFilter-823"><span class="linenos">823</span></a><span class="sd">            #Mask values where absolute value is less than a reference field:</span>
</span><span id="PatternFilter-824"><a href="#PatternFilter-824"><span class="linenos">824</span></a><span class="sd">            def amp_greater_than_reference(ds,ref_ds):</span>
</span><span id="PatternFilter-825"><a href="#PatternFilter-825"><span class="linenos">825</span></a><span class="sd">                return np.abs(ds)&gt;ref_ds</span>
</span><span id="PatternFilter-826"><a href="#PatternFilter-826"><span class="linenos">826</span></a><span class="sd">            pattern_filter.apply_value_mask(amp_greater_than_reference,ref_ds)</span>
</span><span id="PatternFilter-827"><a href="#PatternFilter-827"><span class="linenos">827</span></a>
</span><span id="PatternFilter-828"><a href="#PatternFilter-828"><span class="linenos">828</span></a><span class="sd">        **Arguments**</span>
</span><span id="PatternFilter-829"><a href="#PatternFilter-829"><span class="linenos">829</span></a>
</span><span id="PatternFilter-830"><a href="#PatternFilter-830"><span class="linenos">830</span></a><span class="sd">        *truth_function*</span>
</span><span id="PatternFilter-831"><a href="#PatternFilter-831"><span class="linenos">831</span></a><span class="sd">        </span>
</span><span id="PatternFilter-832"><a href="#PatternFilter-832"><span class="linenos">832</span></a><span class="sd">        A function with inputs (val_ds,*args) that returns a boolean dataset with the same coords and data variables as *PatternFilter.val_ds*.</span>
</span><span id="PatternFilter-833"><a href="#PatternFilter-833"><span class="linenos">833</span></a>
</span><span id="PatternFilter-834"><a href="#PatternFilter-834"><span class="linenos">834</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="PatternFilter-835"><a href="#PatternFilter-835"><span class="linenos">835</span></a><span class="sd">        </span>
</span><span id="PatternFilter-836"><a href="#PatternFilter-836"><span class="linenos">836</span></a><span class="sd">        *mode*</span>
</span><span id="PatternFilter-837"><a href="#PatternFilter-837"><span class="linenos">837</span></a><span class="sd">            </span>
</span><span id="PatternFilter-838"><a href="#PatternFilter-838"><span class="linenos">838</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how the value filter should be used to update the *PatternFilter.mask_ds*.</span>
</span><span id="PatternFilter-839"><a href="#PatternFilter-839"><span class="linenos">839</span></a><span class="sd">        &quot;&quot;&quot;</span>        
</span><span id="PatternFilter-840"><a href="#PatternFilter-840"><span class="linenos">840</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="PatternFilter-841"><a href="#PatternFilter-841"><span class="linenos">841</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;val_ds must be provided to apply value mask.&#39;</span><span class="p">))</span>
</span><span id="PatternFilter-842"><a href="#PatternFilter-842"><span class="linenos">842</span></a>        <span class="n">value_mask</span><span class="o">=</span><span class="n">truth_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span id="PatternFilter-843"><a href="#PatternFilter-843"><span class="linenos">843</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">update_mask</span><span class="p">(</span><span class="n">value_mask</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="PatternFilter-844"><a href="#PatternFilter-844"><span class="linenos">844</span></a>        <span class="k">return</span>
</span><span id="PatternFilter-845"><a href="#PatternFilter-845"><span class="linenos">845</span></a>    
</span><span id="PatternFilter-846"><a href="#PatternFilter-846"><span class="linenos">846</span></a>    <span class="k">def</span> <span class="nf">apply_area_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">,</span><span class="n">area_type</span><span class="o">=</span><span class="s1">&#39;gridpoint&#39;</span><span class="p">):</span>
</span><span id="PatternFilter-847"><a href="#PatternFilter-847"><span class="linenos">847</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply a filter to *PatternFilter.mask_ds* that identifies connected groups of True values within a subspace of the Dataset&#39;s dimensions specified by *dims*, and masks out groups which are beneath a threshold size *n*. This is done through the application of *scipy.ndimage.label* using the default structuring element (https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.label.html). </span>
</span><span id="PatternFilter-848"><a href="#PatternFilter-848"><span class="linenos">848</span></a><span class="sd">    </span>
</span><span id="PatternFilter-849"><a href="#PatternFilter-849"><span class="linenos">849</span></a><span class="sd">        When *area_type*=&#39;gridpoint&#39;, *n* specifies the number of connected datapoints within each connected region. For the special case where *dims* consists of a latitude- and longitude-like coordinate, area_type=&#39;spherical&#39; applies a cosine-latitude weighting, such that *n* can be interpreted as a measure of area, where a datapoint with lat=0 would have area 1. </span>
</span><span id="PatternFilter-850"><a href="#PatternFilter-850"><span class="linenos">850</span></a><span class="sd">        </span>
</span><span id="PatternFilter-851"><a href="#PatternFilter-851"><span class="linenos">851</span></a><span class="sd">        **Examples**</span>
</span><span id="PatternFilter-852"><a href="#PatternFilter-852"><span class="linenos">852</span></a><span class="sd">        </span>
</span><span id="PatternFilter-853"><a href="#PatternFilter-853"><span class="linenos">853</span></a><span class="sd">            #Keep groups of True values consisting of an area &gt;=30 square equatorial gridpoints</span>
</span><span id="PatternFilter-854"><a href="#PatternFilter-854"><span class="linenos">854</span></a><span class="sd">            patternfilter.apply_area_mask(30,dims=(&#39;lat&#39;,&#39;lon&#39;),area_type=&#39;spherical&#39;)</span>
</span><span id="PatternFilter-855"><a href="#PatternFilter-855"><span class="linenos">855</span></a><span class="sd">            </span>
</span><span id="PatternFilter-856"><a href="#PatternFilter-856"><span class="linenos">856</span></a><span class="sd">            #Keep groups of True values that are consistent for at least 3 neighbouring time lags</span>
</span><span id="PatternFilter-857"><a href="#PatternFilter-857"><span class="linenos">857</span></a><span class="sd">            patternfilter.apply_area_mask(3,dims=(&#39;time&#39;))</span>
</span><span id="PatternFilter-858"><a href="#PatternFilter-858"><span class="linenos">858</span></a><span class="sd">            </span>
</span><span id="PatternFilter-859"><a href="#PatternFilter-859"><span class="linenos">859</span></a><span class="sd">            #Keep groups of true values consisting of &gt;=10 longitudinal values, or &gt;=30 values in longitude and altitude if the variables have an altitude coord:</span>
</span><span id="PatternFilter-860"><a href="#PatternFilter-860"><span class="linenos">860</span></a><span class="sd">            patternfilter.apply_area_mask(10,dims=(&#39;longitude&#39;))</span>
</span><span id="PatternFilter-861"><a href="#PatternFilter-861"><span class="linenos">861</span></a><span class="sd">            patternfilter.apply_area_mask(30,dims=(&#39;longitude,altitude&#39;),mode=&#39;union&#39;)</span>
</span><span id="PatternFilter-862"><a href="#PatternFilter-862"><span class="linenos">862</span></a>
</span><span id="PatternFilter-863"><a href="#PatternFilter-863"><span class="linenos">863</span></a><span class="sd">        **Arguments**</span>
</span><span id="PatternFilter-864"><a href="#PatternFilter-864"><span class="linenos">864</span></a>
</span><span id="PatternFilter-865"><a href="#PatternFilter-865"><span class="linenos">865</span></a><span class="sd">        *n*</span>
</span><span id="PatternFilter-866"><a href="#PatternFilter-866"><span class="linenos">866</span></a><span class="sd">            </span>
</span><span id="PatternFilter-867"><a href="#PatternFilter-867"><span class="linenos">867</span></a><span class="sd">        A scalar indicating the minimum size of an unmasked group, in terms of number of gridpoints (for *area_type*=gridpoint) or the weighted area (for *area_type*=spherical), beneath which the group will be masked.</span>
</span><span id="PatternFilter-868"><a href="#PatternFilter-868"><span class="linenos">868</span></a>
</span><span id="PatternFilter-869"><a href="#PatternFilter-869"><span class="linenos">869</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="PatternFilter-870"><a href="#PatternFilter-870"><span class="linenos">870</span></a><span class="sd">        </span>
</span><span id="PatternFilter-871"><a href="#PatternFilter-871"><span class="linenos">871</span></a><span class="sd">        *dims*</span>
</span><span id="PatternFilter-872"><a href="#PatternFilter-872"><span class="linenos">872</span></a><span class="sd">            </span>
</span><span id="PatternFilter-873"><a href="#PatternFilter-873"><span class="linenos">873</span></a><span class="sd">        An iterable of strings specifying coords in *PatternFilter.mask_ds* which define the subspace in which groups of connected True values are identified. Other dims will be iterated over. DataArrays within *PatternFilter.mask_ds* that do not contain all the *dims* will be ignored. If *dims*=None, all dims in each DataArray will be used.</span>
</span><span id="PatternFilter-874"><a href="#PatternFilter-874"><span class="linenos">874</span></a><span class="sd">            </span>
</span><span id="PatternFilter-875"><a href="#PatternFilter-875"><span class="linenos">875</span></a><span class="sd">        *mode*</span>
</span><span id="PatternFilter-876"><a href="#PatternFilter-876"><span class="linenos">876</span></a>
</span><span id="PatternFilter-877"><a href="#PatternFilter-877"><span class="linenos">877</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how the area filter should be used to update the *PatternFilter.mask_ds*.</span>
</span><span id="PatternFilter-878"><a href="#PatternFilter-878"><span class="linenos">878</span></a><span class="sd">            </span>
</span><span id="PatternFilter-879"><a href="#PatternFilter-879"><span class="linenos">879</span></a><span class="sd">        *area_type*</span>
</span><span id="PatternFilter-880"><a href="#PatternFilter-880"><span class="linenos">880</span></a>
</span><span id="PatternFilter-881"><a href="#PatternFilter-881"><span class="linenos">881</span></a><span class="sd">        A string, one of &#39;gridpoint&#39; or &#39;spherical&#39; as specified above. &#39;spherical&#39; is currently only supported for len-2 *dims* kwargs, with the first assumed to be latitude-like. </span>
</span><span id="PatternFilter-882"><a href="#PatternFilter-882"><span class="linenos">882</span></a><span class="sd">            </span>
</span><span id="PatternFilter-883"><a href="#PatternFilter-883"><span class="linenos">883</span></a><span class="sd">        &quot;&quot;&quot;</span>        
</span><span id="PatternFilter-884"><a href="#PatternFilter-884"><span class="linenos">884</span></a>        <span class="k">if</span> <span class="n">area_type</span><span class="o">==</span><span class="s1">&#39;gridpoint&#39;</span><span class="p">:</span>
</span><span id="PatternFilter-885"><a href="#PatternFilter-885"><span class="linenos">885</span></a>            <span class="n">area_based</span><span class="o">=</span><span class="kc">False</span>
</span><span id="PatternFilter-886"><a href="#PatternFilter-886"><span class="linenos">886</span></a>        <span class="k">elif</span> <span class="n">area_type</span><span class="o">==</span><span class="s1">&#39;spherical&#39;</span><span class="p">:</span>
</span><span id="PatternFilter-887"><a href="#PatternFilter-887"><span class="linenos">887</span></a>            <span class="n">area_based</span><span class="o">=</span><span class="kc">True</span>
</span><span id="PatternFilter-888"><a href="#PatternFilter-888"><span class="linenos">888</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="PatternFilter-889"><a href="#PatternFilter-889"><span class="linenos">889</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown area_type </span><span class="si">{</span><span class="n">area_type</span><span class="si">}</span><span class="s2">. Valid options are &#39;gridpoint&#39; and &#39;spherical&#39;&quot;</span><span class="p">))</span>
</span><span id="PatternFilter-890"><a href="#PatternFilter-890"><span class="linenos">890</span></a>        <span class="n">area_mask</span><span class="o">=</span><span class="n">ds_large_regions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span><span class="n">area_based</span><span class="o">=</span><span class="n">area_based</span><span class="p">)</span>
</span><span id="PatternFilter-891"><a href="#PatternFilter-891"><span class="linenos">891</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">update_mask</span><span class="p">(</span><span class="n">area_mask</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="PatternFilter-892"><a href="#PatternFilter-892"><span class="linenos">892</span></a>        <span class="k">return</span>
</span><span id="PatternFilter-893"><a href="#PatternFilter-893"><span class="linenos">893</span></a>    
</span><span id="PatternFilter-894"><a href="#PatternFilter-894"><span class="linenos">894</span></a>    
</span><span id="PatternFilter-895"><a href="#PatternFilter-895"><span class="linenos">895</span></a>    <span class="k">def</span> <span class="nf">apply_convolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">):</span>
</span><span id="PatternFilter-896"><a href="#PatternFilter-896"><span class="linenos">896</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply a square n-point convolution filter to *PatternFilter.mask_ds* in one or two dimensions specified by *dims*, iterated over remaining dimensions. This has the effect of extending the unmasked regions and smoothing the mask overall.</span>
</span><span id="PatternFilter-897"><a href="#PatternFilter-897"><span class="linenos">897</span></a><span class="sd">        </span>
</span><span id="PatternFilter-898"><a href="#PatternFilter-898"><span class="linenos">898</span></a><span class="sd">        **Arguments**</span>
</span><span id="PatternFilter-899"><a href="#PatternFilter-899"><span class="linenos">899</span></a><span class="sd">        </span>
</span><span id="PatternFilter-900"><a href="#PatternFilter-900"><span class="linenos">900</span></a><span class="sd">        *n*</span>
</span><span id="PatternFilter-901"><a href="#PatternFilter-901"><span class="linenos">901</span></a><span class="sd">            </span>
</span><span id="PatternFilter-902"><a href="#PatternFilter-902"><span class="linenos">902</span></a><span class="sd">        A positive integer specifying the size of the convolution filter. *n*=1 leaves the mask unchanged. Even *n* are asymmetric and shifted right. </span>
</span><span id="PatternFilter-903"><a href="#PatternFilter-903"><span class="linenos">903</span></a>
</span><span id="PatternFilter-904"><a href="#PatternFilter-904"><span class="linenos">904</span></a><span class="sd">        *dims*</span>
</span><span id="PatternFilter-905"><a href="#PatternFilter-905"><span class="linenos">905</span></a>
</span><span id="PatternFilter-906"><a href="#PatternFilter-906"><span class="linenos">906</span></a><span class="sd">        A length 1 or 2 iterable of strings specifying the dims in which the convolution is applied. Other dims will be iterated over. DataArrays within *PatternFilter.mask_ds* that do not contain all the *dims* will be ignored. </span>
</span><span id="PatternFilter-907"><a href="#PatternFilter-907"><span class="linenos">907</span></a>
</span><span id="PatternFilter-908"><a href="#PatternFilter-908"><span class="linenos">908</span></a><span class="sd">        *mode*</span>
</span><span id="PatternFilter-909"><a href="#PatternFilter-909"><span class="linenos">909</span></a>
</span><span id="PatternFilter-910"><a href="#PatternFilter-910"><span class="linenos">910</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how the area filter should be used to update the *PatternFilter.mask_ds*.</span>
</span><span id="PatternFilter-911"><a href="#PatternFilter-911"><span class="linenos">911</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="PatternFilter-912"><a href="#PatternFilter-912"><span class="linenos">912</span></a>        
</span><span id="PatternFilter-913"><a href="#PatternFilter-913"><span class="linenos">913</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
</span><span id="PatternFilter-914"><a href="#PatternFilter-914"><span class="linenos">914</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only 1 and 2D dims currently supported&#39;</span><span class="p">))</span>
</span><span id="PatternFilter-915"><a href="#PatternFilter-915"><span class="linenos">915</span></a>            
</span><span id="PatternFilter-916"><a href="#PatternFilter-916"><span class="linenos">916</span></a>        <span class="n">convolution</span><span class="o">=</span><span class="n">convolve_pad_ds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
</span><span id="PatternFilter-917"><a href="#PatternFilter-917"><span class="linenos">917</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">update_mask</span><span class="p">(</span><span class="n">convolution</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="PatternFilter-918"><a href="#PatternFilter-918"><span class="linenos">918</span></a>        <span class="k">return</span>
</span><span id="PatternFilter-919"><a href="#PatternFilter-919"><span class="linenos">919</span></a>    
</span><span id="PatternFilter-920"><a href="#PatternFilter-920"><span class="linenos">920</span></a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="PatternFilter-921"><a href="#PatternFilter-921"><span class="linenos">921</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot; Retrieve the mask with all filters applied.</span>
</span><span id="PatternFilter-922"><a href="#PatternFilter-922"><span class="linenos">922</span></a><span class="sd">        **Returns**</span>
</span><span id="PatternFilter-923"><a href="#PatternFilter-923"><span class="linenos">923</span></a><span class="sd">        An xarray.Dataset of boolean values.</span>
</span><span id="PatternFilter-924"><a href="#PatternFilter-924"><span class="linenos">924</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="PatternFilter-925"><a href="#PatternFilter-925"><span class="linenos">925</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span>
</span><span id="PatternFilter-926"><a href="#PatternFilter-926"><span class="linenos">926</span></a>    
</span><span id="PatternFilter-927"><a href="#PatternFilter-927"><span class="linenos">927</span></a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">drop_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">fill_val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
</span><span id="PatternFilter-928"><a href="#PatternFilter-928"><span class="linenos">928</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply the current mask to *ds* or to *PatternFilter.val_ds* (if *ds* is None), replacing masked gridpoints with *fill_val*.</span>
</span><span id="PatternFilter-929"><a href="#PatternFilter-929"><span class="linenos">929</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="PatternFilter-930"><a href="#PatternFilter-930"><span class="linenos">930</span></a><span class="sd">        </span>
</span><span id="PatternFilter-931"><a href="#PatternFilter-931"><span class="linenos">931</span></a><span class="sd">        *ds*</span>
</span><span id="PatternFilter-932"><a href="#PatternFilter-932"><span class="linenos">932</span></a><span class="sd">        </span>
</span><span id="PatternFilter-933"><a href="#PatternFilter-933"><span class="linenos">933</span></a><span class="sd">        An xarray.Dataset to apply the mask to. Should have the same coords and data_vars as *PatternFilter.mask_ds*. If None, the mask is applied to *PatternFilter.val_ds*.</span>
</span><span id="PatternFilter-934"><a href="#PatternFilter-934"><span class="linenos">934</span></a><span class="sd">        </span>
</span><span id="PatternFilter-935"><a href="#PatternFilter-935"><span class="linenos">935</span></a><span class="sd">        *drop_empty*</span>
</span><span id="PatternFilter-936"><a href="#PatternFilter-936"><span class="linenos">936</span></a><span class="sd">        </span>
</span><span id="PatternFilter-937"><a href="#PatternFilter-937"><span class="linenos">937</span></a><span class="sd">        A boolean value. If True, then completely masked variables are dropped from the returned masked Dataset.</span>
</span><span id="PatternFilter-938"><a href="#PatternFilter-938"><span class="linenos">938</span></a><span class="sd">        </span>
</span><span id="PatternFilter-939"><a href="#PatternFilter-939"><span class="linenos">939</span></a><span class="sd">        *fill_val*</span>
</span><span id="PatternFilter-940"><a href="#PatternFilter-940"><span class="linenos">940</span></a><span class="sd">        </span>
</span><span id="PatternFilter-941"><a href="#PatternFilter-941"><span class="linenos">941</span></a><span class="sd">        A scalar that defaults to np.nan. The value with which masked gridpoints in the Dataset are replaced.</span>
</span><span id="PatternFilter-942"><a href="#PatternFilter-942"><span class="linenos">942</span></a><span class="sd">        </span>
</span><span id="PatternFilter-943"><a href="#PatternFilter-943"><span class="linenos">943</span></a><span class="sd">        **Returns**</span>
</span><span id="PatternFilter-944"><a href="#PatternFilter-944"><span class="linenos">944</span></a><span class="sd">        </span>
</span><span id="PatternFilter-945"><a href="#PatternFilter-945"><span class="linenos">945</span></a><span class="sd">        A Dataset with masked values replaced by *fill_val*.</span>
</span><span id="PatternFilter-946"><a href="#PatternFilter-946"><span class="linenos">946</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="PatternFilter-947"><a href="#PatternFilter-947"><span class="linenos">947</span></a>        <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="PatternFilter-948"><a href="#PatternFilter-948"><span class="linenos">948</span></a>            <span class="n">ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="PatternFilter-949"><a href="#PatternFilter-949"><span class="linenos">949</span></a>            
</span><span id="PatternFilter-950"><a href="#PatternFilter-950"><span class="linenos">950</span></a>        <span class="n">ds</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="p">)</span>
</span><span id="PatternFilter-951"><a href="#PatternFilter-951"><span class="linenos">951</span></a>        <span class="k">if</span> <span class="n">drop_empty</span><span class="p">:</span>
</span><span id="PatternFilter-952"><a href="#PatternFilter-952"><span class="linenos">952</span></a>            <span class="n">drop_vars</span><span class="o">=</span><span class="p">((</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="s1">&#39;vars&#39;</span><span class="p">)</span>
</span><span id="PatternFilter-953"><a href="#PatternFilter-953"><span class="linenos">953</span></a>            <span class="n">ds</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">drop_vars</span><span class="p">[</span><span class="n">drop_vars</span><span class="p">]</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</span><span id="PatternFilter-954"><a href="#PatternFilter-954"><span class="linenos">954</span></a>        <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_val</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Provides filtering methods to refine n-dimensional boolean masks, and apply them to an underlying dataset.</p>

<p><strong>Optional arguments:</strong></p>

<p><em>mask_ds</em></p>

<p>An xarray boolean Dataset of arbitrary dimensions which provides the initial mask dataset. If <em>mask_ds</em>=None  and <em>analyser</em>=None, then <em>mask_ds</em> will be initialised as a Dataset of the same dimensions and data_vars as <em>val_ds</em>, with all values = 1 (i.e. initially unmasked). </p>

<p><em>val_ds</em></p>

<p>An xarray Dataset with the same dimensions as <em>mask_ds</em> if provided, otherwise arbitrary, consisting of an underlying dataset to which the mask is applied. If <em>val_ds</em>=None and <em>analyser</em>=None, then <em><a href="#PatternFilter.apply_value_mask">PatternFilter.apply_value_mask</a></em> will raise an Error</p>

<p><em>analyser</em></p>

<p>An instance of a  core.LaggedAnalyser class for which both composites and significance masks have been computed, used to infer the <em>val_ds</em> and <em>mask_ds</em> arguments respectively. This overrides any values passed explicitly to  <em>mask_ds</em> and <em>val_ds</em>.</p>
</div>


                            <div id="PatternFilter.__init__" class="classattr">
                                        <input id="PatternFilter.__init__-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="name">PatternFilter</span><span class="signature pdoc-code condensed">(<span class="param"><span class="n">mask_ds</span><span class="o">=</span><span class="kc">None</span>, </span><span class="param"><span class="n">val_ds</span><span class="o">=</span><span class="kc">None</span>, </span><span class="param"><span class="n">analyser</span><span class="o">=</span><span class="kc">None</span></span>)</span>

                <label class="view-source-button" for="PatternFilter.__init__-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#PatternFilter.__init__"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="PatternFilter.__init__-755"><a href="#PatternFilter.__init__-755"><span class="linenos">755</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mask_ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">val_ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">analyser</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="PatternFilter.__init__-756"><a href="#PatternFilter.__init__-756"><span class="linenos">756</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialise a new PatternFilter object&quot;&quot;&quot;</span>
</span><span id="PatternFilter.__init__-757"><a href="#PatternFilter.__init__-757"><span class="linenos">757</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">mask_ds</span>
</span><span id="PatternFilter.__init__-758"><a href="#PatternFilter.__init__-758"><span class="linenos">758</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="PatternFilter.__init__-759"><a href="#PatternFilter.__init__-759"><span class="linenos">759</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="o">=</span><span class="n">val_ds</span>
</span><span id="PatternFilter.__init__-760"><a href="#PatternFilter.__init__-760"><span class="linenos">760</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="PatternFilter.__init__-761"><a href="#PatternFilter.__init__-761"><span class="linenos">761</span></a>
</span><span id="PatternFilter.__init__-762"><a href="#PatternFilter.__init__-762"><span class="linenos">762</span></a>        <span class="k">if</span> <span class="n">analyser</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="PatternFilter.__init__-763"><a href="#PatternFilter.__init__-763"><span class="linenos">763</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">_parse_analyser</span><span class="p">(</span><span class="n">analyser</span><span class="p">)</span>
</span><span id="PatternFilter.__init__-764"><a href="#PatternFilter.__init__-764"><span class="linenos">764</span></a>            
</span><span id="PatternFilter.__init__-765"><a href="#PatternFilter.__init__-765"><span class="linenos">765</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="PatternFilter.__init__-766"><a href="#PatternFilter.__init__-766"><span class="linenos">766</span></a>            <span class="k">if</span> <span class="n">mask_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="PatternFilter.__init__-767"><a href="#PatternFilter.__init__-767"><span class="linenos">767</span></a>                <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask_ds_like_val_ds</span><span class="p">()</span>
</span></pre></div>


            <div class="docstring"><p>Initialise a new PatternFilter object</p>
</div>


                            </div>
                            <div id="PatternFilter.update_mask" class="classattr">
                                        <input id="PatternFilter.update_mask-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">update_mask</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">new_mask</span>, </span><span class="param"><span class="n">mode</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="PatternFilter.update_mask-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#PatternFilter.update_mask"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="PatternFilter.update_mask-789"><a href="#PatternFilter.update_mask-789"><span class="linenos">789</span></a>    <span class="k">def</span> <span class="nf">update_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">new_mask</span><span class="p">,</span><span class="n">mode</span><span class="p">):</span>
</span><span id="PatternFilter.update_mask-790"><a href="#PatternFilter.update_mask-790"><span class="linenos">790</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Update *PatternFilter.mask_ds* with a new mask, either taking their union or intersection, or replacing the current mask with new_mask.</span>
</span><span id="PatternFilter.update_mask-791"><a href="#PatternFilter.update_mask-791"><span class="linenos">791</span></a><span class="sd">        </span>
</span><span id="PatternFilter.update_mask-792"><a href="#PatternFilter.update_mask-792"><span class="linenos">792</span></a><span class="sd">        **Arguments**</span>
</span><span id="PatternFilter.update_mask-793"><a href="#PatternFilter.update_mask-793"><span class="linenos">793</span></a><span class="sd">        </span>
</span><span id="PatternFilter.update_mask-794"><a href="#PatternFilter.update_mask-794"><span class="linenos">794</span></a><span class="sd">        *new_mask*</span>
</span><span id="PatternFilter.update_mask-795"><a href="#PatternFilter.update_mask-795"><span class="linenos">795</span></a>
</span><span id="PatternFilter.update_mask-796"><a href="#PatternFilter.update_mask-796"><span class="linenos">796</span></a><span class="sd">        An xarray.Dataset with the same coords and variables as *PatternFilter.mask_ds*.</span>
</span><span id="PatternFilter.update_mask-797"><a href="#PatternFilter.update_mask-797"><span class="linenos">797</span></a>
</span><span id="PatternFilter.update_mask-798"><a href="#PatternFilter.update_mask-798"><span class="linenos">798</span></a><span class="sd">        *mode*</span>
</span><span id="PatternFilter.update_mask-799"><a href="#PatternFilter.update_mask-799"><span class="linenos">799</span></a>
</span><span id="PatternFilter.update_mask-800"><a href="#PatternFilter.update_mask-800"><span class="linenos">800</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how *new_mask* should be used to update the mask.</span>
</span><span id="PatternFilter.update_mask-801"><a href="#PatternFilter.update_mask-801"><span class="linenos">801</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="PatternFilter.update_mask-802"><a href="#PatternFilter.update_mask-802"><span class="linenos">802</span></a>        <span class="n">new_mask</span><span class="o">=</span><span class="n">new_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</span><span id="PatternFilter.update_mask-803"><a href="#PatternFilter.update_mask-803"><span class="linenos">803</span></a>        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;replace&#39;</span><span class="p">:</span>
</span><span id="PatternFilter.update_mask-804"><a href="#PatternFilter.update_mask-804"><span class="linenos">804</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="n">new_mask</span>
</span><span id="PatternFilter.update_mask-805"><a href="#PatternFilter.update_mask-805"><span class="linenos">805</span></a>        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s1">&#39;intersection&#39;</span><span class="p">:</span>
</span><span id="PatternFilter.update_mask-806"><a href="#PatternFilter.update_mask-806"><span class="linenos">806</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">*</span><span class="n">new_mask</span>
</span><span id="PatternFilter.update_mask-807"><a href="#PatternFilter.update_mask-807"><span class="linenos">807</span></a>        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;union&#39;</span><span class="p">:</span>
</span><span id="PatternFilter.update_mask-808"><a href="#PatternFilter.update_mask-808"><span class="linenos">808</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="o">|</span><span class="n">new_mask</span>
</span><span id="PatternFilter.update_mask-809"><a href="#PatternFilter.update_mask-809"><span class="linenos">809</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="PatternFilter.update_mask-810"><a href="#PatternFilter.update_mask-810"><span class="linenos">810</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Invalid mode, </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">))</span>
</span><span id="PatternFilter.update_mask-811"><a href="#PatternFilter.update_mask-811"><span class="linenos">811</span></a>        <span class="k">return</span>
</span></pre></div>


            <div class="docstring"><p>Update <em>PatternFilter.mask_ds</em> with a new mask, either taking their union or intersection, or replacing the current mask with new_mask.</p>

<p><strong>Arguments</strong></p>

<p><em>new_mask</em></p>

<p>An xarray.Dataset with the same coords and variables as <em>PatternFilter.mask_ds</em>.</p>

<p><em>mode</em></p>

<p>A string, one of 'replace','intersection' or 'union', defining how <em>new_mask</em> should be used to update the mask.</p>
</div>


                            </div>
                            <div id="PatternFilter.apply_value_mask" class="classattr">
                                        <input id="PatternFilter.apply_value_mask-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">apply_value_mask</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">truth_function</span>, </span><span class="param"><span class="o">*</span><span class="n">args</span>, </span><span class="param"><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="PatternFilter.apply_value_mask-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#PatternFilter.apply_value_mask"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="PatternFilter.apply_value_mask-813"><a href="#PatternFilter.apply_value_mask-813"><span class="linenos">813</span></a>    <span class="k">def</span> <span class="nf">apply_value_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">truth_function</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">):</span>
</span><span id="PatternFilter.apply_value_mask-814"><a href="#PatternFilter.apply_value_mask-814"><span class="linenos">814</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply a filter to *PatternFilter.mask_ds* based on a user-specified truth function which is applied to *PatternFilter.val_ds. </span>
</span><span id="PatternFilter.apply_value_mask-815"><a href="#PatternFilter.apply_value_mask-815"><span class="linenos">815</span></a><span class="sd">        </span>
</span><span id="PatternFilter.apply_value_mask-816"><a href="#PatternFilter.apply_value_mask-816"><span class="linenos">816</span></a><span class="sd">        **Examples**</span>
</span><span id="PatternFilter.apply_value_mask-817"><a href="#PatternFilter.apply_value_mask-817"><span class="linenos">817</span></a><span class="sd">        </span>
</span><span id="PatternFilter.apply_value_mask-818"><a href="#PatternFilter.apply_value_mask-818"><span class="linenos">818</span></a><span class="sd">            #Mask values beneath a threshold:</span>
</span><span id="PatternFilter.apply_value_mask-819"><a href="#PatternFilter.apply_value_mask-819"><span class="linenos">819</span></a><span class="sd">            def larger_than_thresh(ds,thresh):</span>
</span><span id="PatternFilter.apply_value_mask-820"><a href="#PatternFilter.apply_value_mask-820"><span class="linenos">820</span></a><span class="sd">                return ds&gt;thresh</span>
</span><span id="PatternFilter.apply_value_mask-821"><a href="#PatternFilter.apply_value_mask-821"><span class="linenos">821</span></a><span class="sd">            patternfilter.apply_value_mask(is_positive,thresh)</span>
</span><span id="PatternFilter.apply_value_mask-822"><a href="#PatternFilter.apply_value_mask-822"><span class="linenos">822</span></a>
</span><span id="PatternFilter.apply_value_mask-823"><a href="#PatternFilter.apply_value_mask-823"><span class="linenos">823</span></a><span class="sd">            #Mask values where absolute value is less than a reference field:</span>
</span><span id="PatternFilter.apply_value_mask-824"><a href="#PatternFilter.apply_value_mask-824"><span class="linenos">824</span></a><span class="sd">            def amp_greater_than_reference(ds,ref_ds):</span>
</span><span id="PatternFilter.apply_value_mask-825"><a href="#PatternFilter.apply_value_mask-825"><span class="linenos">825</span></a><span class="sd">                return np.abs(ds)&gt;ref_ds</span>
</span><span id="PatternFilter.apply_value_mask-826"><a href="#PatternFilter.apply_value_mask-826"><span class="linenos">826</span></a><span class="sd">            pattern_filter.apply_value_mask(amp_greater_than_reference,ref_ds)</span>
</span><span id="PatternFilter.apply_value_mask-827"><a href="#PatternFilter.apply_value_mask-827"><span class="linenos">827</span></a>
</span><span id="PatternFilter.apply_value_mask-828"><a href="#PatternFilter.apply_value_mask-828"><span class="linenos">828</span></a><span class="sd">        **Arguments**</span>
</span><span id="PatternFilter.apply_value_mask-829"><a href="#PatternFilter.apply_value_mask-829"><span class="linenos">829</span></a>
</span><span id="PatternFilter.apply_value_mask-830"><a href="#PatternFilter.apply_value_mask-830"><span class="linenos">830</span></a><span class="sd">        *truth_function*</span>
</span><span id="PatternFilter.apply_value_mask-831"><a href="#PatternFilter.apply_value_mask-831"><span class="linenos">831</span></a><span class="sd">        </span>
</span><span id="PatternFilter.apply_value_mask-832"><a href="#PatternFilter.apply_value_mask-832"><span class="linenos">832</span></a><span class="sd">        A function with inputs (val_ds,*args) that returns a boolean dataset with the same coords and data variables as *PatternFilter.val_ds*.</span>
</span><span id="PatternFilter.apply_value_mask-833"><a href="#PatternFilter.apply_value_mask-833"><span class="linenos">833</span></a>
</span><span id="PatternFilter.apply_value_mask-834"><a href="#PatternFilter.apply_value_mask-834"><span class="linenos">834</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="PatternFilter.apply_value_mask-835"><a href="#PatternFilter.apply_value_mask-835"><span class="linenos">835</span></a><span class="sd">        </span>
</span><span id="PatternFilter.apply_value_mask-836"><a href="#PatternFilter.apply_value_mask-836"><span class="linenos">836</span></a><span class="sd">        *mode*</span>
</span><span id="PatternFilter.apply_value_mask-837"><a href="#PatternFilter.apply_value_mask-837"><span class="linenos">837</span></a><span class="sd">            </span>
</span><span id="PatternFilter.apply_value_mask-838"><a href="#PatternFilter.apply_value_mask-838"><span class="linenos">838</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how the value filter should be used to update the *PatternFilter.mask_ds*.</span>
</span><span id="PatternFilter.apply_value_mask-839"><a href="#PatternFilter.apply_value_mask-839"><span class="linenos">839</span></a><span class="sd">        &quot;&quot;&quot;</span>        
</span><span id="PatternFilter.apply_value_mask-840"><a href="#PatternFilter.apply_value_mask-840"><span class="linenos">840</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="PatternFilter.apply_value_mask-841"><a href="#PatternFilter.apply_value_mask-841"><span class="linenos">841</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;val_ds must be provided to apply value mask.&#39;</span><span class="p">))</span>
</span><span id="PatternFilter.apply_value_mask-842"><a href="#PatternFilter.apply_value_mask-842"><span class="linenos">842</span></a>        <span class="n">value_mask</span><span class="o">=</span><span class="n">truth_function</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="p">,</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</span><span id="PatternFilter.apply_value_mask-843"><a href="#PatternFilter.apply_value_mask-843"><span class="linenos">843</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">update_mask</span><span class="p">(</span><span class="n">value_mask</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="PatternFilter.apply_value_mask-844"><a href="#PatternFilter.apply_value_mask-844"><span class="linenos">844</span></a>        <span class="k">return</span>
</span></pre></div>


            <div class="docstring"><p>Apply a filter to <em>PatternFilter.mask_ds</em> based on a user-specified truth function which is applied to *PatternFilter.val_ds. </p>

<p><strong>Examples</strong></p>

<pre><code>#Mask values beneath a threshold:
def larger_than_thresh(ds,thresh):
    return ds&gt;thresh
patternfilter.apply_value_mask(is_positive,thresh)

#Mask values where absolute value is less than a reference field:
def amp_greater_than_reference(ds,ref_ds):
    return np.abs(ds)&gt;ref_ds
pattern_filter.apply_value_mask(amp_greater_than_reference,ref_ds)
</code></pre>

<p><strong>Arguments</strong></p>

<p><em>truth_function</em></p>

<p>A function with inputs (val_ds,<em>args) that returns a boolean dataset with the same coords and data variables as *PatternFilter.val_ds</em>.</p>

<p><strong>Optional arguments</strong></p>

<p><em>mode</em></p>

<p>A string, one of 'replace','intersection' or 'union', defining how the value filter should be used to update the <em>PatternFilter.mask_ds</em>.</p>
</div>


                            </div>
                            <div id="PatternFilter.apply_area_mask" class="classattr">
                                        <input id="PatternFilter.apply_area_mask-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">apply_area_mask</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">n</span>, </span><span class="param"><span class="n">dims</span><span class="o">=</span><span class="kc">None</span>, </span><span class="param"><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span>, </span><span class="param"><span class="n">area_type</span><span class="o">=</span><span class="s1">&#39;gridpoint&#39;</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="PatternFilter.apply_area_mask-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#PatternFilter.apply_area_mask"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="PatternFilter.apply_area_mask-846"><a href="#PatternFilter.apply_area_mask-846"><span class="linenos">846</span></a>    <span class="k">def</span> <span class="nf">apply_area_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;intersection&#39;</span><span class="p">,</span><span class="n">area_type</span><span class="o">=</span><span class="s1">&#39;gridpoint&#39;</span><span class="p">):</span>
</span><span id="PatternFilter.apply_area_mask-847"><a href="#PatternFilter.apply_area_mask-847"><span class="linenos">847</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply a filter to *PatternFilter.mask_ds* that identifies connected groups of True values within a subspace of the Dataset&#39;s dimensions specified by *dims*, and masks out groups which are beneath a threshold size *n*. This is done through the application of *scipy.ndimage.label* using the default structuring element (https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.label.html). </span>
</span><span id="PatternFilter.apply_area_mask-848"><a href="#PatternFilter.apply_area_mask-848"><span class="linenos">848</span></a><span class="sd">    </span>
</span><span id="PatternFilter.apply_area_mask-849"><a href="#PatternFilter.apply_area_mask-849"><span class="linenos">849</span></a><span class="sd">        When *area_type*=&#39;gridpoint&#39;, *n* specifies the number of connected datapoints within each connected region. For the special case where *dims* consists of a latitude- and longitude-like coordinate, area_type=&#39;spherical&#39; applies a cosine-latitude weighting, such that *n* can be interpreted as a measure of area, where a datapoint with lat=0 would have area 1. </span>
</span><span id="PatternFilter.apply_area_mask-850"><a href="#PatternFilter.apply_area_mask-850"><span class="linenos">850</span></a><span class="sd">        </span>
</span><span id="PatternFilter.apply_area_mask-851"><a href="#PatternFilter.apply_area_mask-851"><span class="linenos">851</span></a><span class="sd">        **Examples**</span>
</span><span id="PatternFilter.apply_area_mask-852"><a href="#PatternFilter.apply_area_mask-852"><span class="linenos">852</span></a><span class="sd">        </span>
</span><span id="PatternFilter.apply_area_mask-853"><a href="#PatternFilter.apply_area_mask-853"><span class="linenos">853</span></a><span class="sd">            #Keep groups of True values consisting of an area &gt;=30 square equatorial gridpoints</span>
</span><span id="PatternFilter.apply_area_mask-854"><a href="#PatternFilter.apply_area_mask-854"><span class="linenos">854</span></a><span class="sd">            patternfilter.apply_area_mask(30,dims=(&#39;lat&#39;,&#39;lon&#39;),area_type=&#39;spherical&#39;)</span>
</span><span id="PatternFilter.apply_area_mask-855"><a href="#PatternFilter.apply_area_mask-855"><span class="linenos">855</span></a><span class="sd">            </span>
</span><span id="PatternFilter.apply_area_mask-856"><a href="#PatternFilter.apply_area_mask-856"><span class="linenos">856</span></a><span class="sd">            #Keep groups of True values that are consistent for at least 3 neighbouring time lags</span>
</span><span id="PatternFilter.apply_area_mask-857"><a href="#PatternFilter.apply_area_mask-857"><span class="linenos">857</span></a><span class="sd">            patternfilter.apply_area_mask(3,dims=(&#39;time&#39;))</span>
</span><span id="PatternFilter.apply_area_mask-858"><a href="#PatternFilter.apply_area_mask-858"><span class="linenos">858</span></a><span class="sd">            </span>
</span><span id="PatternFilter.apply_area_mask-859"><a href="#PatternFilter.apply_area_mask-859"><span class="linenos">859</span></a><span class="sd">            #Keep groups of true values consisting of &gt;=10 longitudinal values, or &gt;=30 values in longitude and altitude if the variables have an altitude coord:</span>
</span><span id="PatternFilter.apply_area_mask-860"><a href="#PatternFilter.apply_area_mask-860"><span class="linenos">860</span></a><span class="sd">            patternfilter.apply_area_mask(10,dims=(&#39;longitude&#39;))</span>
</span><span id="PatternFilter.apply_area_mask-861"><a href="#PatternFilter.apply_area_mask-861"><span class="linenos">861</span></a><span class="sd">            patternfilter.apply_area_mask(30,dims=(&#39;longitude,altitude&#39;),mode=&#39;union&#39;)</span>
</span><span id="PatternFilter.apply_area_mask-862"><a href="#PatternFilter.apply_area_mask-862"><span class="linenos">862</span></a>
</span><span id="PatternFilter.apply_area_mask-863"><a href="#PatternFilter.apply_area_mask-863"><span class="linenos">863</span></a><span class="sd">        **Arguments**</span>
</span><span id="PatternFilter.apply_area_mask-864"><a href="#PatternFilter.apply_area_mask-864"><span class="linenos">864</span></a>
</span><span id="PatternFilter.apply_area_mask-865"><a href="#PatternFilter.apply_area_mask-865"><span class="linenos">865</span></a><span class="sd">        *n*</span>
</span><span id="PatternFilter.apply_area_mask-866"><a href="#PatternFilter.apply_area_mask-866"><span class="linenos">866</span></a><span class="sd">            </span>
</span><span id="PatternFilter.apply_area_mask-867"><a href="#PatternFilter.apply_area_mask-867"><span class="linenos">867</span></a><span class="sd">        A scalar indicating the minimum size of an unmasked group, in terms of number of gridpoints (for *area_type*=gridpoint) or the weighted area (for *area_type*=spherical), beneath which the group will be masked.</span>
</span><span id="PatternFilter.apply_area_mask-868"><a href="#PatternFilter.apply_area_mask-868"><span class="linenos">868</span></a>
</span><span id="PatternFilter.apply_area_mask-869"><a href="#PatternFilter.apply_area_mask-869"><span class="linenos">869</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="PatternFilter.apply_area_mask-870"><a href="#PatternFilter.apply_area_mask-870"><span class="linenos">870</span></a><span class="sd">        </span>
</span><span id="PatternFilter.apply_area_mask-871"><a href="#PatternFilter.apply_area_mask-871"><span class="linenos">871</span></a><span class="sd">        *dims*</span>
</span><span id="PatternFilter.apply_area_mask-872"><a href="#PatternFilter.apply_area_mask-872"><span class="linenos">872</span></a><span class="sd">            </span>
</span><span id="PatternFilter.apply_area_mask-873"><a href="#PatternFilter.apply_area_mask-873"><span class="linenos">873</span></a><span class="sd">        An iterable of strings specifying coords in *PatternFilter.mask_ds* which define the subspace in which groups of connected True values are identified. Other dims will be iterated over. DataArrays within *PatternFilter.mask_ds* that do not contain all the *dims* will be ignored. If *dims*=None, all dims in each DataArray will be used.</span>
</span><span id="PatternFilter.apply_area_mask-874"><a href="#PatternFilter.apply_area_mask-874"><span class="linenos">874</span></a><span class="sd">            </span>
</span><span id="PatternFilter.apply_area_mask-875"><a href="#PatternFilter.apply_area_mask-875"><span class="linenos">875</span></a><span class="sd">        *mode*</span>
</span><span id="PatternFilter.apply_area_mask-876"><a href="#PatternFilter.apply_area_mask-876"><span class="linenos">876</span></a>
</span><span id="PatternFilter.apply_area_mask-877"><a href="#PatternFilter.apply_area_mask-877"><span class="linenos">877</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how the area filter should be used to update the *PatternFilter.mask_ds*.</span>
</span><span id="PatternFilter.apply_area_mask-878"><a href="#PatternFilter.apply_area_mask-878"><span class="linenos">878</span></a><span class="sd">            </span>
</span><span id="PatternFilter.apply_area_mask-879"><a href="#PatternFilter.apply_area_mask-879"><span class="linenos">879</span></a><span class="sd">        *area_type*</span>
</span><span id="PatternFilter.apply_area_mask-880"><a href="#PatternFilter.apply_area_mask-880"><span class="linenos">880</span></a>
</span><span id="PatternFilter.apply_area_mask-881"><a href="#PatternFilter.apply_area_mask-881"><span class="linenos">881</span></a><span class="sd">        A string, one of &#39;gridpoint&#39; or &#39;spherical&#39; as specified above. &#39;spherical&#39; is currently only supported for len-2 *dims* kwargs, with the first assumed to be latitude-like. </span>
</span><span id="PatternFilter.apply_area_mask-882"><a href="#PatternFilter.apply_area_mask-882"><span class="linenos">882</span></a><span class="sd">            </span>
</span><span id="PatternFilter.apply_area_mask-883"><a href="#PatternFilter.apply_area_mask-883"><span class="linenos">883</span></a><span class="sd">        &quot;&quot;&quot;</span>        
</span><span id="PatternFilter.apply_area_mask-884"><a href="#PatternFilter.apply_area_mask-884"><span class="linenos">884</span></a>        <span class="k">if</span> <span class="n">area_type</span><span class="o">==</span><span class="s1">&#39;gridpoint&#39;</span><span class="p">:</span>
</span><span id="PatternFilter.apply_area_mask-885"><a href="#PatternFilter.apply_area_mask-885"><span class="linenos">885</span></a>            <span class="n">area_based</span><span class="o">=</span><span class="kc">False</span>
</span><span id="PatternFilter.apply_area_mask-886"><a href="#PatternFilter.apply_area_mask-886"><span class="linenos">886</span></a>        <span class="k">elif</span> <span class="n">area_type</span><span class="o">==</span><span class="s1">&#39;spherical&#39;</span><span class="p">:</span>
</span><span id="PatternFilter.apply_area_mask-887"><a href="#PatternFilter.apply_area_mask-887"><span class="linenos">887</span></a>            <span class="n">area_based</span><span class="o">=</span><span class="kc">True</span>
</span><span id="PatternFilter.apply_area_mask-888"><a href="#PatternFilter.apply_area_mask-888"><span class="linenos">888</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="PatternFilter.apply_area_mask-889"><a href="#PatternFilter.apply_area_mask-889"><span class="linenos">889</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown area_type </span><span class="si">{</span><span class="n">area_type</span><span class="si">}</span><span class="s2">. Valid options are &#39;gridpoint&#39; and &#39;spherical&#39;&quot;</span><span class="p">))</span>
</span><span id="PatternFilter.apply_area_mask-890"><a href="#PatternFilter.apply_area_mask-890"><span class="linenos">890</span></a>        <span class="n">area_mask</span><span class="o">=</span><span class="n">ds_large_regions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">,</span><span class="n">area_based</span><span class="o">=</span><span class="n">area_based</span><span class="p">)</span>
</span><span id="PatternFilter.apply_area_mask-891"><a href="#PatternFilter.apply_area_mask-891"><span class="linenos">891</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">update_mask</span><span class="p">(</span><span class="n">area_mask</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="PatternFilter.apply_area_mask-892"><a href="#PatternFilter.apply_area_mask-892"><span class="linenos">892</span></a>        <span class="k">return</span>
</span></pre></div>


            <div class="docstring"><p>Apply a filter to <em>PatternFilter.mask_ds</em> that identifies connected groups of True values within a subspace of the Dataset's dimensions specified by <em>dims</em>, and masks out groups which are beneath a threshold size <em>n</em>. This is done through the application of <em>scipy.ndimage.label</em> using the default structuring element (https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.label.html). </p>

<p>When <em>area_type</em>='gridpoint', <em>n</em> specifies the number of connected datapoints within each connected region. For the special case where <em>dims</em> consists of a latitude- and longitude-like coordinate, area_type='spherical' applies a cosine-latitude weighting, such that <em>n</em> can be interpreted as a measure of area, where a datapoint with lat=0 would have area 1. </p>

<p><strong>Examples</strong></p>

<pre><code>#Keep groups of True values consisting of an area &gt;=30 square equatorial gridpoints
patternfilter.apply_area_mask(30,dims=('lat','lon'),area_type='spherical')

#Keep groups of True values that are consistent for at least 3 neighbouring time lags
patternfilter.apply_area_mask(3,dims=('time'))

#Keep groups of true values consisting of &gt;=10 longitudinal values, or &gt;=30 values in longitude and altitude if the variables have an altitude coord:
patternfilter.apply_area_mask(10,dims=('longitude'))
patternfilter.apply_area_mask(30,dims=('longitude,altitude'),mode='union')
</code></pre>

<p><strong>Arguments</strong></p>

<p><em>n</em></p>

<p>A scalar indicating the minimum size of an unmasked group, in terms of number of gridpoints (for <em>area_type</em>=gridpoint) or the weighted area (for <em>area_type</em>=spherical), beneath which the group will be masked.</p>

<p><strong>Optional arguments</strong></p>

<p><em>dims</em></p>

<p>An iterable of strings specifying coords in <em>PatternFilter.mask_ds</em> which define the subspace in which groups of connected True values are identified. Other dims will be iterated over. DataArrays within <em>PatternFilter.mask_ds</em> that do not contain all the <em>dims</em> will be ignored. If <em>dims</em>=None, all dims in each DataArray will be used.</p>

<p><em>mode</em></p>

<p>A string, one of 'replace','intersection' or 'union', defining how the area filter should be used to update the <em>PatternFilter.mask_ds</em>.</p>

<p><em>area_type</em></p>

<p>A string, one of 'gridpoint' or 'spherical' as specified above. 'spherical' is currently only supported for len-2 <em>dims</em> kwargs, with the first assumed to be latitude-like.</p>
</div>


                            </div>
                            <div id="PatternFilter.apply_convolution" class="classattr">
                                        <input id="PatternFilter.apply_convolution-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">apply_convolution</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">n</span>, </span><span class="param"><span class="n">dims</span>, </span><span class="param"><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="PatternFilter.apply_convolution-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#PatternFilter.apply_convolution"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="PatternFilter.apply_convolution-895"><a href="#PatternFilter.apply_convolution-895"><span class="linenos">895</span></a>    <span class="k">def</span> <span class="nf">apply_convolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="p">,</span><span class="n">mode</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">):</span>
</span><span id="PatternFilter.apply_convolution-896"><a href="#PatternFilter.apply_convolution-896"><span class="linenos">896</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply a square n-point convolution filter to *PatternFilter.mask_ds* in one or two dimensions specified by *dims*, iterated over remaining dimensions. This has the effect of extending the unmasked regions and smoothing the mask overall.</span>
</span><span id="PatternFilter.apply_convolution-897"><a href="#PatternFilter.apply_convolution-897"><span class="linenos">897</span></a><span class="sd">        </span>
</span><span id="PatternFilter.apply_convolution-898"><a href="#PatternFilter.apply_convolution-898"><span class="linenos">898</span></a><span class="sd">        **Arguments**</span>
</span><span id="PatternFilter.apply_convolution-899"><a href="#PatternFilter.apply_convolution-899"><span class="linenos">899</span></a><span class="sd">        </span>
</span><span id="PatternFilter.apply_convolution-900"><a href="#PatternFilter.apply_convolution-900"><span class="linenos">900</span></a><span class="sd">        *n*</span>
</span><span id="PatternFilter.apply_convolution-901"><a href="#PatternFilter.apply_convolution-901"><span class="linenos">901</span></a><span class="sd">            </span>
</span><span id="PatternFilter.apply_convolution-902"><a href="#PatternFilter.apply_convolution-902"><span class="linenos">902</span></a><span class="sd">        A positive integer specifying the size of the convolution filter. *n*=1 leaves the mask unchanged. Even *n* are asymmetric and shifted right. </span>
</span><span id="PatternFilter.apply_convolution-903"><a href="#PatternFilter.apply_convolution-903"><span class="linenos">903</span></a>
</span><span id="PatternFilter.apply_convolution-904"><a href="#PatternFilter.apply_convolution-904"><span class="linenos">904</span></a><span class="sd">        *dims*</span>
</span><span id="PatternFilter.apply_convolution-905"><a href="#PatternFilter.apply_convolution-905"><span class="linenos">905</span></a>
</span><span id="PatternFilter.apply_convolution-906"><a href="#PatternFilter.apply_convolution-906"><span class="linenos">906</span></a><span class="sd">        A length 1 or 2 iterable of strings specifying the dims in which the convolution is applied. Other dims will be iterated over. DataArrays within *PatternFilter.mask_ds* that do not contain all the *dims* will be ignored. </span>
</span><span id="PatternFilter.apply_convolution-907"><a href="#PatternFilter.apply_convolution-907"><span class="linenos">907</span></a>
</span><span id="PatternFilter.apply_convolution-908"><a href="#PatternFilter.apply_convolution-908"><span class="linenos">908</span></a><span class="sd">        *mode*</span>
</span><span id="PatternFilter.apply_convolution-909"><a href="#PatternFilter.apply_convolution-909"><span class="linenos">909</span></a>
</span><span id="PatternFilter.apply_convolution-910"><a href="#PatternFilter.apply_convolution-910"><span class="linenos">910</span></a><span class="sd">        A string, one of &#39;replace&#39;,&#39;intersection&#39; or &#39;union&#39;, defining how the area filter should be used to update the *PatternFilter.mask_ds*.</span>
</span><span id="PatternFilter.apply_convolution-911"><a href="#PatternFilter.apply_convolution-911"><span class="linenos">911</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="PatternFilter.apply_convolution-912"><a href="#PatternFilter.apply_convolution-912"><span class="linenos">912</span></a>        
</span><span id="PatternFilter.apply_convolution-913"><a href="#PatternFilter.apply_convolution-913"><span class="linenos">913</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
</span><span id="PatternFilter.apply_convolution-914"><a href="#PatternFilter.apply_convolution-914"><span class="linenos">914</span></a>            <span class="k">raise</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Only 1 and 2D dims currently supported&#39;</span><span class="p">))</span>
</span><span id="PatternFilter.apply_convolution-915"><a href="#PatternFilter.apply_convolution-915"><span class="linenos">915</span></a>            
</span><span id="PatternFilter.apply_convolution-916"><a href="#PatternFilter.apply_convolution-916"><span class="linenos">916</span></a>        <span class="n">convolution</span><span class="o">=</span><span class="n">convolve_pad_ds</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">dims</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>
</span><span id="PatternFilter.apply_convolution-917"><a href="#PatternFilter.apply_convolution-917"><span class="linenos">917</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">update_mask</span><span class="p">(</span><span class="n">convolution</span><span class="p">,</span><span class="n">mode</span><span class="p">)</span>
</span><span id="PatternFilter.apply_convolution-918"><a href="#PatternFilter.apply_convolution-918"><span class="linenos">918</span></a>        <span class="k">return</span>
</span></pre></div>


            <div class="docstring"><p>Apply a square n-point convolution filter to <em>PatternFilter.mask_ds</em> in one or two dimensions specified by <em>dims</em>, iterated over remaining dimensions. This has the effect of extending the unmasked regions and smoothing the mask overall.</p>

<p><strong>Arguments</strong></p>

<p><em>n</em></p>

<p>A positive integer specifying the size of the convolution filter. <em>n</em>=1 leaves the mask unchanged. Even <em>n</em> are asymmetric and shifted right. </p>

<p><em>dims</em></p>

<p>A length 1 or 2 iterable of strings specifying the dims in which the convolution is applied. Other dims will be iterated over. DataArrays within <em>PatternFilter.mask_ds</em> that do not contain all the <em>dims</em> will be ignored. </p>

<p><em>mode</em></p>

<p>A string, one of 'replace','intersection' or 'union', defining how the area filter should be used to update the <em>PatternFilter.mask_ds</em>.</p>
</div>


                            </div>
                            <div id="PatternFilter.get_mask" class="classattr">
                                        <input id="PatternFilter.get_mask-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_mask</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="PatternFilter.get_mask-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#PatternFilter.get_mask"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="PatternFilter.get_mask-920"><a href="#PatternFilter.get_mask-920"><span class="linenos">920</span></a>    <span class="k">def</span> <span class="nf">get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="PatternFilter.get_mask-921"><a href="#PatternFilter.get_mask-921"><span class="linenos">921</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot; Retrieve the mask with all filters applied.</span>
</span><span id="PatternFilter.get_mask-922"><a href="#PatternFilter.get_mask-922"><span class="linenos">922</span></a><span class="sd">        **Returns**</span>
</span><span id="PatternFilter.get_mask-923"><a href="#PatternFilter.get_mask-923"><span class="linenos">923</span></a><span class="sd">        An xarray.Dataset of boolean values.</span>
</span><span id="PatternFilter.get_mask-924"><a href="#PatternFilter.get_mask-924"><span class="linenos">924</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="PatternFilter.get_mask-925"><a href="#PatternFilter.get_mask-925"><span class="linenos">925</span></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span>
</span></pre></div>


            <div class="docstring"><p>" Retrieve the mask with all filters applied.
<strong>Returns</strong>
An xarray.Dataset of boolean values.</p>
</div>


                            </div>
                            <div id="PatternFilter.filter" class="classattr">
                                        <input id="PatternFilter.filter-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">filter</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">ds</span><span class="o">=</span><span class="kc">None</span>, </span><span class="param"><span class="n">drop_empty</span><span class="o">=</span><span class="kc">True</span>, </span><span class="param"><span class="n">fill_val</span><span class="o">=</span><span class="n">nan</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="PatternFilter.filter-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#PatternFilter.filter"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="PatternFilter.filter-927"><a href="#PatternFilter.filter-927"><span class="linenos">927</span></a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">drop_empty</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">fill_val</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
</span><span id="PatternFilter.filter-928"><a href="#PatternFilter.filter-928"><span class="linenos">928</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Apply the current mask to *ds* or to *PatternFilter.val_ds* (if *ds* is None), replacing masked gridpoints with *fill_val*.</span>
</span><span id="PatternFilter.filter-929"><a href="#PatternFilter.filter-929"><span class="linenos">929</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="PatternFilter.filter-930"><a href="#PatternFilter.filter-930"><span class="linenos">930</span></a><span class="sd">        </span>
</span><span id="PatternFilter.filter-931"><a href="#PatternFilter.filter-931"><span class="linenos">931</span></a><span class="sd">        *ds*</span>
</span><span id="PatternFilter.filter-932"><a href="#PatternFilter.filter-932"><span class="linenos">932</span></a><span class="sd">        </span>
</span><span id="PatternFilter.filter-933"><a href="#PatternFilter.filter-933"><span class="linenos">933</span></a><span class="sd">        An xarray.Dataset to apply the mask to. Should have the same coords and data_vars as *PatternFilter.mask_ds*. If None, the mask is applied to *PatternFilter.val_ds*.</span>
</span><span id="PatternFilter.filter-934"><a href="#PatternFilter.filter-934"><span class="linenos">934</span></a><span class="sd">        </span>
</span><span id="PatternFilter.filter-935"><a href="#PatternFilter.filter-935"><span class="linenos">935</span></a><span class="sd">        *drop_empty*</span>
</span><span id="PatternFilter.filter-936"><a href="#PatternFilter.filter-936"><span class="linenos">936</span></a><span class="sd">        </span>
</span><span id="PatternFilter.filter-937"><a href="#PatternFilter.filter-937"><span class="linenos">937</span></a><span class="sd">        A boolean value. If True, then completely masked variables are dropped from the returned masked Dataset.</span>
</span><span id="PatternFilter.filter-938"><a href="#PatternFilter.filter-938"><span class="linenos">938</span></a><span class="sd">        </span>
</span><span id="PatternFilter.filter-939"><a href="#PatternFilter.filter-939"><span class="linenos">939</span></a><span class="sd">        *fill_val*</span>
</span><span id="PatternFilter.filter-940"><a href="#PatternFilter.filter-940"><span class="linenos">940</span></a><span class="sd">        </span>
</span><span id="PatternFilter.filter-941"><a href="#PatternFilter.filter-941"><span class="linenos">941</span></a><span class="sd">        A scalar that defaults to np.nan. The value with which masked gridpoints in the Dataset are replaced.</span>
</span><span id="PatternFilter.filter-942"><a href="#PatternFilter.filter-942"><span class="linenos">942</span></a><span class="sd">        </span>
</span><span id="PatternFilter.filter-943"><a href="#PatternFilter.filter-943"><span class="linenos">943</span></a><span class="sd">        **Returns**</span>
</span><span id="PatternFilter.filter-944"><a href="#PatternFilter.filter-944"><span class="linenos">944</span></a><span class="sd">        </span>
</span><span id="PatternFilter.filter-945"><a href="#PatternFilter.filter-945"><span class="linenos">945</span></a><span class="sd">        A Dataset with masked values replaced by *fill_val*.</span>
</span><span id="PatternFilter.filter-946"><a href="#PatternFilter.filter-946"><span class="linenos">946</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="PatternFilter.filter-947"><a href="#PatternFilter.filter-947"><span class="linenos">947</span></a>        <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="PatternFilter.filter-948"><a href="#PatternFilter.filter-948"><span class="linenos">948</span></a>            <span class="n">ds</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">val_ds</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</span><span id="PatternFilter.filter-949"><a href="#PatternFilter.filter-949"><span class="linenos">949</span></a>            
</span><span id="PatternFilter.filter-950"><a href="#PatternFilter.filter-950"><span class="linenos">950</span></a>        <span class="n">ds</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask_ds</span><span class="p">)</span>
</span><span id="PatternFilter.filter-951"><a href="#PatternFilter.filter-951"><span class="linenos">951</span></a>        <span class="k">if</span> <span class="n">drop_empty</span><span class="p">:</span>
</span><span id="PatternFilter.filter-952"><a href="#PatternFilter.filter-952"><span class="linenos">952</span></a>            <span class="n">drop_vars</span><span class="o">=</span><span class="p">((</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to_array</span><span class="p">(</span><span class="s1">&#39;vars&#39;</span><span class="p">)</span>
</span><span id="PatternFilter.filter-953"><a href="#PatternFilter.filter-953"><span class="linenos">953</span></a>            <span class="n">ds</span><span class="o">=</span><span class="n">ds</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">drop_vars</span><span class="p">[</span><span class="n">drop_vars</span><span class="p">]</span><span class="o">.</span><span class="n">vars</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
</span><span id="PatternFilter.filter-954"><a href="#PatternFilter.filter-954"><span class="linenos">954</span></a>        <span class="k">return</span> <span class="n">ds</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">fill_val</span><span class="p">)</span>
</span></pre></div>


            <div class="docstring"><p>Apply the current mask to <em>ds</em> or to <em>PatternFilter.val_ds</em> (if <em>ds</em> is None), replacing masked gridpoints with <em>fill_val</em>.
<strong>Optional arguments</strong></p>

<p><em>ds</em></p>

<p>An xarray.Dataset to apply the mask to. Should have the same coords and data_vars as <em>PatternFilter.mask_ds</em>. If None, the mask is applied to <em>PatternFilter.val_ds</em>.</p>

<p><em>drop_empty</em></p>

<p>A boolean value. If True, then completely masked variables are dropped from the returned masked Dataset.</p>

<p><em>fill_val</em></p>

<p>A scalar that defaults to np.nan. The value with which masked gridpoints in the Dataset are replaced.</p>

<p><strong>Returns</strong></p>

<p>A Dataset with masked values replaced by <em>fill_val</em>.</p>
</div>


                            </div>
                </section>
                <section id="IndexGenerator">
                            <input id="IndexGenerator-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr class">
            
    <span class="def">class</span>
    <span class="name">IndexGenerator</span>:

                <label class="view-source-button" for="IndexGenerator-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#IndexGenerator"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="IndexGenerator-965"><a href="#IndexGenerator-965"><span class="linenos"> 965</span></a><span class="k">class</span> <span class="nc">IndexGenerator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
</span><span id="IndexGenerator-966"><a href="#IndexGenerator-966"><span class="linenos"> 966</span></a><span class="w">    </span>
</span><span id="IndexGenerator-967"><a href="#IndexGenerator-967"><span class="linenos"> 967</span></a><span class="w">    </span><span class="sd">&quot;&quot;&quot; Computes dot-products between a Dataset of patterns and a Dataset of variables, reducing them to standardised scalar indices.</span>
</span><span id="IndexGenerator-968"><a href="#IndexGenerator-968"><span class="linenos"> 968</span></a><span class="sd">    &quot;&quot;&quot;</span>
</span><span id="IndexGenerator-969"><a href="#IndexGenerator-969"><span class="linenos"> 969</span></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="IndexGenerator-970"><a href="#IndexGenerator-970"><span class="linenos"> 970</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_means</span><span class="o">=</span><span class="p">[]</span>
</span><span id="IndexGenerator-971"><a href="#IndexGenerator-971"><span class="linenos"> 971</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_stds</span><span class="o">=</span><span class="p">[]</span>
</span><span id="IndexGenerator-972"><a href="#IndexGenerator-972"><span class="linenos"> 972</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">_rename_function</span><span class="o">=</span><span class="n">_DEFAULT_RENAME_FUNC</span>
</span><span id="IndexGenerator-973"><a href="#IndexGenerator-973"><span class="linenos"> 973</span></a>        
</span><span id="IndexGenerator-974"><a href="#IndexGenerator-974"><span class="linenos"> 974</span></a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="IndexGenerator-975"><a href="#IndexGenerator-975"><span class="linenos"> 975</span></a>        <span class="k">return</span> <span class="s1">&#39;An IndexGenerator object&#39;</span>
</span><span id="IndexGenerator-976"><a href="#IndexGenerator-976"><span class="linenos"> 976</span></a>        
</span><span id="IndexGenerator-977"><a href="#IndexGenerator-977"><span class="linenos"> 977</span></a>    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span id="IndexGenerator-978"><a href="#IndexGenerator-978"><span class="linenos"> 978</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span>
</span><span id="IndexGenerator-979"><a href="#IndexGenerator-979"><span class="linenos"> 979</span></a>    
</span><span id="IndexGenerator-980"><a href="#IndexGenerator-980"><span class="linenos"> 980</span></a>    
</span><span id="IndexGenerator-981"><a href="#IndexGenerator-981"><span class="linenos"> 981</span></a>    <span class="k">def</span> <span class="nf">centre</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="IndexGenerator-982"><a href="#IndexGenerator-982"><span class="linenos"> 982</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="IndexGenerator-983"><a href="#IndexGenerator-983"><span class="linenos"> 983</span></a>
</span><span id="IndexGenerator-984"><a href="#IndexGenerator-984"><span class="linenos"> 984</span></a>        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="IndexGenerator-985"><a href="#IndexGenerator-985"><span class="linenos"> 985</span></a>            <span class="n">ref</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
</span><span id="IndexGenerator-986"><a href="#IndexGenerator-986"><span class="linenos"> 986</span></a>        <span class="k">return</span> <span class="n">x</span><span class="o">-</span><span class="n">ref</span>
</span><span id="IndexGenerator-987"><a href="#IndexGenerator-987"><span class="linenos"> 987</span></a>    
</span><span id="IndexGenerator-988"><a href="#IndexGenerator-988"><span class="linenos"> 988</span></a>    <span class="k">def</span> <span class="nf">normalise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="IndexGenerator-989"><a href="#IndexGenerator-989"><span class="linenos"> 989</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="IndexGenerator-990"><a href="#IndexGenerator-990"><span class="linenos"> 990</span></a>
</span><span id="IndexGenerator-991"><a href="#IndexGenerator-991"><span class="linenos"> 991</span></a>        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="IndexGenerator-992"><a href="#IndexGenerator-992"><span class="linenos"> 992</span></a>            <span class="n">ref</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
</span><span id="IndexGenerator-993"><a href="#IndexGenerator-993"><span class="linenos"> 993</span></a>        <span class="k">return</span> <span class="n">x</span><span class="o">/</span><span class="n">ref</span>
</span><span id="IndexGenerator-994"><a href="#IndexGenerator-994"><span class="linenos"> 994</span></a>    
</span><span id="IndexGenerator-995"><a href="#IndexGenerator-995"><span class="linenos"> 995</span></a>    <span class="k">def</span> <span class="nf">standardise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">mean_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">std_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
</span><span id="IndexGenerator-996"><a href="#IndexGenerator-996"><span class="linenos"> 996</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="IndexGenerator-997"><a href="#IndexGenerator-997"><span class="linenos"> 997</span></a>        <span class="n">centred_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centre</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">mean_ref</span><span class="p">)</span>
</span><span id="IndexGenerator-998"><a href="#IndexGenerator-998"><span class="linenos"> 998</span></a>        <span class="n">standardised_x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="n">centred_x</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">std_ref</span><span class="p">)</span>
</span><span id="IndexGenerator-999"><a href="#IndexGenerator-999"><span class="linenos"> 999</span></a>        <span class="k">return</span> <span class="n">standardised_x</span>
</span><span id="IndexGenerator-1000"><a href="#IndexGenerator-1000"><span class="linenos">1000</span></a>        
</span><span id="IndexGenerator-1001"><a href="#IndexGenerator-1001"><span class="linenos">1001</span></a>    <span class="k">def</span> <span class="nf">collapse_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ix</span><span class="p">,</span><span class="n">dims</span><span class="p">):</span>
</span><span id="IndexGenerator-1002"><a href="#IndexGenerator-1002"><span class="linenos">1002</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;@private&quot;&quot;&quot;</span>
</span><span id="IndexGenerator-1003"><a href="#IndexGenerator-1003"><span class="linenos">1003</span></a>        <span class="n">lat_coords</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;lat&#39;</span><span class="p">,</span><span class="s1">&#39;latitude&#39;</span><span class="p">,</span><span class="s1">&#39;grid_latitude&#39;</span><span class="p">]</span>
</span><span id="IndexGenerator-1004"><a href="#IndexGenerator-1004"><span class="linenos">1004</span></a>        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">lat_coords</span><span class="p">,</span><span class="n">dims</span><span class="p">)):</span>
</span><span id="IndexGenerator-1005"><a href="#IndexGenerator-1005"><span class="linenos">1005</span></a>            <span class="k">return</span> <span class="n">ix</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
</span><span id="IndexGenerator-1006"><a href="#IndexGenerator-1006"><span class="linenos">1006</span></a>        
</span><span id="IndexGenerator-1007"><a href="#IndexGenerator-1007"><span class="linenos">1007</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator-1008"><a href="#IndexGenerator-1008"><span class="linenos">1008</span></a>            <span class="c1">#assumes only one lat coord: seems safe.</span>
</span><span id="IndexGenerator-1009"><a href="#IndexGenerator-1009"><span class="linenos">1009</span></a>            <span class="n">lat_dim</span><span class="o">=</span><span class="n">lat_coords</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">lat_coords</span><span class="p">,</span><span class="n">dims</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
</span><span id="IndexGenerator-1010"><a href="#IndexGenerator-1010"><span class="linenos">1010</span></a>            <span class="n">weights</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">ix</span><span class="p">[</span><span class="n">lat_dim</span><span class="p">]))</span>
</span><span id="IndexGenerator-1011"><a href="#IndexGenerator-1011"><span class="linenos">1011</span></a>            <span class="k">return</span> <span class="n">ix</span><span class="o">.</span><span class="n">weighted</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
</span><span id="IndexGenerator-1012"><a href="#IndexGenerator-1012"><span class="linenos">1012</span></a>            
</span><span id="IndexGenerator-1013"><a href="#IndexGenerator-1013"><span class="linenos">1013</span></a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">slices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ix_means</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ix_stds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">drop_blank</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">strict_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="IndexGenerator-1014"><a href="#IndexGenerator-1014"><span class="linenos">1014</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute standardised indices from an xarray.Dataset of patterns and an xarray.Dataset of arbitrary dimension variables.</span>
</span><span id="IndexGenerator-1015"><a href="#IndexGenerator-1015"><span class="linenos">1015</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1016"><a href="#IndexGenerator-1016"><span class="linenos">1016</span></a><span class="sd">        **Arguments**</span>
</span><span id="IndexGenerator-1017"><a href="#IndexGenerator-1017"><span class="linenos">1017</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1018"><a href="#IndexGenerator-1018"><span class="linenos">1018</span></a><span class="sd">        *pattern_ds*</span>
</span><span id="IndexGenerator-1019"><a href="#IndexGenerator-1019"><span class="linenos">1019</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1020"><a href="#IndexGenerator-1020"><span class="linenos">1020</span></a><span class="sd">        An xarray.Dataset of patterns to project onto with arbitrary dimensions.</span>
</span><span id="IndexGenerator-1021"><a href="#IndexGenerator-1021"><span class="linenos">1021</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1022"><a href="#IndexGenerator-1022"><span class="linenos">1022</span></a><span class="sd">        *series_ds*</span>
</span><span id="IndexGenerator-1023"><a href="#IndexGenerator-1023"><span class="linenos">1023</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1024"><a href="#IndexGenerator-1024"><span class="linenos">1024</span></a><span class="sd">        An xarray.Dataset of variables to project onto the patterns. Coordinates of *series_ds* once subsetted using *slices* must match the dimensions of *pattern_ds* + the extra coord *dim*.</span>
</span><span id="IndexGenerator-1025"><a href="#IndexGenerator-1025"><span class="linenos">1025</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1026"><a href="#IndexGenerator-1026"><span class="linenos">1026</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="IndexGenerator-1027"><a href="#IndexGenerator-1027"><span class="linenos">1027</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1028"><a href="#IndexGenerator-1028"><span class="linenos">1028</span></a><span class="sd">        *dim*:</span>
</span><span id="IndexGenerator-1029"><a href="#IndexGenerator-1029"><span class="linenos">1029</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1030"><a href="#IndexGenerator-1030"><span class="linenos">1030</span></a><span class="sd">        A string specifying the remaining coord of the scalar indices. Defaults to &#39;time&#39;, which should be the choice for most use cases.</span>
</span><span id="IndexGenerator-1031"><a href="#IndexGenerator-1031"><span class="linenos">1031</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1032"><a href="#IndexGenerator-1032"><span class="linenos">1032</span></a><span class="sd">        *slices*</span>
</span><span id="IndexGenerator-1033"><a href="#IndexGenerator-1033"><span class="linenos">1033</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1034"><a href="#IndexGenerator-1034"><span class="linenos">1034</span></a><span class="sd">        A dictionary or iterable of dictionaries, each specifying a subset of *pattern_ds* to take before computing an index, with one index returned for each dictionary and for each variable. Subsetting is based on the *xr.Dataset.sel* method: e.g. *slices*=[dict(lag=0,index_val=1)] will produce 1 set of indices based on pattern_ds.sel(lag=0,index_val=1). If *slices*=None, no subsets are computed.</span>
</span><span id="IndexGenerator-1035"><a href="#IndexGenerator-1035"><span class="linenos">1035</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1036"><a href="#IndexGenerator-1036"><span class="linenos">1036</span></a><span class="sd">        *ix_means*</span>
</span><span id="IndexGenerator-1037"><a href="#IndexGenerator-1037"><span class="linenos">1037</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1038"><a href="#IndexGenerator-1038"><span class="linenos">1038</span></a><span class="sd">        If None, the mean of each index is calculated and subtracted, resulting in centred indices. Otherwise, *ix_means* should be a dictionary of index names and predefined mean values which are subtracted instead. Of most use for online computations, updating a precomputed index in a new dataset.</span>
</span><span id="IndexGenerator-1039"><a href="#IndexGenerator-1039"><span class="linenos">1039</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1040"><a href="#IndexGenerator-1040"><span class="linenos">1040</span></a><span class="sd">        *ix_stds*</span>
</span><span id="IndexGenerator-1041"><a href="#IndexGenerator-1041"><span class="linenos">1041</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1042"><a href="#IndexGenerator-1042"><span class="linenos">1042</span></a><span class="sd">        If None, the standard deviation of each index is calculated and is divided by, resulting in standardised indices. Otherwise, *ix_stds* should be a dictionary of index names and predefined std values which are divided by instead. Of most use for online computations, updating a precomputed index in a new dataset.</span>
</span><span id="IndexGenerator-1043"><a href="#IndexGenerator-1043"><span class="linenos">1043</span></a>
</span><span id="IndexGenerator-1044"><a href="#IndexGenerator-1044"><span class="linenos">1044</span></a><span class="sd">        *drop_blank*</span>
</span><span id="IndexGenerator-1045"><a href="#IndexGenerator-1045"><span class="linenos">1045</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1046"><a href="#IndexGenerator-1046"><span class="linenos">1046</span></a><span class="sd">        A boolean. If True, drop indices where the corresponding pattern is entirely blank. If False, returns an all np.nan time series.</span>
</span><span id="IndexGenerator-1047"><a href="#IndexGenerator-1047"><span class="linenos">1047</span></a><span class="sd">        *in_place*</span>
</span><span id="IndexGenerator-1048"><a href="#IndexGenerator-1048"><span class="linenos">1048</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1049"><a href="#IndexGenerator-1049"><span class="linenos">1049</span></a><span class="sd">        *strict_metadata*</span>
</span><span id="IndexGenerator-1050"><a href="#IndexGenerator-1050"><span class="linenos">1050</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1051"><a href="#IndexGenerator-1051"><span class="linenos">1051</span></a><span class="sd">        If False, indices will be merged into a common dataset regardless of metadata. If True, nonmatching metadata will raise a ValueError.</span>
</span><span id="IndexGenerator-1052"><a href="#IndexGenerator-1052"><span class="linenos">1052</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1053"><a href="#IndexGenerator-1053"><span class="linenos">1053</span></a><span class="sd">        **Returns</span>
</span><span id="IndexGenerator-1054"><a href="#IndexGenerator-1054"><span class="linenos">1054</span></a><span class="sd">        </span>
</span><span id="IndexGenerator-1055"><a href="#IndexGenerator-1055"><span class="linenos">1055</span></a><span class="sd">        An xarray.Dataset of indices with a single coordinate (*dim*).</span>
</span><span id="IndexGenerator-1056"><a href="#IndexGenerator-1056"><span class="linenos">1056</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="IndexGenerator-1057"><a href="#IndexGenerator-1057"><span class="linenos">1057</span></a>        <span class="c1">#Parse inputs</span>
</span><span id="IndexGenerator-1058"><a href="#IndexGenerator-1058"><span class="linenos">1058</span></a>        
</span><span id="IndexGenerator-1059"><a href="#IndexGenerator-1059"><span class="linenos">1059</span></a>        <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="IndexGenerator-1060"><a href="#IndexGenerator-1060"><span class="linenos">1060</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="o">=</span><span class="p">[{}]</span>
</span><span id="IndexGenerator-1061"><a href="#IndexGenerator-1061"><span class="linenos">1061</span></a>        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
</span><span id="IndexGenerator-1062"><a href="#IndexGenerator-1062"><span class="linenos">1062</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="o">=</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
</span><span id="IndexGenerator-1063"><a href="#IndexGenerator-1063"><span class="linenos">1063</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator-1064"><a href="#IndexGenerator-1064"><span class="linenos">1064</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="o">=</span><span class="n">slices</span>
</span><span id="IndexGenerator-1065"><a href="#IndexGenerator-1065"><span class="linenos">1065</span></a>            
</span><span id="IndexGenerator-1066"><a href="#IndexGenerator-1066"><span class="linenos">1066</span></a>        <span class="k">if</span> <span class="n">ix_means</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ix_stds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="IndexGenerator-1067"><a href="#IndexGenerator-1067"><span class="linenos">1067</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">user_params</span><span class="o">=</span><span class="kc">True</span>
</span><span id="IndexGenerator-1068"><a href="#IndexGenerator-1068"><span class="linenos">1068</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">=</span><span class="n">ix_means</span>
</span><span id="IndexGenerator-1069"><a href="#IndexGenerator-1069"><span class="linenos">1069</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">=</span><span class="n">ix_stds</span>
</span><span id="IndexGenerator-1070"><a href="#IndexGenerator-1070"><span class="linenos">1070</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator-1071"><a href="#IndexGenerator-1071"><span class="linenos">1071</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">user_params</span><span class="o">=</span><span class="kc">False</span>
</span><span id="IndexGenerator-1072"><a href="#IndexGenerator-1072"><span class="linenos">1072</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">=</span><span class="p">{}</span>
</span><span id="IndexGenerator-1073"><a href="#IndexGenerator-1073"><span class="linenos">1073</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">=</span><span class="p">{}</span>
</span><span id="IndexGenerator-1074"><a href="#IndexGenerator-1074"><span class="linenos">1074</span></a>            
</span><span id="IndexGenerator-1075"><a href="#IndexGenerator-1075"><span class="linenos">1075</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">=</span><span class="kc">None</span>
</span><span id="IndexGenerator-1076"><a href="#IndexGenerator-1076"><span class="linenos">1076</span></a>        
</span><span id="IndexGenerator-1077"><a href="#IndexGenerator-1077"><span class="linenos">1077</span></a>        <span class="c1">#Compute indices</span>
</span><span id="IndexGenerator-1078"><a href="#IndexGenerator-1078"><span class="linenos">1078</span></a>        <span class="n">indices</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_index</span><span class="p">(</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">sl</span><span class="p">)</span>\
</span><span id="IndexGenerator-1079"><a href="#IndexGenerator-1079"><span class="linenos">1079</span></a>                <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="p">]</span>
</span><span id="IndexGenerator-1080"><a href="#IndexGenerator-1080"><span class="linenos">1080</span></a>        <span class="k">try</span><span class="p">:</span>
</span><span id="IndexGenerator-1081"><a href="#IndexGenerator-1081"><span class="linenos">1081</span></a>            <span class="n">indices</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
</span><span id="IndexGenerator-1082"><a href="#IndexGenerator-1082"><span class="linenos">1082</span></a>        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span id="IndexGenerator-1083"><a href="#IndexGenerator-1083"><span class="linenos">1083</span></a>            <span class="k">if</span> <span class="n">strict_metadata</span><span class="p">:</span>
</span><span id="IndexGenerator-1084"><a href="#IndexGenerator-1084"><span class="linenos">1084</span></a>                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merge of indices failed. Consider &#39;strict_metadata=False&#39;&quot;</span><span class="p">)</span>
</span><span id="IndexGenerator-1085"><a href="#IndexGenerator-1085"><span class="linenos">1085</span></a>                <span class="k">raise</span> <span class="n">e</span>
</span><span id="IndexGenerator-1086"><a href="#IndexGenerator-1086"><span class="linenos">1086</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator-1087"><a href="#IndexGenerator-1087"><span class="linenos">1087</span></a>                <span class="n">indices</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="n">compat</span><span class="o">=</span><span class="s1">&#39;override&#39;</span><span class="p">)</span>
</span><span id="IndexGenerator-1088"><a href="#IndexGenerator-1088"><span class="linenos">1088</span></a>            
</span><span id="IndexGenerator-1089"><a href="#IndexGenerator-1089"><span class="linenos">1089</span></a>        <span class="c1">#Optionally remove indices which are all nan    </span>
</span><span id="IndexGenerator-1090"><a href="#IndexGenerator-1090"><span class="linenos">1090</span></a>        <span class="k">if</span> <span class="n">drop_blank</span><span class="p">:</span>
</span><span id="IndexGenerator-1091"><a href="#IndexGenerator-1091"><span class="linenos">1091</span></a>            <span class="n">drop</span><span class="o">=</span><span class="p">(</span><span class="o">~</span><span class="n">indices</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span>
</span><span id="IndexGenerator-1092"><a href="#IndexGenerator-1092"><span class="linenos">1092</span></a>            <span class="n">drop</span><span class="o">=</span><span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="n">drop</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()[</span><span class="s1">&#39;data_vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]]</span>
</span><span id="IndexGenerator-1093"><a href="#IndexGenerator-1093"><span class="linenos">1093</span></a>            <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">drop</span><span class="p">)</span>
</span><span id="IndexGenerator-1094"><a href="#IndexGenerator-1094"><span class="linenos">1094</span></a>            <span class="n">_</span><span class="o">=</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">drop</span><span class="p">]</span>
</span><span id="IndexGenerator-1095"><a href="#IndexGenerator-1095"><span class="linenos">1095</span></a>        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
</span><span id="IndexGenerator-1096"><a href="#IndexGenerator-1096"><span class="linenos">1096</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span>
</span><span id="IndexGenerator-1097"><a href="#IndexGenerator-1097"><span class="linenos">1097</span></a>        <span class="k">return</span> <span class="n">indices</span>
</span><span id="IndexGenerator-1098"><a href="#IndexGenerator-1098"><span class="linenos">1098</span></a>    
</span><span id="IndexGenerator-1099"><a href="#IndexGenerator-1099"><span class="linenos">1099</span></a>    <span class="k">def</span> <span class="nf">_generate_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">sl</span><span class="p">):</span>
</span><span id="IndexGenerator-1100"><a href="#IndexGenerator-1100"><span class="linenos">1100</span></a>                
</span><span id="IndexGenerator-1101"><a href="#IndexGenerator-1101"><span class="linenos">1101</span></a>        <span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">)</span>
</span><span id="IndexGenerator-1102"><a href="#IndexGenerator-1102"><span class="linenos">1102</span></a>        <span class="n">pattern_ds</span><span class="o">=</span><span class="n">pattern_ds</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>
</span><span id="IndexGenerator-1103"><a href="#IndexGenerator-1103"><span class="linenos">1103</span></a>        <span class="n">dims</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">pattern_ds</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
</span><span id="IndexGenerator-1104"><a href="#IndexGenerator-1104"><span class="linenos">1104</span></a>
</span><span id="IndexGenerator-1105"><a href="#IndexGenerator-1105"><span class="linenos">1105</span></a>        <span class="n">index</span><span class="o">=</span><span class="n">pattern_ds</span><span class="o">*</span><span class="n">series_ds</span>
</span><span id="IndexGenerator-1106"><a href="#IndexGenerator-1106"><span class="linenos">1106</span></a>        <span class="c1">#coslat weights lat coords</span>
</span><span id="IndexGenerator-1107"><a href="#IndexGenerator-1107"><span class="linenos">1107</span></a>        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">collapse_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">dims</span><span class="p">)</span>
</span><span id="IndexGenerator-1108"><a href="#IndexGenerator-1108"><span class="linenos">1108</span></a>        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rename_index_vars</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">sl</span><span class="p">)</span>
</span><span id="IndexGenerator-1109"><a href="#IndexGenerator-1109"><span class="linenos">1109</span></a>
</span><span id="IndexGenerator-1110"><a href="#IndexGenerator-1110"><span class="linenos">1110</span></a>        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">user_params</span><span class="p">:</span>
</span><span id="IndexGenerator-1111"><a href="#IndexGenerator-1111"><span class="linenos">1111</span></a>            <span class="n">mean</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span>
</span><span id="IndexGenerator-1112"><a href="#IndexGenerator-1112"><span class="linenos">1112</span></a>            <span class="n">std</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span>
</span><span id="IndexGenerator-1113"><a href="#IndexGenerator-1113"><span class="linenos">1113</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator-1114"><a href="#IndexGenerator-1114"><span class="linenos">1114</span></a>            <span class="n">mean</span><span class="o">=</span><span class="n">_Dataset_to_dict</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
</span><span id="IndexGenerator-1115"><a href="#IndexGenerator-1115"><span class="linenos">1115</span></a>            <span class="n">std</span><span class="o">=</span><span class="n">_Dataset_to_dict</span><span class="p">(</span><span class="n">index</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
</span><span id="IndexGenerator-1116"><a href="#IndexGenerator-1116"><span class="linenos">1116</span></a>            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">mean</span><span class="p">:</span>
</span><span id="IndexGenerator-1117"><a href="#IndexGenerator-1117"><span class="linenos">1117</span></a>                <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">mean</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
</span><span id="IndexGenerator-1118"><a href="#IndexGenerator-1118"><span class="linenos">1118</span></a>            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">std</span><span class="p">:</span>
</span><span id="IndexGenerator-1119"><a href="#IndexGenerator-1119"><span class="linenos">1119</span></a>                <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">std</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
</span><span id="IndexGenerator-1120"><a href="#IndexGenerator-1120"><span class="linenos">1120</span></a>                
</span><span id="IndexGenerator-1121"><a href="#IndexGenerator-1121"><span class="linenos">1121</span></a>        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">standardise</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">mean_ref</span><span class="o">=</span><span class="n">mean</span><span class="p">,</span><span class="n">std_ref</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>
</span><span id="IndexGenerator-1122"><a href="#IndexGenerator-1122"><span class="linenos">1122</span></a>        <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_index_attrs</span><span class="p">(</span><span class="n">index</span><span class="p">,</span><span class="n">sl</span><span class="p">,</span><span class="n">mean</span><span class="p">,</span><span class="n">std</span><span class="p">)</span>
</span><span id="IndexGenerator-1123"><a href="#IndexGenerator-1123"><span class="linenos">1123</span></a>
</span><span id="IndexGenerator-1124"><a href="#IndexGenerator-1124"><span class="linenos">1124</span></a>        
</span><span id="IndexGenerator-1125"><a href="#IndexGenerator-1125"><span class="linenos">1125</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">generated_index</span><span class="o">=</span><span class="n">index</span>
</span><span id="IndexGenerator-1126"><a href="#IndexGenerator-1126"><span class="linenos">1126</span></a>        <span class="k">return</span> <span class="n">index</span>
</span><span id="IndexGenerator-1127"><a href="#IndexGenerator-1127"><span class="linenos">1127</span></a>    
</span><span id="IndexGenerator-1128"><a href="#IndexGenerator-1128"><span class="linenos">1128</span></a>    <span class="k">def</span> <span class="nf">_add_index_attrs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">sl</span><span class="p">,</span><span class="n">mean</span><span class="p">,</span><span class="n">std</span><span class="p">):</span>
</span><span id="IndexGenerator-1129"><a href="#IndexGenerator-1129"><span class="linenos">1129</span></a>        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">index</span><span class="p">:</span>
</span><span id="IndexGenerator-1130"><a href="#IndexGenerator-1130"><span class="linenos">1130</span></a>            <span class="n">ix</span><span class="o">=</span><span class="n">index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
</span><span id="IndexGenerator-1131"><a href="#IndexGenerator-1131"><span class="linenos">1131</span></a>            <span class="n">ix</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mean</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
</span><span id="IndexGenerator-1132"><a href="#IndexGenerator-1132"><span class="linenos">1132</span></a>            <span class="n">ix</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">std</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
</span><span id="IndexGenerator-1133"><a href="#IndexGenerator-1133"><span class="linenos">1133</span></a>            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">i</span> <span class="ow">in</span> <span class="n">sl</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
</span><span id="IndexGenerator-1134"><a href="#IndexGenerator-1134"><span class="linenos">1134</span></a>                <span class="n">ix</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">i</span>
</span><span id="IndexGenerator-1135"><a href="#IndexGenerator-1135"><span class="linenos">1135</span></a>            <span class="n">index</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">=</span><span class="n">ix</span>
</span><span id="IndexGenerator-1136"><a href="#IndexGenerator-1136"><span class="linenos">1136</span></a>        <span class="k">return</span> <span class="n">index</span>
</span><span id="IndexGenerator-1137"><a href="#IndexGenerator-1137"><span class="linenos">1137</span></a>    
</span><span id="IndexGenerator-1138"><a href="#IndexGenerator-1138"><span class="linenos">1138</span></a>    <span class="k">def</span> <span class="nf">_rename_index_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">index</span><span class="p">,</span><span class="n">sl</span><span class="p">):</span>
</span><span id="IndexGenerator-1139"><a href="#IndexGenerator-1139"><span class="linenos">1139</span></a>        <span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_rename_function</span>
</span><span id="IndexGenerator-1140"><a href="#IndexGenerator-1140"><span class="linenos">1140</span></a>        <span class="k">return</span> <span class="n">index</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="n">v</span><span class="p">:</span><span class="n">func</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">sl</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">data_vars</span><span class="p">})</span>
</span><span id="IndexGenerator-1141"><a href="#IndexGenerator-1141"><span class="linenos">1141</span></a>    
</span><span id="IndexGenerator-1142"><a href="#IndexGenerator-1142"><span class="linenos">1142</span></a>    <span class="k">def</span> <span class="nf">get_standardisation_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="IndexGenerator-1143"><a href="#IndexGenerator-1143"><span class="linenos">1143</span></a><span class="w">        </span>
</span><span id="IndexGenerator-1144"><a href="#IndexGenerator-1144"><span class="linenos">1144</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Retrieve index means and stds for computed indices, for use as future inputs into index_means or index_stds in *IndexGenerator.Generate*</span>
</span><span id="IndexGenerator-1145"><a href="#IndexGenerator-1145"><span class="linenos">1145</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="IndexGenerator-1146"><a href="#IndexGenerator-1146"><span class="linenos">1146</span></a>        <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
</span><span id="IndexGenerator-1147"><a href="#IndexGenerator-1147"><span class="linenos">1147</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span>
</span><span id="IndexGenerator-1148"><a href="#IndexGenerator-1148"><span class="linenos">1148</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator-1149"><a href="#IndexGenerator-1149"><span class="linenos">1149</span></a>            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">),</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">)]</span>
</span><span id="IndexGenerator-1150"><a href="#IndexGenerator-1150"><span class="linenos">1150</span></a>            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="s1">&#39;param&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;param&#39;</span><span class="p">:[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="s1">&#39;std&#39;</span><span class="p">]})</span>
</span></pre></div>


            <div class="docstring"><p>Computes dot-products between a Dataset of patterns and a Dataset of variables, reducing them to standardised scalar indices.</p>
</div>


                            <div id="IndexGenerator.generate" class="classattr">
                                        <input id="IndexGenerator.generate-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">generate</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">pattern_ds</span>,</span><span class="param">	<span class="n">series_ds</span>,</span><span class="param">	<span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span>,</span><span class="param">	<span class="n">slices</span><span class="o">=</span><span class="kc">None</span>,</span><span class="param">	<span class="n">ix_means</span><span class="o">=</span><span class="kc">None</span>,</span><span class="param">	<span class="n">ix_stds</span><span class="o">=</span><span class="kc">None</span>,</span><span class="param">	<span class="n">drop_blank</span><span class="o">=</span><span class="kc">False</span>,</span><span class="param">	<span class="n">in_place</span><span class="o">=</span><span class="kc">True</span>,</span><span class="param">	<span class="n">strict_metadata</span><span class="o">=</span><span class="kc">False</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="IndexGenerator.generate-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#IndexGenerator.generate"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="IndexGenerator.generate-1013"><a href="#IndexGenerator.generate-1013"><span class="linenos">1013</span></a>    <span class="k">def</span> <span class="nf">generate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">,</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span><span class="n">slices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ix_means</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ix_stds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">drop_blank</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">strict_metadata</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="IndexGenerator.generate-1014"><a href="#IndexGenerator.generate-1014"><span class="linenos">1014</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute standardised indices from an xarray.Dataset of patterns and an xarray.Dataset of arbitrary dimension variables.</span>
</span><span id="IndexGenerator.generate-1015"><a href="#IndexGenerator.generate-1015"><span class="linenos">1015</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1016"><a href="#IndexGenerator.generate-1016"><span class="linenos">1016</span></a><span class="sd">        **Arguments**</span>
</span><span id="IndexGenerator.generate-1017"><a href="#IndexGenerator.generate-1017"><span class="linenos">1017</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1018"><a href="#IndexGenerator.generate-1018"><span class="linenos">1018</span></a><span class="sd">        *pattern_ds*</span>
</span><span id="IndexGenerator.generate-1019"><a href="#IndexGenerator.generate-1019"><span class="linenos">1019</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1020"><a href="#IndexGenerator.generate-1020"><span class="linenos">1020</span></a><span class="sd">        An xarray.Dataset of patterns to project onto with arbitrary dimensions.</span>
</span><span id="IndexGenerator.generate-1021"><a href="#IndexGenerator.generate-1021"><span class="linenos">1021</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1022"><a href="#IndexGenerator.generate-1022"><span class="linenos">1022</span></a><span class="sd">        *series_ds*</span>
</span><span id="IndexGenerator.generate-1023"><a href="#IndexGenerator.generate-1023"><span class="linenos">1023</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1024"><a href="#IndexGenerator.generate-1024"><span class="linenos">1024</span></a><span class="sd">        An xarray.Dataset of variables to project onto the patterns. Coordinates of *series_ds* once subsetted using *slices* must match the dimensions of *pattern_ds* + the extra coord *dim*.</span>
</span><span id="IndexGenerator.generate-1025"><a href="#IndexGenerator.generate-1025"><span class="linenos">1025</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1026"><a href="#IndexGenerator.generate-1026"><span class="linenos">1026</span></a><span class="sd">        **Optional arguments**</span>
</span><span id="IndexGenerator.generate-1027"><a href="#IndexGenerator.generate-1027"><span class="linenos">1027</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1028"><a href="#IndexGenerator.generate-1028"><span class="linenos">1028</span></a><span class="sd">        *dim*:</span>
</span><span id="IndexGenerator.generate-1029"><a href="#IndexGenerator.generate-1029"><span class="linenos">1029</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1030"><a href="#IndexGenerator.generate-1030"><span class="linenos">1030</span></a><span class="sd">        A string specifying the remaining coord of the scalar indices. Defaults to &#39;time&#39;, which should be the choice for most use cases.</span>
</span><span id="IndexGenerator.generate-1031"><a href="#IndexGenerator.generate-1031"><span class="linenos">1031</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1032"><a href="#IndexGenerator.generate-1032"><span class="linenos">1032</span></a><span class="sd">        *slices*</span>
</span><span id="IndexGenerator.generate-1033"><a href="#IndexGenerator.generate-1033"><span class="linenos">1033</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1034"><a href="#IndexGenerator.generate-1034"><span class="linenos">1034</span></a><span class="sd">        A dictionary or iterable of dictionaries, each specifying a subset of *pattern_ds* to take before computing an index, with one index returned for each dictionary and for each variable. Subsetting is based on the *xr.Dataset.sel* method: e.g. *slices*=[dict(lag=0,index_val=1)] will produce 1 set of indices based on pattern_ds.sel(lag=0,index_val=1). If *slices*=None, no subsets are computed.</span>
</span><span id="IndexGenerator.generate-1035"><a href="#IndexGenerator.generate-1035"><span class="linenos">1035</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1036"><a href="#IndexGenerator.generate-1036"><span class="linenos">1036</span></a><span class="sd">        *ix_means*</span>
</span><span id="IndexGenerator.generate-1037"><a href="#IndexGenerator.generate-1037"><span class="linenos">1037</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1038"><a href="#IndexGenerator.generate-1038"><span class="linenos">1038</span></a><span class="sd">        If None, the mean of each index is calculated and subtracted, resulting in centred indices. Otherwise, *ix_means* should be a dictionary of index names and predefined mean values which are subtracted instead. Of most use for online computations, updating a precomputed index in a new dataset.</span>
</span><span id="IndexGenerator.generate-1039"><a href="#IndexGenerator.generate-1039"><span class="linenos">1039</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1040"><a href="#IndexGenerator.generate-1040"><span class="linenos">1040</span></a><span class="sd">        *ix_stds*</span>
</span><span id="IndexGenerator.generate-1041"><a href="#IndexGenerator.generate-1041"><span class="linenos">1041</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1042"><a href="#IndexGenerator.generate-1042"><span class="linenos">1042</span></a><span class="sd">        If None, the standard deviation of each index is calculated and is divided by, resulting in standardised indices. Otherwise, *ix_stds* should be a dictionary of index names and predefined std values which are divided by instead. Of most use for online computations, updating a precomputed index in a new dataset.</span>
</span><span id="IndexGenerator.generate-1043"><a href="#IndexGenerator.generate-1043"><span class="linenos">1043</span></a>
</span><span id="IndexGenerator.generate-1044"><a href="#IndexGenerator.generate-1044"><span class="linenos">1044</span></a><span class="sd">        *drop_blank*</span>
</span><span id="IndexGenerator.generate-1045"><a href="#IndexGenerator.generate-1045"><span class="linenos">1045</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1046"><a href="#IndexGenerator.generate-1046"><span class="linenos">1046</span></a><span class="sd">        A boolean. If True, drop indices where the corresponding pattern is entirely blank. If False, returns an all np.nan time series.</span>
</span><span id="IndexGenerator.generate-1047"><a href="#IndexGenerator.generate-1047"><span class="linenos">1047</span></a><span class="sd">        *in_place*</span>
</span><span id="IndexGenerator.generate-1048"><a href="#IndexGenerator.generate-1048"><span class="linenos">1048</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1049"><a href="#IndexGenerator.generate-1049"><span class="linenos">1049</span></a><span class="sd">        *strict_metadata*</span>
</span><span id="IndexGenerator.generate-1050"><a href="#IndexGenerator.generate-1050"><span class="linenos">1050</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1051"><a href="#IndexGenerator.generate-1051"><span class="linenos">1051</span></a><span class="sd">        If False, indices will be merged into a common dataset regardless of metadata. If True, nonmatching metadata will raise a ValueError.</span>
</span><span id="IndexGenerator.generate-1052"><a href="#IndexGenerator.generate-1052"><span class="linenos">1052</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1053"><a href="#IndexGenerator.generate-1053"><span class="linenos">1053</span></a><span class="sd">        **Returns</span>
</span><span id="IndexGenerator.generate-1054"><a href="#IndexGenerator.generate-1054"><span class="linenos">1054</span></a><span class="sd">        </span>
</span><span id="IndexGenerator.generate-1055"><a href="#IndexGenerator.generate-1055"><span class="linenos">1055</span></a><span class="sd">        An xarray.Dataset of indices with a single coordinate (*dim*).</span>
</span><span id="IndexGenerator.generate-1056"><a href="#IndexGenerator.generate-1056"><span class="linenos">1056</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="IndexGenerator.generate-1057"><a href="#IndexGenerator.generate-1057"><span class="linenos">1057</span></a>        <span class="c1">#Parse inputs</span>
</span><span id="IndexGenerator.generate-1058"><a href="#IndexGenerator.generate-1058"><span class="linenos">1058</span></a>        
</span><span id="IndexGenerator.generate-1059"><a href="#IndexGenerator.generate-1059"><span class="linenos">1059</span></a>        <span class="k">if</span> <span class="n">slices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1060"><a href="#IndexGenerator.generate-1060"><span class="linenos">1060</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="o">=</span><span class="p">[{}]</span>
</span><span id="IndexGenerator.generate-1061"><a href="#IndexGenerator.generate-1061"><span class="linenos">1061</span></a>        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">dict</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1062"><a href="#IndexGenerator.generate-1062"><span class="linenos">1062</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="o">=</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
</span><span id="IndexGenerator.generate-1063"><a href="#IndexGenerator.generate-1063"><span class="linenos">1063</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1064"><a href="#IndexGenerator.generate-1064"><span class="linenos">1064</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="o">=</span><span class="n">slices</span>
</span><span id="IndexGenerator.generate-1065"><a href="#IndexGenerator.generate-1065"><span class="linenos">1065</span></a>            
</span><span id="IndexGenerator.generate-1066"><a href="#IndexGenerator.generate-1066"><span class="linenos">1066</span></a>        <span class="k">if</span> <span class="n">ix_means</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">ix_stds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1067"><a href="#IndexGenerator.generate-1067"><span class="linenos">1067</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">user_params</span><span class="o">=</span><span class="kc">True</span>
</span><span id="IndexGenerator.generate-1068"><a href="#IndexGenerator.generate-1068"><span class="linenos">1068</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">=</span><span class="n">ix_means</span>
</span><span id="IndexGenerator.generate-1069"><a href="#IndexGenerator.generate-1069"><span class="linenos">1069</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">=</span><span class="n">ix_stds</span>
</span><span id="IndexGenerator.generate-1070"><a href="#IndexGenerator.generate-1070"><span class="linenos">1070</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1071"><a href="#IndexGenerator.generate-1071"><span class="linenos">1071</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">user_params</span><span class="o">=</span><span class="kc">False</span>
</span><span id="IndexGenerator.generate-1072"><a href="#IndexGenerator.generate-1072"><span class="linenos">1072</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">=</span><span class="p">{}</span>
</span><span id="IndexGenerator.generate-1073"><a href="#IndexGenerator.generate-1073"><span class="linenos">1073</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">=</span><span class="p">{}</span>
</span><span id="IndexGenerator.generate-1074"><a href="#IndexGenerator.generate-1074"><span class="linenos">1074</span></a>            
</span><span id="IndexGenerator.generate-1075"><a href="#IndexGenerator.generate-1075"><span class="linenos">1075</span></a>        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">=</span><span class="kc">None</span>
</span><span id="IndexGenerator.generate-1076"><a href="#IndexGenerator.generate-1076"><span class="linenos">1076</span></a>        
</span><span id="IndexGenerator.generate-1077"><a href="#IndexGenerator.generate-1077"><span class="linenos">1077</span></a>        <span class="c1">#Compute indices</span>
</span><span id="IndexGenerator.generate-1078"><a href="#IndexGenerator.generate-1078"><span class="linenos">1078</span></a>        <span class="n">indices</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_index</span><span class="p">(</span><span class="n">pattern_ds</span><span class="p">,</span><span class="n">series_ds</span><span class="p">,</span><span class="n">dim</span><span class="p">,</span><span class="n">sl</span><span class="p">)</span>\
</span><span id="IndexGenerator.generate-1079"><a href="#IndexGenerator.generate-1079"><span class="linenos">1079</span></a>                <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">slices</span><span class="p">]</span>
</span><span id="IndexGenerator.generate-1080"><a href="#IndexGenerator.generate-1080"><span class="linenos">1080</span></a>        <span class="k">try</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1081"><a href="#IndexGenerator.generate-1081"><span class="linenos">1081</span></a>            <span class="n">indices</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
</span><span id="IndexGenerator.generate-1082"><a href="#IndexGenerator.generate-1082"><span class="linenos">1082</span></a>        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1083"><a href="#IndexGenerator.generate-1083"><span class="linenos">1083</span></a>            <span class="k">if</span> <span class="n">strict_metadata</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1084"><a href="#IndexGenerator.generate-1084"><span class="linenos">1084</span></a>                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merge of indices failed. Consider &#39;strict_metadata=False&#39;&quot;</span><span class="p">)</span>
</span><span id="IndexGenerator.generate-1085"><a href="#IndexGenerator.generate-1085"><span class="linenos">1085</span></a>                <span class="k">raise</span> <span class="n">e</span>
</span><span id="IndexGenerator.generate-1086"><a href="#IndexGenerator.generate-1086"><span class="linenos">1086</span></a>            <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1087"><a href="#IndexGenerator.generate-1087"><span class="linenos">1087</span></a>                <span class="n">indices</span><span class="o">=</span><span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span><span class="n">compat</span><span class="o">=</span><span class="s1">&#39;override&#39;</span><span class="p">)</span>
</span><span id="IndexGenerator.generate-1088"><a href="#IndexGenerator.generate-1088"><span class="linenos">1088</span></a>            
</span><span id="IndexGenerator.generate-1089"><a href="#IndexGenerator.generate-1089"><span class="linenos">1089</span></a>        <span class="c1">#Optionally remove indices which are all nan    </span>
</span><span id="IndexGenerator.generate-1090"><a href="#IndexGenerator.generate-1090"><span class="linenos">1090</span></a>        <span class="k">if</span> <span class="n">drop_blank</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1091"><a href="#IndexGenerator.generate-1091"><span class="linenos">1091</span></a>            <span class="n">drop</span><span class="o">=</span><span class="p">(</span><span class="o">~</span><span class="n">indices</span><span class="o">.</span><span class="n">isnull</span><span class="p">())</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">==</span><span class="mi">0</span>
</span><span id="IndexGenerator.generate-1092"><a href="#IndexGenerator.generate-1092"><span class="linenos">1092</span></a>            <span class="n">drop</span><span class="o">=</span><span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">d</span> <span class="ow">in</span> <span class="n">drop</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()[</span><span class="s1">&#39;data_vars&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]]</span>
</span><span id="IndexGenerator.generate-1093"><a href="#IndexGenerator.generate-1093"><span class="linenos">1093</span></a>            <span class="n">indices</span><span class="o">=</span><span class="n">indices</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="n">drop</span><span class="p">)</span>
</span><span id="IndexGenerator.generate-1094"><a href="#IndexGenerator.generate-1094"><span class="linenos">1094</span></a>            <span class="n">_</span><span class="o">=</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">drop</span><span class="p">]</span>
</span><span id="IndexGenerator.generate-1095"><a href="#IndexGenerator.generate-1095"><span class="linenos">1095</span></a>        <span class="k">if</span> <span class="n">in_place</span><span class="p">:</span>
</span><span id="IndexGenerator.generate-1096"><a href="#IndexGenerator.generate-1096"><span class="linenos">1096</span></a>            <span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="o">=</span><span class="n">indices</span>
</span><span id="IndexGenerator.generate-1097"><a href="#IndexGenerator.generate-1097"><span class="linenos">1097</span></a>        <span class="k">return</span> <span class="n">indices</span>
</span></pre></div>


            <div class="docstring"><p>Compute standardised indices from an xarray.Dataset of patterns and an xarray.Dataset of arbitrary dimension variables.</p>

<p><strong>Arguments</strong></p>

<p><em>pattern_ds</em></p>

<p>An xarray.Dataset of patterns to project onto with arbitrary dimensions.</p>

<p><em>series_ds</em></p>

<p>An xarray.Dataset of variables to project onto the patterns. Coordinates of <em>series_ds</em> once subsetted using <em>slices</em> must match the dimensions of <em>pattern_ds</em> + the extra coord <em>dim</em>.</p>

<p><strong>Optional arguments</strong></p>

<p><em>dim</em>:</p>

<p>A string specifying the remaining coord of the scalar indices. Defaults to 'time', which should be the choice for most use cases.</p>

<p><em>slices</em></p>

<p>A dictionary or iterable of dictionaries, each specifying a subset of <em>pattern_ds</em> to take before computing an index, with one index returned for each dictionary and for each variable. Subsetting is based on the <em>xr.Dataset.sel</em> method: e.g. <em>slices</em>=[dict(lag=0,index_val=1)] will produce 1 set of indices based on pattern_ds.sel(lag=0,index_val=1). If <em>slices</em>=None, no subsets are computed.</p>

<p><em>ix_means</em></p>

<p>If None, the mean of each index is calculated and subtracted, resulting in centred indices. Otherwise, <em>ix_means</em> should be a dictionary of index names and predefined mean values which are subtracted instead. Of most use for online computations, updating a precomputed index in a new dataset.</p>

<p><em>ix_stds</em></p>

<p>If None, the standard deviation of each index is calculated and is divided by, resulting in standardised indices. Otherwise, <em>ix_stds</em> should be a dictionary of index names and predefined std values which are divided by instead. Of most use for online computations, updating a precomputed index in a new dataset.</p>

<p><em>drop_blank</em></p>

<p>A boolean. If True, drop indices where the corresponding pattern is entirely blank. If False, returns an all np.nan time series.
<em>in_place</em></p>

<p><em>strict_metadata</em></p>

<p>If False, indices will be merged into a common dataset regardless of metadata. If True, nonmatching metadata will raise a ValueError.</p>

<p>**Returns</p>

<p>An xarray.Dataset of indices with a single coordinate (<em>dim</em>).</p>
</div>


                            </div>
                            <div id="IndexGenerator.get_standardisation_params" class="classattr">
                                        <input id="IndexGenerator.get_standardisation_params-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
<div class="attr function">
            
        <span class="def">def</span>
        <span class="name">get_standardisation_params</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span></span><span class="return-annotation">):</span></span>

                <label class="view-source-button" for="IndexGenerator.get_standardisation_params-view-source"><span>View Source</span></label>

    </div>
    <a class="headerlink" href="#IndexGenerator.get_standardisation_params"></a>
            <div class="pdoc-code codehilite"><pre><span></span><span id="IndexGenerator.get_standardisation_params-1142"><a href="#IndexGenerator.get_standardisation_params-1142"><span class="linenos">1142</span></a>    <span class="k">def</span> <span class="nf">get_standardisation_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">as_dict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
</span><span id="IndexGenerator.get_standardisation_params-1143"><a href="#IndexGenerator.get_standardisation_params-1143"><span class="linenos">1143</span></a><span class="w">        </span>
</span><span id="IndexGenerator.get_standardisation_params-1144"><a href="#IndexGenerator.get_standardisation_params-1144"><span class="linenos">1144</span></a><span class="w">        </span><span class="sd">&quot;&quot;&quot; Retrieve index means and stds for computed indices, for use as future inputs into index_means or index_stds in *IndexGenerator.Generate*</span>
</span><span id="IndexGenerator.get_standardisation_params-1145"><a href="#IndexGenerator.get_standardisation_params-1145"><span class="linenos">1145</span></a><span class="sd">        &quot;&quot;&quot;</span>
</span><span id="IndexGenerator.get_standardisation_params-1146"><a href="#IndexGenerator.get_standardisation_params-1146"><span class="linenos">1146</span></a>        <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
</span><span id="IndexGenerator.get_standardisation_params-1147"><a href="#IndexGenerator.get_standardisation_params-1147"><span class="linenos">1147</span></a>            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span>
</span><span id="IndexGenerator.get_standardisation_params-1148"><a href="#IndexGenerator.get_standardisation_params-1148"><span class="linenos">1148</span></a>        <span class="k">else</span><span class="p">:</span>
</span><span id="IndexGenerator.get_standardisation_params-1149"><a href="#IndexGenerator.get_standardisation_params-1149"><span class="linenos">1149</span></a>            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">means</span><span class="p">),</span><span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stds</span><span class="p">)]</span>
</span><span id="IndexGenerator.get_standardisation_params-1150"><a href="#IndexGenerator.get_standardisation_params-1150"><span class="linenos">1150</span></a>            <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="s1">&#39;param&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">assign_coords</span><span class="p">({</span><span class="s1">&#39;param&#39;</span><span class="p">:[</span><span class="s1">&#39;mean&#39;</span><span class="p">,</span><span class="s1">&#39;std&#39;</span><span class="p">]})</span>
</span></pre></div>


            <div class="docstring"><p>Retrieve index means and stds for computed indices, for use as future inputs into index_means or index_stds in <em>IndexGenerator.Generate</em></p>
</div>


                            </div>
                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.kind) {
                    case "function":
                        if (doc.fullname.endsWith(".__init__")) {
                            heading = `<span class="name">${doc.fullname.replace(/\.__init__$/, "")}</span>${doc.signature}`;
                        } else {
                            heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span>${doc.signature}`;
                        }
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        if (doc.bases)
                            heading += `<wbr>(<span class="base">${doc.bases}</span>)`;
                        heading += `:`;
                        break;
                    case "variable":
                        heading = `<span class="name">${doc.fullname}</span>`;
                        if (doc.annotation)
                            heading += `<span class="annotation">${doc.annotation}</span>`;
                        if (doc.default_value)
                            heading += `<span class="default_value"> = ${doc.default_value}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.kind}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>